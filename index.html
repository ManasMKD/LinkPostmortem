<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Postmortem | Ultimate Suite</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, doc, updateDoc, getDocs } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        // ============================================
        // FIREBASE CONFIGURATION
        // ============================================
        const firebaseConfig = {
            apiKey: "AIzaSyC8Ce3i_s0sfemJ6iRZhsdUnZMNFSfwIuM",
            authDomain: "link-postmortem.firebaseapp.com",
            projectId: "link-postmortem",
            storageBucket: "link-postmortem.firebasestorage.app",
            messagingSenderId: "349174304404",
            appId: "1:349174304404:web:b6f9d8ae5db19f926a6e81",
            measurementId: "G-GE65L6YQ7D"
        };
        // ============================================

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            
            // Make Firebase functions globally available
            window.firebaseDB = db;
            window.firebaseAddDoc = addDoc;
            window.firebaseCollection = collection;
            window.firebaseQuery = query;
            window.firebaseOrderBy = orderBy;
            window.firebaseOnSnapshot = onSnapshot;
            window.firebaseServerTimestamp = serverTimestamp;
            window.firebaseDoc = doc;
            window.firebaseUpdateDoc = updateDoc;
            window.firebaseGetDocs = getDocs;
            
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            window.firebaseDB = null;
        }
    </script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { 
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace']
                    },
                    colors: {
                        zinc: { 950: '#09090b' },
                        cyan: { 950: '#083344' }
                    },
                    animation: {
                        'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <style>
        body { background-color: #000000; color: #d4d4d8; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        textarea::-webkit-scrollbar { width: 8px; }
        textarea::-webkit-scrollbar-track { background: #18181b; }
        textarea::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 4px; }
        textarea::-webkit-scrollbar-thumb:hover { background: #52525b; }
        
        .btn-scroll::-webkit-scrollbar { width: 4px; }
        .btn-scroll::-webkit-scrollbar-track { background: transparent; }
        .btn-scroll::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 4px; }

        .animate-in { animation: fadeIn 0.5s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .no-select {
            user-select: none;
            -webkit-user-select: none;
        }

        /* Sonic Visualizer Canvas */
        #sonic-canvas {
            width: 100%;
            height: 100px;
            background: #000;
            border-bottom: 1px solid #1e293b;
        }

        /* YouTube Result Styles */
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Ghost Comms Chat Styles */
        #ghost-messages::-webkit-scrollbar {
            width: 6px;
        }
        #ghost-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        #ghost-messages::-webkit-scrollbar-thumb {
            background: #3f3f46;
            border-radius: 3px;
        }
        #ghost-messages::-webkit-scrollbar-thumb:hover {
            background: #52525b;
        }

        .message-bubble {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-own {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }

        .message-other {
            background: #27272a;
            color: #e4e4e7;
            margin-right: auto;
            border-bottom-left-radius: 4px;
        }

        /* Floating Button Styles */
        #ghost-float-btn {
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        #ghost-modal {
            animation: fadeIn 0.3s ease-out;
        }

        /* HACKER TRAP - GLITCH MODE */
        .system-breach {
            animation: glitch 0.3s infinite, colorShift 0.5s infinite, shake 0.1s infinite;
            filter: invert(1) hue-rotate(180deg);
            position: relative;
            overflow: hidden;
        }

        .system-breach::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,0,0,0.1) 2px, rgba(255,0,0,0.1) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0,255,0,0.1) 2px, rgba(0,255,0,0.1) 4px);
            pointer-events: none;
            z-index: 9999;
            animation: noise 0.2s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }

        @keyframes colorShift {
            0% { filter: invert(1) hue-rotate(0deg); }
            25% { filter: invert(1) hue-rotate(90deg); }
            50% { filter: invert(1) hue-rotate(180deg); }
            75% { filter: invert(1) hue-rotate(270deg); }
            100% { filter: invert(1) hue-rotate(360deg); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes noise {
            0% { opacity: 0.1; }
            50% { opacity: 0.3; }
            100% { opacity: 0.1; }
        }

        /* SECURITY BREACH MODAL */
        #security-breach-modal {
            animation: fadeIn 0.2s ease-out;
            z-index: 10000;
        }

        .breach-warning {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            border: 3px solid #fca5a5;
            box-shadow: 0 0 30px rgba(220, 38, 38, 0.8), inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* CHAOS MODE - PHYSICS */
        .physics-active {
            position: relative;
        }

        .physics-body {
            position: absolute;
            pointer-events: none;
        }

        /* SONIC PULSE - AUDIO VISUALIZATION */
        .pulse-active {
            transition: box-shadow 0.1s ease-out, transform 0.1s ease-out;
        }

        /* GLITCH OVERLAY FOR PIRACY DETECTION */
        .glitch-overlay {
            display: none;
            position: fixed;
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
            color: red;
            font-family: 'Courier New', monospace;
            text-align: center;
            padding-top: 20%;
            font-size: 2rem;
        }

        /* MOBILE RESPONSIVE FIXES */
        @media (max-width: 768px) {
            /* Fix container padding on mobile */
            .container {
                padding-left: 1rem;
                padding-right: 1rem;
            }

            /* Fix navigation on mobile */
            nav {
                padding-left: 1rem;
                padding-right: 1rem;
            }

            /* Fix ghost modal on mobile */
            #ghost-modal {
                padding: 0;
                align-items: stretch;
            }

            #ghost-modal > div {
                max-width: 100%;
                max-height: 100vh;
                height: 100vh;
                border-radius: 0;
                margin: 0;
            }

            /* Fix ghost join panel on mobile */
            #ghost-join-panel {
                width: 100%;
                max-width: 100%;
                border-right: none;
                border-bottom: 1px solid rgb(39 39 42);
            }

            /* Stack ghost modal content on mobile */
            #ghost-modal > div > div.flex {
                flex-direction: column;
            }

            /* Fix chat area on mobile */
            #ghost-modal .flex-1.flex.flex-col {
                min-height: 0;
            }

            /* Fix messages container on mobile */
            #ghost-messages {
                min-height: 300px;
                padding: 1rem;
            }

            /* Fix input area on mobile */
            .input-area {
                padding: 0.75rem;
            }

            /* Fix message bubbles on mobile */
            .message-bubble {
                max-width: 90% !important;
                font-size: 0.875rem;
            }

            /* Fix buttons on mobile */
            button, .icon-btn {
                min-height: 44px; /* Touch target size */
                min-width: 44px;
            }

            /* Fix floating button on mobile */
            #ghost-float-btn {
                width: 56px;
                height: 56px;
                bottom: 1rem;
                right: 1rem;
            }

            /* Fix modals on mobile */
            .call-modal, #incoming-call-modal, #memory-warning-modal {
                padding: 1rem;
            }

            .call-modal > div, #incoming-call-modal > div, #memory-warning-modal > div {
                max-width: 95%;
                padding: 1.5rem;
            }

            /* Fix active call interface on mobile */
            #active-call-interface {
                left: 50%;
                transform: translateX(-50%);
                width: calc(100% - 2rem);
                max-width: 100%;
                padding: 0.75rem;
            }

            /* Fix text sizes on mobile */
            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            /* Fix tabs on mobile */
            .tab-content {
                padding: 1rem 0;
            }

            /* Fix form inputs on mobile */
            input, textarea, select {
                font-size: 16px; /* Prevents zoom on iOS */
            }

            /* Fix ghost message input on mobile */
            #ghost-message-input {
                font-size: 16px;
                padding: 0.75rem;
            }

            /* Fix emoji and GIF pickers on mobile */
            #ghost-emoji-picker, #ghost-gif-picker {
                width: calc(100vw - 2rem);
                max-width: 100%;
                left: 1rem;
                right: 1rem;
            }

            /* Fix GIF grid on mobile */
            #ghost-gif-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            /* Extra small mobile fixes */
            h1 {
                font-size: 1.5rem;
            }

            .message-bubble {
                max-width: 95% !important;
                padding: 0.5rem;
            }

            #ghost-float-btn {
                width: 48px;
                height: 48px;
            }

            /* Stack header controls on very small screens */
            .header-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body class="selection:bg-rose-900 selection:text-white min-h-screen flex flex-col no-select">

    <!-- NAVIGATION -->
    <nav class="sticky top-0 z-50 bg-black/80 backdrop-blur-xl border-b border-zinc-900">
        <div class="container mx-auto px-4 md:px-8 h-16 flex items-center justify-between">
            <div class="flex items-center gap-3 cursor-pointer" onclick="location.reload()">
                <div class="w-8 h-8 bg-zinc-900 border border-zinc-800 rounded-lg flex items-center justify-center text-rose-600 font-bold text-xl shadow-[0_0_15px_rgba(225,29,72,0.3)]">
                    <i data-lucide="skull" class="w-5 h-5"></i>
                </div>
                <span class="text-xl font-bold text-white tracking-wider">
                    Link <span class="text-rose-600">Postmortem</span>
                </span>
            </div>

            <!-- Desktop Nav -->
            <div class="hidden md:flex items-center gap-1 bg-zinc-900/50 p-1 rounded-full border border-zinc-800">
                <button type="button" onclick="switchTab('downloader')" id="btn-nav-downloader" class="px-5 py-1.5 rounded-full text-xs font-medium transition-all bg-zinc-800 text-white shadow-lg">Downloader</button>
                <button type="button" onclick="switchTab('crypter')" id="btn-nav-crypter" class="px-5 py-1.5 rounded-full text-xs font-medium transition-all text-zinc-500 hover:text-zinc-300">Encrypter</button>
                <button type="button" onclick="switchTab('keys')" id="btn-nav-keys" class="px-5 py-1.5 rounded-full text-xs font-medium transition-all text-zinc-500 hover:text-zinc-300">Key Forge</button>
                <button type="button" onclick="switchTab('stego')" id="btn-nav-stego" class="px-5 py-1.5 rounded-full text-xs font-medium transition-all text-zinc-500 hover:text-zinc-300">Stego Lab</button>
                <button type="button" onclick="switchTab('sonic')" id="btn-nav-sonic" class="px-5 py-1.5 rounded-full text-xs font-medium transition-all text-cyan-500 hover:text-cyan-300 border border-transparent hover:border-cyan-900/50 flex items-center gap-1">
                    <i data-lucide="waves" class="w-3 h-3"></i> Sonic Lab
                </button>
            </div>

            <!-- Mobile Menu Toggle -->
            <button type="button" onclick="toggleMenu()" class="md:hidden p-2 text-zinc-400">
                <i data-lucide="menu" class="w-6 h-6"></i>
            </button>
        </div>

        <!-- Mobile Menu -->
        <div id="mobile-menu" class="hidden md:hidden bg-zinc-950 border-b border-zinc-900 p-4 flex flex-col gap-4">
            <button type="button" onclick="switchTab('downloader'); toggleMenu()" class="text-left text-zinc-300 font-medium p-2 hover:bg-zinc-900 rounded">Downloader</button>
            <button type="button" onclick="switchTab('crypter'); toggleMenu()" class="text-left text-zinc-300 font-medium p-2 hover:bg-zinc-900 rounded">Link Crypter</button>
            <button type="button" onclick="switchTab('keys'); toggleMenu()" class="text-left text-zinc-300 font-medium p-2 hover:bg-zinc-900 rounded">Key Forge</button>
            <button type="button" onclick="switchTab('stego'); toggleMenu()" class="text-left text-zinc-300 font-medium p-2 hover:bg-zinc-900 rounded">Steganography</button>
            <button type="button" onclick="switchTab('sonic'); toggleMenu()" class="text-left text-cyan-400 font-medium p-2 hover:bg-zinc-900 rounded">Sonic Lab</button>
        </div>
    </nav>

    <!-- MAIN CONTENT -->
    <main class="relative pt-12 pb-24 overflow-hidden flex-grow relative">
        
        <!-- Background Gradients -->
        <div class="absolute top-0 left-1/2 -translate-x-1/2 w-full h-full z-0 pointer-events-none opacity-20">
            <div class="absolute top-20 left-1/4 w-[300px] md:w-[500px] h-[300px] md:h-[500px] bg-rose-900/40 rounded-full mix-blend-screen filter blur-[80px] md:blur-[100px] animate-pulse"></div>
            <div class="absolute bottom-20 right-1/4 w-[300px] md:w-[400px] h-[300px] md:h-[400px] bg-indigo-900/40 rounded-full mix-blend-screen filter blur-[80px] md:blur-[100px]"></div>
        </div>

        <div class="container mx-auto px-4 relative z-10">

            <!-- TAB: DOWNLOADER -->
            <div id="tab-downloader" class="tab-content active animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-6xl font-black tracking-tight mb-4 text-white">
                        Extract <span class="text-transparent bg-clip-text bg-gradient-to-r from-rose-500 to-orange-600">Remote</span> Content
                    </h1>
                    <p class="text-zinc-500 max-w-xl mx-auto text-lg">
                        Bypass restrictions and access your files directly via our secure tunnel.
                    </p>
                </div>

                <div class="max-w-3xl mx-auto bg-zinc-900/50 backdrop-blur-md rounded-2xl shadow-2xl border border-zinc-800 p-3 mb-8">
                    <form onsubmit="handleDownload(event)" class="relative flex flex-col md:flex-row gap-2">
                        <div class="relative flex-grow">
                            <div class="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none text-zinc-500">
                                <i data-lucide="link" class="w-5 h-5"></i>
                            </div>
                            <input type="text" id="dl-input" placeholder="Paste source link (Cloud or Direct)..." 
                                class="w-full pl-12 pr-10 py-4 rounded-xl bg-black border border-zinc-800 focus:border-rose-600 focus:ring-1 focus:ring-rose-600 outline-none transition-all text-white placeholder:text-zinc-600">
                            <button type="button" onclick="clearInput('dl-input')" class="absolute inset-y-0 right-0 pr-4 flex items-center text-zinc-600 hover:text-zinc-300 transition-colors">
                                <i data-lucide="x" class="w-4 h-4"></i>
                            </button>
                        </div>
                        <button type="submit" id="dl-btn"
                            class="bg-rose-600 hover:bg-rose-700 disabled:bg-zinc-700 disabled:text-zinc-500 text-white font-bold py-4 px-8 rounded-xl transition-all flex items-center justify-center gap-2 shadow-[0_0_20px_rgba(225,29,72,0.3)] hover:shadow-[0_0_30px_rgba(225,29,72,0.5)]">
                            <i data-lucide="download" class="w-5 h-5"></i>
                            <span>Extract</span>
                        </button>
                    </form>
                </div>

                <div id="dl-error" class="hidden max-w-3xl mx-auto mb-8 p-4 bg-rose-950/30 text-rose-400 border border-rose-900/50 rounded-xl flex items-center justify-center gap-2">
                    <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                    <span id="dl-error-text"></span>
                </div>

                <div id="media-result" class="hidden max-w-3xl mx-auto mt-8 animate-in">
                    <div class="bg-zinc-900 border border-zinc-800 rounded-xl p-6 flex flex-col items-center text-center">
                        <div class="w-16 h-16 bg-rose-900/20 rounded-full flex items-center justify-center text-rose-500 mb-4 animate-pulse">
                            <i data-lucide="file-video" class="w-8 h-8"></i>
                        </div>
                        <h3 class="text-xl font-bold text-white mb-2">Direct Media Detected</h3>
                        <p class="text-zinc-400 mb-6 text-sm max-w-md">The link appears to be a direct media file. You can access it directly.</p>
                        <a id="media-download-btn" href="#" target="_blank" rel="noopener noreferrer" 
                           class="bg-white text-black hover:bg-zinc-200 font-bold py-3 px-8 rounded-full flex items-center gap-2 transition-all shadow-lg hover:scale-105">
                            <i data-lucide="download" class="w-4 h-4"></i> <span id="media-btn-label">Download / Play</span>
                        </a>
                    </div>
                </div>


                <div id="dl-result" class="hidden max-w-5xl mx-auto mt-8 animate-in">
                    <div class="bg-zinc-900 border border-zinc-800 rounded-xl p-4 mb-4 flex flex-col md:flex-row items-center justify-between gap-4">
                        <div class="flex items-center gap-3">
                            <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                            <p class="text-sm text-zinc-300">Tunnel established. Loading content...</p>
                        </div>
                        <a id="dl-external-link" href="#" target="_blank" rel="noopener noreferrer"
                            class="bg-zinc-800 hover:bg-zinc-700 border border-zinc-700 text-white px-5 py-2.5 rounded-lg text-sm font-semibold flex items-center gap-2 transition-colors">
                            Open in New Tab <i data-lucide="external-link" class="w-4 h-4"></i>
                        </a>
                    </div>
                    <div class="bg-black rounded-2xl shadow-2xl overflow-hidden border border-zinc-800 relative h-[600px]">
                        <iframe id="dl-iframe" src="" title="Secure Download Server" class="w-full h-full border-0" sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe>
                    </div>
                </div>
            </div>

            <!-- TAB: CRYPTER -->
            <div id="tab-crypter" class="tab-content animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4 text-white">
                        Link <span class="text-rose-600">Obfuscator</span>
                    </h1>
                    <p class="text-zinc-500 max-w-lg mx-auto">Encrypt multiple links into a single payload with time-locks.</p>
                </div>

                <div class="max-w-4xl mx-auto grid md:grid-cols-2 gap-6 bg-zinc-900/30 p-2 rounded-2xl border border-zinc-800 backdrop-blur-sm">
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col h-full">
                        <div class="flex justify-between items-center mb-4">
                            <label class="text-sm font-bold text-zinc-400 uppercase tracking-wider">Input Payload</label>
                            <div class="flex bg-zinc-900 rounded-lg p-1 border border-zinc-800">
                                <button type="button" onclick="setCryptoMode('encrypt')" id="mode-encrypt" class="p-1.5 rounded-md transition-all bg-zinc-700 text-white"><i data-lucide="lock" class="w-4 h-4"></i></button>
                                <button type="button" onclick="setCryptoMode('decrypt')" id="mode-decrypt" class="p-1.5 rounded-md transition-all text-zinc-600 hover:text-zinc-400"><i data-lucide="unlock" class="w-4 h-4"></i></button>
                            </div>
                        </div>
                        <div class="relative w-full flex-grow flex flex-col">
                            <textarea id="crypto-input" placeholder="Paste link(s) here..." class="w-full flex-grow bg-zinc-900 border border-zinc-800 rounded-lg p-4 pr-10 text-zinc-300 focus:border-rose-600 outline-none resize-none font-mono text-sm min-h-[150px]"></textarea>
                            <div class="absolute top-2 right-2 flex flex-col gap-1">
                                <button type="button" onclick="clearInput('crypto-input')" class="p-1.5 text-zinc-500 hover:text-white bg-zinc-800/50 rounded"><i data-lucide="x" class="w-3 h-3"></i></button>
                                <button type="button" onclick="pasteToInput('crypto-input')" class="p-1.5 text-zinc-500 hover:text-white bg-zinc-800/50 rounded"><i data-lucide="clipboard" class="w-3 h-3"></i></button>
                            </div>
                        </div>
                        <div id="crypto-settings" class="mt-4 grid grid-cols-2 gap-3">
                            <div>
                                <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Passcode</label>
                                <input type="text" id="crypto-pass" placeholder="Optional PIN" class="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-3 py-2 text-sm text-white focus:border-rose-600 outline-none">
                            </div>
                            <div id="crypto-expiry-container">
                                <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Lifespan</label>
                                <select id="crypto-expiry" class="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-3 py-2 text-sm text-zinc-300 focus:border-rose-600 outline-none">
                                    <option value="0">Eternal</option>
                                    <option value="5">5 Minutes</option>
                                    <option value="60">1 Hour</option>
                                    <option value="1440">24 Hours</option>
                                </select>
                            </div>
                        </div>
                        <button type="button" onclick="handleCryptoProcess()" id="crypto-action-btn" class="mt-4 w-full bg-white text-black hover:bg-zinc-200 font-bold py-3 rounded-lg flex items-center justify-center gap-2">
                            <i data-lucide="lock" id="action-icon" class="w-4 h-4"></i> <span id="action-text">Encrypt Payload</span>
                        </button>
                    </div>

                    <div class="bg-zinc-900/80 p-6 rounded-xl border border-zinc-800 flex flex-col h-full relative overflow-hidden">
                        <div class="absolute top-0 right-0 w-20 h-20 bg-rose-600/10 blur-xl rounded-full"></div>
                        <div class="flex justify-between items-center mb-4 relative z-10">
                            <label class="text-sm font-bold text-zinc-400 uppercase tracking-wider">Result</label>
                            <div class="flex gap-2">
                                <button type="button" id="btn-copy" onclick="copyToClipboard()" class="hidden text-xs flex items-center gap-1 text-rose-500 hover:text-rose-400 font-medium"><i data-lucide="copy" class="w-3 h-3"></i> <span>Copy</span></button>
                            </div>
                        </div>
                        <div class="flex-grow bg-black border border-zinc-800 rounded-lg p-4 relative min-h-[150px] flex flex-col overflow-hidden">
                            <div id="result-empty" class="h-full flex flex-col items-center justify-center text-zinc-700">
                                <i data-lucide="refresh-cw" class="mb-2 opacity-20 w-8 h-8"></i> <span class="text-xs">Waiting...</span>
                            </div>
                            <div id="result-text" class="hidden break-all font-mono text-sm text-emerald-400"></div>
                            <div id="result-launch" class="hidden absolute inset-0 flex flex-col items-center justify-start bg-black/60 backdrop-blur-[1px] pt-4">
                                <div id="launch-buttons-container" class="flex flex-col gap-2 w-full px-4 overflow-y-auto btn-scroll items-center mb-2 justify-start flex-grow" style="max-height: 200px;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- TAB: KEY FORGE -->
            <div id="tab-keys" class="tab-content animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4 text-white">
                        Key <span class="text-amber-500">Forge</span>
                    </h1>
                    <p class="text-zinc-500 max-w-lg mx-auto">
                        Split your secret into multiple keys. <br><span class="text-amber-500/80">ALL</span> generated keys are required to unlock the data.
                    </p>
                </div>

                <div class="max-w-4xl mx-auto grid md:grid-cols-2 gap-6 bg-zinc-900/30 p-4 rounded-2xl border border-zinc-800 backdrop-blur-sm">
                    
                    <!-- KEY GENERATION -->
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col gap-4">
                        <div class="flex items-center gap-2 mb-2 border-b border-amber-900/30 pb-2">
                            <i data-lucide="hammer" class="text-amber-500 w-5 h-5"></i>
                            <h3 class="font-bold text-white uppercase tracking-wider text-sm">Forge New Keys</h3>
                        </div>
                        
                        <div>
                            <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-1 block">Secret Message / URL</label>
                            <textarea id="keys-input" placeholder="Enter the secret to split..." class="w-full bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-amber-100 focus:border-amber-500 outline-none resize-none font-mono text-xs h-24 placeholder:text-zinc-700"></textarea>
                        </div>

                        <div class="bg-zinc-900/50 p-3 rounded-lg border border-zinc-800">
                            <div class="flex justify-between items-center mb-2">
                                <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider">Number of Keys</label>
                                <span id="keys-count-val" class="text-amber-500 font-bold font-mono text-sm">3</span>
                            </div>
                            <input type="range" id="keys-count" min="2" max="10" value="3" class="w-full h-2 bg-zinc-800 rounded-lg appearance-none cursor-pointer accent-amber-500" oninput="document.getElementById('keys-count-val').innerText = this.value; document.getElementById('keys-req-val').innerText = this.value;">
                            <p class="text-[10px] text-zinc-500 mt-2 text-center">
                                * To decrypt, the user will need exactly <span id="keys-req-val" class="text-amber-500 font-bold">3</span> keys.
                            </p>
                        </div>

                        <button onclick="forgeKeys()" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 mt-auto shadow-lg shadow-amber-900/20">
                            <i data-lucide="key" class="w-4 h-4"></i> Generate Keys
                        </button>

                        <div id="forge-output" class="hidden w-full bg-zinc-950 border border-amber-900/50 rounded-lg p-3 font-mono text-[10px] text-amber-400 break-all relative max-h-40 overflow-y-auto btn-scroll">
                            <!-- Output -->
                        </div>
                    </div>

                    <!-- KEY UNLOCK -->
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col gap-4">
                        <div class="flex items-center gap-2 mb-2 border-b border-zinc-800 pb-2">
                            <i data-lucide="unlock" class="text-zinc-400 w-5 h-5"></i>
                            <h3 class="font-bold text-white uppercase tracking-wider text-sm">Unlock Vault</h3>
                        </div>

                        <div class="flex-grow flex flex-col">
                            <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-1 block">Input Keys (One per line)</label>
                            <textarea id="keys-unlock-input" placeholder="Paste Key 1&#10;Paste Key 2&#10;..." class="w-full flex-grow bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-zinc-300 focus:border-amber-500 outline-none resize-none font-mono text-xs placeholder:text-zinc-700 min-h-[150px]"></textarea>
                        </div>

                        <button onclick="unlockKeys()" class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-3 rounded-lg border border-zinc-700 flex items-center justify-center gap-2">
                            <i data-lucide="folder-open" class="w-4 h-4"></i> Combine & Reveal
                        </button>

                        <div id="unlock-result" class="hidden w-full bg-zinc-950 border border-zinc-800 rounded-lg p-3 font-mono text-sm text-center break-all"></div>
                    </div>

                </div>
            </div>

            <!-- TAB: STEGO LAB -->
            <div id="tab-stego" class="tab-content animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4 text-white">
                        Stego <span class="text-rose-600">Lab</span>
                    </h1>
                    <p class="text-zinc-500 max-w-lg mx-auto">Inject encrypted payloads into image pixels.</p>
                </div>

                <div class="max-w-5xl mx-auto grid md:grid-cols-2 gap-8 bg-zinc-900/30 p-4 rounded-2xl border border-zinc-800 backdrop-blur-sm">
                    <!-- Inject -->
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col gap-4">
                        <div class="flex items-center gap-2 mb-2 border-b border-zinc-800 pb-2">
                            <i data-lucide="file-plus" class="text-rose-500 w-5 h-5"></i>
                            <h3 class="font-bold text-white uppercase tracking-wider text-sm">Injection</h3>
                        </div>
                        <div class="space-y-3">
                            <div>
                                <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-1 block">Carrier</label>
                                <div class="flex gap-2">
                                    <label class="flex-1 cursor-pointer bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded-lg p-2 text-xs text-center border border-zinc-700 flex items-center justify-center gap-2">
                                        <input type="file" id="stego-upload-inject" accept="image/*" class="hidden" onchange="document.getElementById('file-name-display').innerText = this.files[0]?.name || 'Upload Image'"/>
                                        <i data-lucide="upload" class="w-3 h-3"></i> <span id="file-name-display">Upload Image</span>
                                    </label>
                                    <button type="button" onclick="generateCarrierImage()" class="flex-1 bg-indigo-900/50 hover:bg-indigo-900 text-indigo-200 rounded-lg p-2 text-xs border border-indigo-800 flex items-center justify-center gap-2">
                                        <i data-lucide="cpu" class="w-3 h-3"></i> Auto-Generate
                                    </button>
                                </div>
                                <div id="generated-status" class="hidden text-[10px] text-indigo-400 mt-1 text-center">
                                    <i data-lucide="check" class="w-3 h-3 inline"></i> Carrier Generated
                                </div>
                            </div>
                            <textarea id="stego-text-inject" placeholder="Payload..." class="w-full bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-zinc-300 focus:border-rose-600 outline-none resize-none font-mono text-xs h-20"></textarea>
                            <input type="text" id="stego-pass-inject" placeholder="Passcode (Optional)" class="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-3 py-2 text-sm text-white focus:border-rose-600 outline-none">
                        </div>
                        <button type="button" onclick="stegoInject()" class="w-full bg-rose-600 hover:bg-rose-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 mt-auto">
                            <i data-lucide="syringe" class="w-4 h-4"></i> Inject & Download
                        </button>
                    </div>

                    <!-- Extract -->
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col gap-4">
                        <div class="flex items-center gap-2 mb-2 border-b border-zinc-800 pb-2">
                            <i data-lucide="scan-eye" class="text-emerald-500 w-5 h-5"></i>
                            <h3 class="font-bold text-white uppercase tracking-wider text-sm">Batch Extraction</h3>
                        </div>
                        <div>
                            <input type="file" id="stego-upload-extract" multiple accept="image/*" class="block w-full text-sm text-zinc-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-zinc-800 file:text-white hover:file:bg-zinc-700 cursor-pointer"/>
                        </div>
                        <input type="text" id="stego-pass-extract" placeholder="Decryption Passcode" class="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-3 py-2 text-sm text-white focus:border-emerald-600 outline-none">
                        <div id="stego-result-area" class="w-full bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-zinc-500 font-mono text-xs h-64 overflow-y-auto break-all relative">
                            <div class="absolute inset-0 flex items-center justify-center opacity-30 pointer-events-none">Waiting...</div>
                        </div>
                        <button type="button" onclick="stegoExtract()" class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-3 rounded-lg border border-zinc-700 flex items-center justify-center gap-2">
                            <i data-lucide="download-cloud" class="w-4 h-4"></i> Extract Data
                        </button>
                    </div>
                </div>
            </div>

            <!-- TAB: SONIC LAB (NEW EXPERIMENT) -->
            <div id="tab-sonic" class="tab-content animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4 text-white">
                        Sonic <span class="text-cyan-500">Lab</span> <span class="text-xs align-top bg-cyan-900/30 text-cyan-300 px-2 py-1 rounded ml-2 font-mono font-normal tracking-wide">BETA</span>
                    </h1>
                    <p class="text-zinc-500 max-w-lg mx-auto">
                        Audio Steganography. Hide data inside "Dark Ambient" drone frequencies.
                    </p>
                </div>

                <!-- Visualizer -->
                <div class="max-w-4xl mx-auto mb-8 bg-black border border-cyan-900/50 rounded-xl overflow-hidden shadow-[0_0_30px_rgba(8,145,178,0.1)] relative">
                    <canvas id="sonic-canvas"></canvas>
                    <div class="absolute top-2 left-3 text-[10px] font-mono text-cyan-500/50 uppercase tracking-widest">Frequency Domain Monitor</div>
                </div>

                <div class="max-w-4xl mx-auto grid md:grid-cols-2 gap-8 bg-cyan-950/10 p-6 rounded-2xl border border-cyan-900/30 backdrop-blur-sm">
                    
                    <!-- ENCODE AUDIO -->
                    <div class="space-y-4">
                        <div class="flex items-center gap-2 text-cyan-400 border-b border-cyan-900/30 pb-2">
                            <i data-lucide="mic" class="w-5 h-5"></i>
                            <h3 class="font-bold uppercase tracking-wider text-sm">Generate Carrier Signal</h3>
                        </div>
                        <p class="text-xs text-zinc-500">Creates a generated 10s audio file with data embedded in the noise floor.</p>
                        
                        <textarea id="sonic-input" placeholder="Enter secret message to modulate..." class="w-full bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-cyan-100 focus:border-cyan-500 outline-none resize-none font-mono text-xs h-32 placeholder:text-zinc-600"></textarea>
                        
                        <button onclick="generateSonic()" id="btn-sonic-gen" class="w-full bg-cyan-900 hover:bg-cyan-800 text-cyan-100 border border-cyan-700/50 font-bold py-3 rounded-lg transition-all flex items-center justify-center gap-2 shadow-lg shadow-cyan-900/20">
                            <i data-lucide="activity" class="w-4 h-4"></i> Generate & Download WAV
                        </button>
                    </div>

                    <!-- DECODE AUDIO -->
                    <div class="space-y-4">
                        <div class="flex items-center gap-2 text-rose-400 border-b border-rose-900/30 pb-2">
                            <i data-lucide="headphones" class="w-5 h-5"></i>
                            <h3 class="font-bold uppercase tracking-wider text-sm">Analyze Audio Signal</h3>
                        </div>
                        <p class="text-xs text-zinc-500">Upload a WAV file generated by this lab.</p>

                        <div class="border-2 border-dashed border-zinc-800 rounded-xl p-8 text-center hover:border-cyan-800 transition-colors group cursor-pointer relative bg-zinc-900/50">
                            <input type="file" id="sonic-upload" accept=".wav" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" onchange="handleSonicUpload(this)">
                            <div class="flex flex-col items-center">
                                <i data-lucide="music" class="w-8 h-8 text-zinc-600 group-hover:text-cyan-500 mb-2 transition-colors"></i>
                                <span class="text-sm text-zinc-400 font-mono" id="sonic-file-name">Drop .WAV File</span>
                            </div>
                        </div>

                        <div id="sonic-result" class="hidden w-full bg-black border border-cyan-900/50 rounded-lg p-4 font-mono text-xs break-all relative min-h-[80px]">
                            <div class="text-[10px] text-zinc-600 uppercase mb-1">Decoded Signal:</div>
                            <div id="sonic-result-text" class="text-cyan-400"></div>
                        </div>

                        <button onclick="decodeSonic()" id="btn-sonic-decode" class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-3 rounded-lg transition-all flex items-center justify-center gap-2 mt-auto">
                            <i data-lucide="search" class="w-4 h-4"></i> Analyze Spectrum
                        </button>
                    </div>

                </div>
            </div>

        </div>
    </main>

    <!-- FOOTER -->
    <footer class="bg-black border-t border-zinc-900 py-12 mt-auto">
        <div class="container mx-auto px-4 text-center">
            <p class="text-zinc-400 font-medium">Designed & Developed by <span class="text-rose-500 font-bold">MKD</span></p>
            <p class="text-xs text-zinc-600 flex items-center justify-center gap-1 mt-1">
                Made with <i data-lucide="heart" class="w-3 h-3 text-red-600 fill-current"></i> by Indian Developer
            </p>
            <p class="text-[10px] text-zinc-700 mt-2">Â© 2025 Link Postmortem. Secure Build.</p>
        </div>
    </footer>

    <script>
        // Immediate function definitions for modals
        (function() {
            function closeMemoryWarningNow() {
                try {
                    const mw = document.getElementById('memory-warning-modal');
                    if (mw) {
                        mw.style.display = 'none';
                        mw.classList.add('hidden');
                        console.log('Memory warning dismissed');
                        return true;
                    }
                } catch(e) {
                    console.error('Error:', e);
                }
                return false;
            }
            
            // Make available immediately
            window.closeMemoryWarning = closeMemoryWarningNow;
            
            // Also set up buttons immediately if they exist
            function setupButtons() {
                const memoryBtn = document.getElementById('memory-warning-btn');
                if (memoryBtn) {
                    memoryBtn.onclick = function() { closeMemoryWarningNow(); return false; };
                }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setupButtons);
            } else {
                setupButtons();
            }
        })();
    </script>

    <!-- FLOATING GHOST COMMS BUTTON -->
    <button onclick="openGhostComms()" id="ghost-float-btn" 
        class="fixed bottom-6 right-6 w-16 h-16 bg-emerald-600 hover:bg-emerald-700 text-white rounded-full shadow-2xl shadow-emerald-900/50 hover:shadow-emerald-900/70 transition-all flex items-center justify-center z-50 group">
        <i data-lucide="message-square-lock" class="w-7 h-7 group-hover:scale-110 transition-transform"></i>
        <span class="absolute -top-1 -right-1 w-4 h-4 bg-rose-500 rounded-full border-2 border-black animate-pulse hidden" id="ghost-notification-dot"></span>
    </button>

    <!-- GHOST COMMS MODAL -->
    <div id="ghost-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm">
        <div class="bg-zinc-900 border border-zinc-800 rounded-2xl shadow-2xl w-full max-w-6xl max-h-[90vh] flex flex-col overflow-hidden">
            <!-- Modal Header -->
            <div class="bg-zinc-950 border-b border-zinc-800 px-6 py-4 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-emerald-600/20 rounded-full flex items-center justify-center border border-emerald-600/30">
                        <i data-lucide="message-square-lock" class="w-5 h-5 text-emerald-400"></i>
                    </div>
                    <div>
                        <h2 class="font-bold text-white">Ghost Comms</h2>
                        <p class="text-xs text-zinc-500">Zero-Knowledge Encrypted Chat</p>
                    </div>
                </div>
                <button onclick="closeGhostComms()" class="text-zinc-500 hover:text-white transition-colors">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>

            <!-- Modal Content -->
            <div class="flex-1 overflow-hidden flex flex-col md:flex-row">
                <!-- LEFT SIDE: Join/Create Room (Hidden when in room) -->
                <div id="ghost-join-panel" class="w-full md:w-96 bg-zinc-950 border-r border-zinc-800 p-4 md:p-6 overflow-y-auto">
                    <div class="space-y-6">
                        <!-- Create Room Section -->
                        <div>
                            <div class="flex items-center gap-2 text-emerald-400 mb-4">
                                <i data-lucide="plus-circle" class="w-5 h-5"></i>
                                <h3 class="font-bold uppercase tracking-wider text-sm">Create Room</h3>
                            </div>
                            
                            <div class="space-y-4">
                                <div>
                                    <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Master Key</label>
                                    <input type="password" id="ghost-master-key" placeholder="Enter master key to create room" 
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none font-mono">
                                    <p class="text-[10px] text-zinc-600 mt-1">Key required to create new rooms</p>
                                </div>
                                
                                <div>
                                    <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Room ID</label>
                                    <input type="text" id="ghost-room-id-create" placeholder="e.g., RedHawk" 
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none font-mono">
                                </div>
                                
                                <div>
                                    <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Room Password</label>
                                    <input type="password" id="ghost-password-create" placeholder="Room access password" 
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none">
                                </div>
                                
                                <div>
                                    <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Your Handle</label>
                                    <input type="text" id="ghost-handle-create" placeholder="Your Name" 
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none">
                                </div>
                                
                                <!-- Room Settings -->
                                <div class="bg-zinc-950/50 border border-zinc-800 rounded-lg p-4 space-y-3">
                                    <label class="text-xs font-bold text-zinc-400 uppercase tracking-wider block">Room Features</label>
                                    
                                    <label class="flex items-center gap-3 cursor-pointer group">
                                        <input type="checkbox" id="ghost-enable-download" class="w-4 h-4 rounded border-zinc-700 bg-zinc-900 text-emerald-600 focus:ring-emerald-600 focus:ring-offset-0 focus:ring-2">
                                        <div class="flex-1">
                                            <div class="text-sm text-zinc-300 group-hover:text-white transition-colors">Download Chat History</div>
                                            <div class="text-[10px] text-zinc-600">Allow participants to download chat history</div>
                                        </div>
                                    </label>
                                    
                                    <label class="flex items-center gap-3 cursor-pointer group">
                                        <input type="checkbox" id="ghost-enable-delete" class="w-4 h-4 rounded border-zinc-700 bg-zinc-900 text-emerald-600 focus:ring-emerald-600 focus:ring-offset-0 focus:ring-2">
                                        <div class="flex-1">
                                            <div class="text-sm text-zinc-300 group-hover:text-white transition-colors">Delete Messages</div>
                                            <div class="text-[10px] text-zinc-600">Allow participants to delete their messages (for everyone)</div>
                                        </div>
                                    </label>
                                    
                                    <label class="flex items-center gap-3 cursor-pointer group">
                                        <input type="checkbox" id="ghost-enable-gifs" class="w-4 h-4 rounded border-zinc-700 bg-zinc-900 text-emerald-600 focus:ring-emerald-600 focus:ring-offset-0 focus:ring-2">
                                        <div class="flex-1">
                                            <div class="text-sm text-zinc-300 group-hover:text-white transition-colors">Send GIFs</div>
                                            <div class="text-[10px] text-zinc-600">Allow participants to send GIF images</div>
                                        </div>
                                    </label>
                                </div>
                                
                                <button onclick="createGhostRoom()" id="ghost-create-btn" 
                                    class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 rounded-lg transition-all flex items-center justify-center gap-2 shadow-lg shadow-emerald-900/20">
                                    <i data-lucide="shield-check" class="w-4 h-4"></i> Create & Join Room
                                </button>
                            </div>
                        </div>

                        <div class="border-t border-zinc-800 pt-6">
                            <div class="flex items-center gap-2 text-zinc-400 mb-4">
                                <i data-lucide="link" class="w-5 h-5"></i>
                                <h3 class="font-bold uppercase tracking-wider text-sm">Join via Link</h3>
                            </div>
                            
                            <div class="space-y-4">
                                <div>
                                    <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Room ID</label>
                                    <input type="text" id="ghost-room-id-join" placeholder="From shared link" 
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none font-mono">
                                </div>
                                
                                <div>
                                    <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Room Password</label>
                                    <input type="password" id="ghost-password-join" placeholder="From shared link" 
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none">
                                </div>
                                
                                <div>
                                    <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Your Handle</label>
                                    <input type="text" id="ghost-handle-join" placeholder="Your Name" 
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none">
                                </div>
                                
                                <button onclick="joinViaLink()" id="ghost-join-link-btn" 
                                    class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-3 rounded-lg transition-all flex items-center justify-center gap-2">
                                    <i data-lucide="log-in" class="w-4 h-4"></i> Join Room
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- RIGHT SIDE: Chat Area -->
                <div class="flex-1 flex flex-col bg-zinc-900/50">
                    <!-- Chat Header -->
                    <div class="bg-zinc-950 border-b border-zinc-800 px-6 py-4 flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <div class="w-10 h-10 bg-emerald-600/20 rounded-full flex items-center justify-center border border-emerald-600/30">
                                <i data-lucide="shield-check" class="w-5 h-5 text-emerald-400"></i>
                            </div>
                            <div>
                                <h3 class="font-bold text-white text-sm" id="ghost-room-display">Not Connected</h3>
                                <p class="text-[10px] text-zinc-500" id="ghost-room-status">Join or create a room to start</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-3">
                            <button onclick="initiateCall()" id="ghost-call-btn" class="hidden text-xs bg-cyan-600 hover:bg-cyan-700 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-all">
                                <i data-lucide="phone" class="w-4 h-4"></i> Call
                            </button>
                            <button onclick="copyRoomLink()" id="ghost-share-btn" class="hidden text-xs bg-zinc-800 hover:bg-zinc-700 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-all">
                                <i data-lucide="share-2" class="w-4 h-4"></i> Share Link
                            </button>
                            <button onclick="disconnectGhostWithCleanup()" id="ghost-disconnect-btn" class="hidden text-xs text-rose-500 hover:text-rose-400 transition-colors">
                                <i data-lucide="log-out" class="w-4 h-4"></i> Leave
                            </button>
                            <div id="ghost-encryption-indicator" class="w-2 h-2 rounded-full bg-zinc-700"></div>
                            <span class="text-[10px] text-zinc-500 font-mono">E2E</span>
                        </div>
                    </div>
                    
                    <!-- Messages Container -->
                    <div id="ghost-messages" class="flex-1 min-h-[400px] overflow-y-auto bg-gradient-to-b from-zinc-950 via-zinc-900 to-zinc-950 p-4 space-y-3" style="overflow-y: auto; overflow-x: hidden; scroll-behavior: smooth;">
                        <div class="text-center text-zinc-600 text-sm py-12">
                            <div class="w-16 h-16 bg-emerald-600/10 rounded-full flex items-center justify-center mx-auto mb-3 border border-emerald-600/20">
                                <i data-lucide="message-square-lock" class="w-8 h-8 text-emerald-500/50"></i>
                            </div>
                            <p class="font-medium">Join or create a room to start messaging</p>
                            <p class="text-xs text-zinc-700 mt-1">Messages are end-to-end encrypted</p>
                        </div>
                    </div>
                    
                    <!-- Input Area -->
                    <div class="bg-zinc-950 border-t border-zinc-800 p-4">
                        <div class="flex items-end gap-2">
                            <!-- Emoji Picker Button -->
                            <button onclick="toggleEmojiPicker()" id="ghost-emoji-btn" 
                                class="w-10 h-10 bg-zinc-800 hover:bg-zinc-700 disabled:bg-zinc-900 disabled:text-zinc-700 text-zinc-400 rounded-full transition-all flex items-center justify-center disabled:cursor-not-allowed"
                                disabled>
                                <i data-lucide="smile" class="w-5 h-5"></i>
                            </button>
                            
                            <!-- GIF Picker Button (if enabled) -->
                            <button onclick="toggleGifPicker()" id="ghost-gif-btn" 
                                class="hidden w-10 h-10 bg-zinc-800 hover:bg-zinc-700 disabled:bg-zinc-900 disabled:text-zinc-700 text-zinc-400 rounded-full transition-all flex items-center justify-center disabled:cursor-not-allowed"
                                disabled>
                                <i data-lucide="image" class="w-5 h-5"></i>
                            </button>
                            
                            <!-- Audio Record Button -->
                            <button onclick="toggleAudioRecord()" id="ghost-audio-btn" 
                                class="w-10 h-10 bg-zinc-800 hover:bg-zinc-700 disabled:bg-zinc-900 disabled:text-zinc-700 text-zinc-400 rounded-full transition-all flex items-center justify-center disabled:cursor-not-allowed"
                                disabled>
                                <i data-lucide="mic" class="w-5 h-5"></i>
                            </button>
                            
                            <!-- Hidden file input for GIF upload -->
                            <input type="file" id="ghost-gif-upload" accept="image/gif,video/*" style="display: none;" onchange="handleGifUpload(event)">
                            
                            <div class="flex-1 relative">
                                <textarea id="ghost-message-input" placeholder="Type a message..." 
                                    class="w-full bg-zinc-900 border border-zinc-800 rounded-2xl px-4 py-3 pl-12 pr-12 text-sm text-white focus:border-emerald-600 focus:ring-1 focus:ring-emerald-600 outline-none resize-none min-h-[48px] max-h-[400px] placeholder:text-zinc-600"
                                    disabled rows="1"></textarea>
                                
                                <!-- Emoji Picker Popup -->
                                <div id="ghost-emoji-picker" class="hidden absolute bottom-full left-0 mb-2 bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl p-4 w-80 max-h-64 overflow-y-auto z-50">
                                    <div class="grid grid-cols-8 gap-2" id="ghost-emoji-grid"></div>
                                </div>
                                
                                <!-- GIF Picker Popup -->
                                <div id="ghost-gif-picker" class="hidden absolute bottom-full left-0 mb-2 bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-[400px] max-h-[500px] flex flex-col z-50">
                                    <!-- Search Bar -->
                                    <div class="p-3 border-b border-zinc-800">
                                        <div class="relative">
                                            <input type="text" id="ghost-gif-search" placeholder="Search GIFs..." 
                                                class="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 pl-10 text-sm text-white placeholder:text-zinc-600 outline-none focus:border-emerald-600">
                                            <i data-lucide="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-zinc-500"></i>
                                        </div>
                                    </div>
                                    
                                    <!-- Categories/Tabs -->
                                    <div class="flex gap-2 px-3 py-2 border-b border-zinc-800 overflow-x-auto">
                                        <button onclick="loadGifCategory('trending')" id="gif-tab-trending" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-emerald-600 text-white whitespace-nowrap">Trending</button>
                                        <button onclick="loadGifCategory('reactions')" id="gif-tab-reactions" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 whitespace-nowrap">Reactions</button>
                                        <button onclick="loadGifCategory('funny')" id="gif-tab-funny" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 whitespace-nowrap">Funny</button>
                                        <button onclick="loadGifCategory('love')" id="gif-tab-love" class="px-3 py-1.5 text-xs font-medium rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 whitespace-nowrap">Love</button>
                                    </div>
                                    
                                    <!-- GIF Grid -->
                                    <div id="ghost-gif-results" class="flex-1 overflow-y-auto p-3">
                                        <div class="grid grid-cols-2 gap-2" id="ghost-gif-grid"></div>
                                        <div id="ghost-gif-loading" class="hidden text-center py-8">
                                            <i data-lucide="loader-2" class="w-6 h-6 animate-spin text-emerald-500 mx-auto"></i>
                                            <p class="text-xs text-zinc-500 mt-2">Loading GIFs...</p>
                                        </div>
                                    </div>
                                </div>
                                
                                <button onclick="sendGhostMessage()" id="ghost-send-btn" 
                                    class="absolute right-2 bottom-2 w-8 h-8 bg-emerald-600 hover:bg-emerald-700 disabled:bg-zinc-800 disabled:text-zinc-600 text-white rounded-full transition-all flex items-center justify-center shadow-lg hover:shadow-emerald-600/50 disabled:shadow-none"
                                    disabled>
                                    <i data-lucide="send" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mt-2 flex items-center justify-between">
                            <div class="flex items-center gap-3">
                            <p class="text-[10px] text-zinc-700 font-mono">ð Encrypted with AES-GCM</p>
                                <button onclick="downloadChatHistory()" id="ghost-download-btn" class="hidden text-[10px] text-emerald-500 hover:text-emerald-400 transition-colors flex items-center gap-1">
                                    <i data-lucide="download" class="w-3 h-3"></i> Download History
                                </button>
                                <button onclick="toggleChaosMode()" id="ghost-chaos-btn" class="hidden text-[10px] text-rose-500 hover:text-rose-400 transition-colors flex items-center gap-1">
                                    <i data-lucide="zap" class="w-3 h-3"></i> Gravity
                                </button>
                                <button onclick="toggleSonicPulse()" id="ghost-sonic-btn" class="hidden text-[10px] text-cyan-500 hover:text-cyan-400 transition-colors flex items-center gap-1">
                                    <i data-lucide="radio" class="w-3 h-3"></i> Visualize
                                </button>
                            </div>
                            <p class="text-[10px] text-zinc-700" id="ghost-char-count">0</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- SECURITY BREACH MODAL -->
    <div id="security-breach-modal" class="hidden fixed inset-0 z-[10000] flex items-center justify-center p-4 bg-black/95 backdrop-blur-sm">
        <div class="breach-warning rounded-2xl p-8 max-w-md text-center shadow-2xl">
            <div class="mb-6">
                <div class="w-20 h-20 bg-red-600 rounded-full flex items-center justify-center mx-auto mb-4 animate-pulse">
                    <i data-lucide="shield-alert" class="w-10 h-10 text-white"></i>
                </div>
                <h2 class="text-3xl font-black text-white mb-2 tracking-wider">UNAUTHORIZED ACCESS</h2>
                <h3 class="text-xl font-bold text-red-200 mb-4">SYSTEM COMPROMISED</h3>
                <p class="text-red-100 text-sm">Intrusion detected. Security protocols activated.</p>
            </div>
            <button onclick="closeBreachModal()" class="bg-white text-red-600 font-bold px-8 py-3 rounded-lg hover:bg-red-50 transition-colors">
                ACKNOWLEDGE
            </button>
        </div>
    </div>

    <!-- INCOMING CALL MODAL (The Uplink) -->
    <div id="incoming-call-modal" class="hidden fixed inset-0 z-[10001] flex items-center justify-center p-4 bg-black/95 backdrop-blur-sm">
        <div class="bg-zinc-900 border-2 border-cyan-600 rounded-2xl p-8 max-w-md text-center shadow-2xl">
            <div class="mb-6">
                <div class="w-20 h-20 bg-cyan-600/20 rounded-full flex items-center justify-center mx-auto mb-4 animate-pulse">
                    <i data-lucide="phone-incoming" class="w-10 h-10 text-cyan-500"></i>
                </div>
                <h2 class="text-2xl font-black text-white mb-2 tracking-wider">INCOMING TRANSMISSION...</h2>
                <p class="text-cyan-300 text-sm" id="caller-name-display">Unknown Caller</p>
            </div>
            <div class="flex gap-4 justify-center">
                <button onclick="acceptCall()" id="accept-call-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold px-8 py-3 rounded-lg transition-colors flex items-center gap-2">
                    <i data-lucide="phone" class="w-5 h-5"></i> ACCEPT
                </button>
                <button onclick="denyCall()" id="deny-call-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold px-8 py-3 rounded-lg transition-colors flex items-center gap-2">
                    <i data-lucide="phone-off" class="w-5 h-5"></i> DENY
                </button>
            </div>
        </div>
    </div>

    <!-- ACTIVE CALL INTERFACE (The Uplink) -->
    <div id="active-call-interface" class="hidden fixed top-4 left-1/2 -translate-x-1/2 z-[10000] bg-zinc-900 border-2 border-cyan-600 rounded-xl px-6 py-4 shadow-2xl">
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-3">
                <div class="w-3 h-3 bg-emerald-500 rounded-full animate-pulse"></div>
                <span class="text-sm font-bold text-white">ACTIVE CALL</span>
                <div id="call-visualizer" class="flex items-center gap-1 h-6">
                    <div class="w-1 bg-cyan-500 rounded-full" style="height: 4px; animation: pulse 1s ease-in-out infinite;"></div>
                    <div class="w-1 bg-cyan-500 rounded-full" style="height: 8px; animation: pulse 1s ease-in-out infinite 0.2s;"></div>
                    <div class="w-1 bg-cyan-500 rounded-full" style="height: 12px; animation: pulse 1s ease-in-out infinite 0.4s;"></div>
                    <div class="w-1 bg-cyan-500 rounded-full" style="height: 8px; animation: pulse 1s ease-in-out infinite 0.6s;"></div>
                </div>
            </div>
            <button onclick="hangupCall()" id="hangup-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold px-4 py-2 rounded-lg transition-colors flex items-center gap-2">
                <i data-lucide="phone-off" class="w-4 h-4"></i> HANG UP
            </button>
        </div>
    </div>

    <!-- MEMORY WARNING MODAL -->
    <div id="memory-warning-modal" class="hidden fixed inset-0 z-[10000] flex items-center justify-center p-4 bg-black/90 backdrop-blur-sm" style="pointer-events: auto;">
        <div class="bg-zinc-900 border-2 border-amber-600 rounded-2xl p-8 max-w-md text-center shadow-2xl" style="pointer-events: auto;">
            <div class="mb-6">
                <div class="w-16 h-16 bg-amber-600/20 rounded-full flex items-center justify-center mx-auto mb-4">
                    <i data-lucide="eye" class="w-8 h-8 text-amber-500"></i>
                </div>
                <h2 class="text-2xl font-black text-white mb-2">I REMEMBER YOU</h2>
                <p class="text-zinc-300 mb-2">You tried to break me last time.</p>
                <p class="text-amber-400 font-bold" id="memory-warning-text">Don't try it again.</p>
            </div>
            <button type="button" id="memory-warning-btn" onclick="if(typeof closeMemoryWarning === 'function') { closeMemoryWarning(); } else { const mw = document.getElementById('memory-warning-modal'); if(mw) { mw.style.display = 'none'; mw.classList.add('hidden'); } } return false;" class="bg-amber-600 text-white font-bold px-8 py-3 rounded-lg hover:bg-amber-700 transition-colors cursor-pointer" style="pointer-events: auto; z-index: 10001;">
                PROCEED WITH CAUTION
            </button>
        </div>
    </div>

    <!-- LOGIC -->
    <script>
        // ============================================
        // HACKER TRAP - DEFENSE & MEMORY SYSTEM
        // ============================================
        let breachDetected = false;
        let breachAudio = null;

        // Initialize breach audio
        function initBreachAudio() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.warn('Audio not available');
            }
        }


        // ============================================
        // SELF-DEFENDING WEBSITE SYSTEM
        // ============================================
        // CONFIGURATION
        const SECURITY_KEY = "endeavour_security_log"; // The name in browser memory

        // Caution Board removed - no longer needed

        // Memory Warning Modal Functions
        function closeMemoryWarning() {
            try {
                const modal = document.getElementById('memory-warning-modal');
                if (modal) {
                    modal.classList.add('hidden');
                    modal.style.display = 'none';
                    console.log('Memory warning dismissed');
                    return true;
                }
            } catch (e) {
                console.error('Error closing memory warning:', e);
            }
            return false;
        }

        // Make closeMemoryWarning globally available
        window.closeMemoryWarning = closeMemoryWarning;

        // 1. THE MEMORY CHECK (Runs immediately on load)
        window.addEventListener('DOMContentLoaded', function() {
            checkMemory();
            
            // Set up memory warning button click handler
            const memoryWarningBtn = document.getElementById('memory-warning-btn');
            if (memoryWarningBtn) {
                memoryWarningBtn.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    if (typeof closeMemoryWarning === 'function') {
                        closeMemoryWarning();
                    } else {
                        // Fallback if function not available
                        const mw = document.getElementById('memory-warning-modal');
                        if (mw) {
                            mw.style.display = 'none';
                            mw.classList.add('hidden');
                        }
                    }
                return false;
                };
                
                // Also add event listener as backup
                memoryWarningBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof closeMemoryWarning === 'function') {
                        closeMemoryWarning();
                    } else {
                        const mw = document.getElementById('memory-warning-modal');
                        if (mw) {
                            mw.style.display = 'none';
                            mw.classList.add('hidden');
                        }
                    }
                }, true);
            }
            
            // Caution board removed - no longer showing
        });

        // 2. ENHANCED TRAP WITH REASON TRACKING & FIRESTORE LOGGING
        async function triggerSecurityBreach(reason) {
            // Prevent multiple rapid triggers (debounce)
            const now = Date.now();
            const lastTrigger = parseInt(localStorage.getItem('last_breach_trigger') || '0');
            if (now - lastTrigger < 2000) return;
            
            localStorage.setItem('last_breach_trigger', now.toString());
            
            if (breachDetected) {
                document.body.classList.add('system-breach');
                setTimeout(() => {
                    document.body.classList.remove('system-breach');
                }, 3000);
                return;
            }
            
            breachDetected = true;
            
            // Store breach in memory with reason
            localStorage.setItem(SECURITY_KEY, "breached");
            localStorage.setItem('security_breach', 'level_1');
            localStorage.setItem('breach_timestamp', Date.now().toString());
            localStorage.setItem('breach_count', (parseInt(localStorage.getItem('breach_count') || '0') + 1).toString());
            localStorage.setItem('breach_reason', reason);
            
            // Log to Firestore (The Sentinel - Evidence Collection)
            try {
                if (window.firebaseDB && window.firebaseAddDoc && window.firebaseCollection && window.firebaseServerTimestamp) {
                    await window.firebaseAddDoc(
                        window.firebaseCollection(window.firebaseDB, 'security_logs'),
                        {
                            ip: 'anonymous', // Could be enhanced with actual IP detection
                            timestamp: window.firebaseServerTimestamp(),
                            violationType: reason,
                            userAgent: navigator.userAgent,
                            url: window.location.href,
                            breachCount: parseInt(localStorage.getItem('breach_count') || '0')
                        }
                    );
                }
            } catch (error) {
                console.warn('Firestore logging failed:', error);
            }
            
            // A. Visual Chaos
            document.body.classList.add('system-breach');
            
            // B. Create/Show the Overlay Warning
            let overlay = document.getElementById('glitch-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'glitch-overlay';
                overlay.className = 'glitch-overlay';
                document.body.appendChild(overlay);
            }
            overlay.style.display = 'block';
            overlay.innerHTML = `
                <h1 style="color: red; font-size: 3rem; margin-bottom: 20px;">â  INTRUSION DETECTED â </h1>
                <p style="color: #ff4444; font-size: 1.5rem; margin: 10px 0;">UNAUTHORIZED ACCESS DETECTED</p>
                <p style="color: #ff6666; font-size: 1.2rem; margin: 10px 0;">${reason}</p>
                <p style="color: #ff8888; font-size: 1rem; margin: 20px 0;">YOUR IP HAS BEEN LOGGED.</p>
                <p style="color: #ffaaaa; font-size: 1rem;">DO NOT RESIST.</p>
                <button onclick="closeGlitchOverlay()" style="margin-top: 30px; padding: 15px 30px; background: red; color: white; border: none; font-size: 1rem; cursor: pointer; border-radius: 5px;">ACKNOWLEDGE</button>
            `;
            
            // C. Play Sound
            initBreachAudio();
            
            // D. Console scare
            console.clear();
            console.log("%c STOP! ", "color: red; font-size: 50px; font-weight: bold;");
            console.log("%c System has recorded your intrusion attempt.", "color: red; font-size: 16px;");
            console.log("%c Reason: " + reason, "color: orange; font-size: 14px;");
            
            // Remove glitch after 5 seconds
            setTimeout(() => {
                document.body.classList.remove('system-breach');
                breachDetected = false;
            }, 5000);
        }

        function closeGlitchOverlay() {
            const overlay = document.getElementById('glitch-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            document.body.classList.remove('system-breach');
        }

        // Update checkMemory to use new security key
        function checkMemory() {
            const breach = localStorage.getItem(SECURITY_KEY) || localStorage.getItem('security_breach');
            const breachCount = parseInt(localStorage.getItem('breach_count') || '0');
            
            if (breach === 'level_1' || breach === 'breached') {
                // Show memory warning with breach count
                setTimeout(() => {
                    const modal = document.getElementById('memory-warning-modal');
                    if (modal) {
                        const warningText = document.getElementById('memory-warning-text');
                        if (warningText && breachCount > 1) {
                            warningText.innerHTML = `You tried to break me ${breachCount} time${breachCount > 1 ? 's' : ''} before.<br><span class="text-amber-400 font-bold">DO NOT ATTEMPT TO BREACH ME AGAIN.</span>`;
                        } else if (warningText) {
                            warningText.innerHTML = 'DO NOT ATTEMPT TO BREACH ME AGAIN.';
                        }
                        modal.classList.remove('hidden');
                    }
                }, 1500);
            }
        }

        // Right-click counter for breach detection
        let rightClickCount = 0;
        let rightClickResetTimeout = null;
        const RIGHT_CLICK_THRESHOLD = 10;

        // Update trigger functions to use new system
        document.addEventListener('contextmenu', function(e) {
            // Check if clicking on memory warning modal - allow dismiss
            const memoryModal = document.getElementById('memory-warning-modal');
            if (memoryModal && !memoryModal.classList.contains('hidden') && window.getComputedStyle(memoryModal).display !== 'none') {
                // Right-click on memory modal dismisses it
                if (typeof closeMemoryWarning === 'function') {
                    closeMemoryWarning();
                }
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            
            // Increment right-click counter
            rightClickCount++;
            
            // Reset counter after 3 seconds of no right-clicks
            if (rightClickResetTimeout) {
                clearTimeout(rightClickResetTimeout);
            }
            rightClickResetTimeout = setTimeout(() => {
                rightClickCount = 0;
            }, 3000);
            
            // Only trigger breach after 10 consecutive right-clicks
            if (rightClickCount >= RIGHT_CLICK_THRESHOLD) {
                triggerSecurityBreach("Right Click Attempt (10+ times)");
                rightClickCount = 0; // Reset after triggering
            }
            
            // Always prevent right-click menu (but don't trigger breach until threshold)
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
        }, true);

        document.addEventListener('keydown', function(e) {
            let shouldTrigger = false;
            let reason = '';
            
            if(e.keyCode == 123 || e.key === 'F12') {
                shouldTrigger = true;
                reason = "F12 Inspector Tool";
            }
            else if(e.ctrlKey && e.shiftKey && (e.keyCode == 'I'.charCodeAt(0) || e.key === 'I' || e.key === 'i')) {
                shouldTrigger = true;
                reason = "DevTools Shortcut (Ctrl+Shift+I)";
            }
            else if(e.ctrlKey && e.shiftKey && (e.keyCode == 'C'.charCodeAt(0) || e.key === 'C' || e.key === 'c')) {
                shouldTrigger = true;
                reason = "Inspect Element Shortcut (Ctrl+Shift+C)";
            }
            else if(e.ctrlKey && e.shiftKey && (e.keyCode == 'J'.charCodeAt(0) || e.key === 'J' || e.key === 'j')) {
                shouldTrigger = true;
                reason = "Console Shortcut (Ctrl+Shift+J)";
            }
            else if(e.ctrlKey && (e.keyCode == 'U'.charCodeAt(0) || e.key === 'U' || e.key === 'u')) {
                shouldTrigger = true;
                reason = "Source Code Theft Attempt (Ctrl+U)";
            }
            else if(e.ctrlKey && e.shiftKey && (e.keyCode == 'K'.charCodeAt(0) || e.key === 'K' || e.key === 'k')) {
                shouldTrigger = true;
                reason = "Firefox Console Shortcut";
            }
            else if(e.ctrlKey && e.shiftKey && (e.keyCode == 'E'.charCodeAt(0) || e.key === 'E' || e.key === 'e')) {
                shouldTrigger = true;
                reason = "Chrome Network Panel";
            }
            
            if (shouldTrigger) {
                triggerSecurityBreach(reason);
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }
        }, true);

        // Backup prevention
        document.onkeydown = function(e) {
            if(e.keyCode == 123 || 
               (e.ctrlKey && e.shiftKey && (e.keyCode == 'I'.charCodeAt(0) || e.keyCode == 'C'.charCodeAt(0) || e.keyCode == 'J'.charCodeAt(0) || e.keyCode == 'K'.charCodeAt(0) || e.keyCode == 'E'.charCodeAt(0))) ||
               (e.ctrlKey && e.keyCode == 'U'.charCodeAt(0))) {
                triggerSecurityBreach("Keyboard Shortcut Detected");
                return false;
            }
        };

        // Detect DevTools by window size change
        let lastWidth = window.innerWidth;
        let lastHeight = window.innerHeight;
        let devToolsOpen = false;
        
        setInterval(() => {
            const currentWidth = window.innerWidth;
            const currentHeight = window.innerHeight;
            
            if (Math.abs(currentWidth - lastWidth) > 150 || Math.abs(currentHeight - lastHeight) > 150) {
                if (!devToolsOpen) {
                    devToolsOpen = true;
                    triggerSecurityBreach("DevTools Window Detected");
                }
            } else {
                devToolsOpen = false;
            }
            
            lastWidth = currentWidth;
            lastHeight = currentHeight;
        }, 300);

        // Detect DevTools by console detection
        let devtools = {open: false};
        const element = new Image();
        Object.defineProperty(element, 'id', {
            get: function() {
                if (!devtools.open) {
                    devtools.open = true;
                    triggerSecurityBreach("Console Access Detected");
                }
            }
        });
        
        setInterval(() => {
            devtools.open = false;
            console.log(element);
            console.clear();
        }, 1000);

        // Detect if DevTools is already open on page load
        function checkDevToolsOnLoad() {
            const widthThreshold = window.outerWidth - window.innerWidth > 160;
            const heightThreshold = window.outerHeight - window.innerHeight > 160;
            
            if (widthThreshold || heightThreshold) {
                triggerSecurityBreach("DevTools Already Open");
            }
        }
        
        setTimeout(checkDevToolsOnLoad, 1000);

        // ============================================
        // CHAOS MODE - PHYSICS ENGINE
        // ============================================
        let chaosModeActive = false;
        let engine = null;
        let world = null;
        let bodies = [];

        function toggleChaosMode() {
            if (chaosModeActive) {
                disableChaosMode();
                        } else {
                enableChaosMode();
            }
        }

        function enableChaosMode() {
            if (typeof Matter === 'undefined') {
                alert('Physics engine not loaded. Please refresh the page.');
                return;
            }

            chaosModeActive = true;
            const btn = document.getElementById('ghost-chaos-btn');
            if (btn) {
                btn.innerHTML = '<i data-lucide="zap-off" class="w-3 h-3"></i> Stop';
                btn.classList.remove('text-rose-500');
                btn.classList.add('text-red-600');
                lucide.createIcons();
            }

            const messagesDiv = document.getElementById('ghost-messages');
            if (!messagesDiv) return;

            // Ensure messages container has proper positioning
            messagesDiv.style.position = 'relative';
            messagesDiv.style.overflow = 'hidden';

            // Create Matter.js engine with gentle gravity
            engine = Matter.Engine.create();
            world = engine.world;
            engine.world.gravity.y = 0.3; // Gentle gravity
            engine.world.gravity.scale = 0.001;

            // Get all message bubbles
            const messageBubbles = messagesDiv.querySelectorAll('.message-bubble');
            
            bodies = [];
            const messagesRect = messagesDiv.getBoundingClientRect();
            
            messageBubbles.forEach((bubble) => {
                const rect = bubble.getBoundingClientRect();
                const relativeX = rect.left - messagesRect.left + rect.width / 2;
                const relativeY = rect.top - messagesRect.top + rect.height / 2;
                
                // Create physics body with gentle properties
                const body = Matter.Bodies.rectangle(
                    relativeX,
                    relativeY,
                    Math.min(rect.width, messagesDiv.offsetWidth - 20), // Constrain width
                    rect.height,
                    {
                        restitution: 0.2, // Less bouncy
                        friction: 0.8, // More friction
                        frictionAir: 0.05, // Air resistance
                        density: 0.0005, // Lighter
                        chamfer: { radius: 8 } // Rounded corners
                    }
                );
                
                Matter.World.add(world, body);
                
                // Store original position and style
                const originalLeft = rect.left - messagesRect.left;
                const originalTop = rect.top - messagesRect.top;
                
                bodies.push({ 
                    body, 
                    element: bubble, 
                    originalStyle: bubble.style.cssText,
                    originalLeft,
                    originalTop,
                    maxWidth: Math.min(rect.width, messagesDiv.offsetWidth - 20)
                });
                
                // Make element position absolute within container
                bubble.style.position = 'absolute';
                bubble.style.left = originalLeft + 'px';
                bubble.style.top = originalTop + 'px';
                bubble.style.width = Math.min(rect.width, messagesDiv.offsetWidth - 20) + 'px';
                bubble.style.margin = '0';
                bubble.style.transition = 'none';
            });

            // Add invisible boundaries within the messages container
            const padding = 5;
            const floor = Matter.Bodies.rectangle(
                messagesDiv.offsetWidth / 2,
                messagesDiv.offsetHeight - padding,
                messagesDiv.offsetWidth,
                10,
                { isStatic: true, label: 'floor' }
            );
            
            const leftWall = Matter.Bodies.rectangle(
                padding,
                messagesDiv.offsetHeight / 2,
                10,
                messagesDiv.offsetHeight,
                { isStatic: true, label: 'leftWall' }
            );
            
            const rightWall = Matter.Bodies.rectangle(
                messagesDiv.offsetWidth - padding,
                messagesDiv.offsetHeight / 2,
                10,
                messagesDiv.offsetHeight,
                { isStatic: true, label: 'rightWall' }
            );
            
            const ceiling = Matter.Bodies.rectangle(
                messagesDiv.offsetWidth / 2,
                padding,
                messagesDiv.offsetWidth,
                10,
                { isStatic: true, label: 'ceiling' }
            );
            
            Matter.World.add(world, [floor, leftWall, rightWall, ceiling]);

            // Gentle mouse constraint for dragging
            const mouse = Matter.Mouse.create(messagesDiv);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.1,
                    render: { visible: false }
                }
            });
            Matter.World.add(world, mouseConstraint);

            // Run engine with slower updates for smoother motion
            const runner = Matter.Runner.create();
            runner.delta = 1000 / 60; // 60 FPS
            Matter.Runner.run(runner, engine);

            // Sync physics to HTML with boundary constraints
            function syncPhysics() {
                if (!chaosModeActive) return;
                
                const currentRect = messagesDiv.getBoundingClientRect();
                const maxX = messagesDiv.offsetWidth;
                const maxY = messagesDiv.offsetHeight;
                
                bodies.forEach(({ body, element, maxWidth }) => {
                    // Constrain position within boundaries
                    let x = body.position.x - body.bounds.min.x;
                    let y = body.position.y - body.bounds.min.y;
                    
                    // Keep within container bounds
                    x = Math.max(5, Math.min(x, maxX - body.bounds.max.x + body.bounds.min.x - 5));
                    y = Math.max(5, Math.min(y, maxY - body.bounds.max.y + body.bounds.min.y - 5));
                    
                    element.style.left = x + 'px';
                    element.style.top = y + 'px';
                    element.style.width = Math.min(maxWidth, maxX - x - 10) + 'px';
                    
                    // Gentle rotation
                    const rotation = body.angle * (180 / Math.PI);
                    element.style.transform = `rotate(${rotation * 0.3}deg)`; // Reduced rotation
                });
                
                requestAnimationFrame(syncPhysics);
            }
            syncPhysics();
        }

        function disableChaosMode() {
            chaosModeActive = false;
            
            const btn = document.getElementById('ghost-chaos-btn');
            if (btn) {
                btn.innerHTML = '<i data-lucide="zap" class="w-3 h-3"></i> Gravity';
                btn.classList.add('text-rose-500');
                btn.classList.remove('text-red-600');
            lucide.createIcons();
        }

            // Restore original positions
            bodies.forEach(({ element, originalStyle }) => {
                element.style.cssText = originalStyle;
            });

            // Clean up
            if (engine) {
                Matter.Engine.clear(engine);
                engine = null;
            }
            bodies = [];
        }

        // ============================================
        // SONIC PULSE - AUDIO VISUALIZATION
        // ============================================
        let sonicPulseActive = false;
        let sonicAudioContext = null;
        let sonicAnalyser = null;
        let sonicMicrophone = null;
        let sonicAnimationFrame = null;

        function toggleSonicPulse() {
            if (sonicPulseActive) {
                disableSonicPulse();
            } else {
                enableSonicPulse();
            }
        }

        async function enableSonicPulse() {
            try {
                sonicPulseActive = true;
                const btn = document.getElementById('ghost-sonic-btn');
                if (btn) {
                    btn.innerHTML = '<i data-lucide="radio-off" class="w-3 h-3"></i> Stop';
                    btn.classList.remove('text-cyan-500');
                    btn.classList.add('text-red-600');
                lucide.createIcons();
                }

                // Prevent chat container from shifting
                const messagesDiv = document.getElementById('ghost-messages');
                if (messagesDiv) {
                    messagesDiv.style.position = 'relative';
                    messagesDiv.style.overflow = 'hidden';
                }

                // Create audio context
                sonicAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                sonicAnalyser = sonicAudioContext.createAnalyser();
                sonicAnalyser.fftSize = 256;
                sonicAnalyser.smoothingTimeConstant = 0.9; // Increased for smoother visualization

                // Try to get microphone with echo cancellation and noise suppression
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });
                    sonicMicrophone = sonicAudioContext.createMediaStreamSource(stream);
                    sonicMicrophone.connect(sonicAnalyser);
                } catch (e) {
                    // If mic not available, use system audio simulation
                    console.log('Microphone not available, using system audio simulation');
                    simulateAudio();
                }

                visualizeAudio();
            } catch (error) {
                console.error('Error enabling sonic pulse:', error);
                alert('Could not access audio. Please allow microphone permissions.');
                disableSonicPulse();
            }
        }

        function simulateAudio() {
            // Simulate audio for demo
            setInterval(() => {
                if (!sonicPulseActive) return;
                const randomVolume = Math.random() * 255;
                updatePulseVisualization(randomVolume);
            }, 100);
        }

        function visualizeAudio() {
            if (!sonicPulseActive) return;

            const dataArray = new Uint8Array(sonicAnalyser.frequencyBinCount);
            sonicAnalyser.getByteFrequencyData(dataArray);

            // Get average volume
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            updatePulseVisualization(average);

            sonicAnimationFrame = requestAnimationFrame(visualizeAudio);
        }

        function updatePulseVisualization(volume) {
            // Gentle pulse strength (much smaller values)
            const pulseStrength = Math.min(volume * 0.3, 15); // Reduced from 50 to 15
            const glowIntensity = Math.min(volume * 0.1, 8); // Gentle glow
            
            document.documentElement.style.setProperty('--pulse-strength', `${pulseStrength}px`);
            
            // Apply gentle glow to all message bubbles without shifting layout
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.classList.add('pulse-active');
                // Gentle cyan glow that doesn't affect layout
                bubble.style.boxShadow = `0 0 ${glowIntensity}px rgba(8, 145, 178, 0.6), 0 0 ${glowIntensity * 2}px rgba(8, 145, 178, 0.3)`;
                // Very subtle scale that won't shift other elements
                bubble.style.transform = `scale(${1 + pulseStrength / 500})`; // Reduced from 200 to 500
                bubble.style.transition = 'box-shadow 0.1s ease-out, transform 0.1s ease-out';
                // Ensure transform origin is center to prevent shifting
                bubble.style.transformOrigin = 'center center';
            });
        }

        function disableSonicPulse() {
            sonicPulseActive = false;
            
            const btn = document.getElementById('ghost-sonic-btn');
            if (btn) {
                btn.innerHTML = '<i data-lucide="radio" class="w-3 h-3"></i> Visualize';
                btn.classList.add('text-cyan-500');
                btn.classList.remove('text-red-600');
                lucide.createIcons();
        }

            if (sonicAnimationFrame) {
                cancelAnimationFrame(sonicAnimationFrame);
                sonicAnimationFrame = null;
            }

            if (sonicMicrophone) {
                sonicMicrophone.disconnect();
                sonicMicrophone = null;
            }

            if (sonicAudioContext) {
                sonicAudioContext.close();
                sonicAudioContext = null;
            }

            // Reset styles
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.classList.remove('pulse-active');
                bubble.style.boxShadow = '';
                bubble.style.transform = '';
            });
        }


        // --- INIT ---
        try { lucide.createIcons(); } catch(e){}

        // --- NAVIGATION ---
        function switchTab(tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
            
            // Reset styles
            ['downloader','crypter','keys','stego','sonic'].forEach(t => {
                const btn = document.getElementById(`btn-nav-${t}`);
                if (!btn) return;
                if (t === 'sonic') {
                    btn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all text-cyan-500 hover:text-cyan-300 border border-transparent hover:border-cyan-900/50 flex items-center gap-1";
                } else if (t === 'ghost') {
                    btn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all text-emerald-500 hover:text-emerald-300 border border-transparent hover:border-emerald-900/50 flex items-center gap-1";
                } else {
                    btn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all text-zinc-500 hover:text-zinc-300";
                }
            });

            // Set active
            const activeBtn = document.getElementById(`btn-nav-${tab}`);
            if (tab === 'sonic') {
                activeBtn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all bg-cyan-950 text-cyan-300 border border-cyan-800 shadow-[0_0_15px_rgba(8,145,178,0.2)] flex items-center gap-1";
                initVisualizer(); // Start visualizer loop
            } else if (tab === 'keys') {
                activeBtn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all bg-amber-950 text-amber-500 border border-amber-900 shadow-[0_0_15px_rgba(245,158,11,0.2)]";
                stopVisualizer(); // Stop visualizer when switching away
            } else {
                activeBtn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all bg-zinc-800 text-white shadow-lg";
                stopVisualizer(); // Stop visualizer when switching away
            }
        }
        function toggleMenu() { document.getElementById('mobile-menu').classList.toggle('hidden'); }

        // --- COMMON UTILS ---
        function clearInput(id) { document.getElementById(id).value = ''; }
        async function pasteToInput(id) {
            try { document.getElementById(id).value = await navigator.clipboard.readText(); }
            catch(e) { document.getElementById(id).value = prompt("Paste text:"); }
        }
        function copyToClipboard() {
            const t = document.getElementById('result-text').innerText;
            navigator.clipboard.writeText(t).then(() => alert("Copied")).catch(()=> prompt("Copy:", t));
        }

        // --- 1. DOWNLOADER LOGIC ---
        function handleDownload(e) {
            e.preventDefault();
            const url = document.getElementById('dl-input').value.trim();
            const btn = document.getElementById('dl-btn');
            
            if(!url.includes('http')) {
                document.getElementById('dl-error').classList.remove('hidden');
                document.getElementById('dl-error-text').innerText = "Invalid URL";
                return;
            }
            
            document.getElementById('dl-error').classList.add('hidden');
            document.getElementById('media-result').classList.add('hidden');
            document.getElementById('dl-result').classList.add('hidden');

            const isMedia = /\.(mp4|m3u8|mkv|avi|mov|webm|flv)(\?|$)/i.test(url);
            
            btn.innerHTML = `<i data-lucide="loader-2" class="animate-spin w-5 h-5"></i> Processing`;
            
            setTimeout(() => {
                btn.innerHTML = `<i data-lucide="download" class="w-5 h-5"></i> Extract`;
                lucide.createIcons();

                if(isMedia) {
                    document.getElementById('media-result').classList.remove('hidden');
                    document.getElementById('media-download-btn').href = url;
                } else {
                    document.getElementById('dl-result').classList.remove('hidden');
                    const link = `https://teradownloader.com/download?l=${encodeURIComponent(url)}`;
                    document.getElementById('dl-iframe').src = link;
                    document.getElementById('dl-external-link').href = link;
                }
            }, 1000);
        }

        // --- 2. CRYPTER LOGIC (Restored Complex Version) ---
        const SALT = "POSTMORTEM_KEY_X9";
        const DELIMITER = "|||"; 
        const PASS_MARKER = "LOCKED::";
        const TIME_MARKER = "_TIME_";
        let currentMode = 'encrypt';
        let hiddenTargetUrls = []; 

        function complexEncrypt(text) {
            if (!text) return '';
            try {
                let result = btoa(text);
                let shifted = '';
                for (let i = 0; i < result.length; i++) {
                    shifted += String.fromCharCode(result.charCodeAt(i) + 5);
                }
                const salted = shifted.split('').reverse().join('') + `_SALT_${btoa(SALT)}`;
                return btoa(salted);
            } catch (e) {
                return "Error: Invalid input";
            }
        }

        function complexDecrypt(text) {
            if (!text) return null;
            try {
                let salted = atob(text);
                const saltMarker = `_SALT_${btoa(SALT)}`;
                if (!salted.includes(saltMarker)) return null;
                
                let rawShifted = salted.replace(saltMarker, '');
                let unreversed = rawShifted.split('').reverse().join('');
                let unshifted = '';
                for (let i = 0; i < unreversed.length; i++) {
                    unshifted += String.fromCharCode(unreversed.charCodeAt(i) - 5);
                }
                return atob(unshifted);
            } catch (e) {
                return null;
            }
        }

        function wrapWithPass(payload, pass) {
            let signature = btoa(pass).substring(0, 8);
            return PASS_MARKER + signature + "::" + complexEncrypt(payload); 
        }

        function unwrapPass(payload, pass) {
            if (!payload.startsWith(PASS_MARKER)) return null;
            const parts = payload.split('::');
            if (parts.length < 3) return null;
            const signature = parts[1];
            const content = parts[2];
            const attemptSignature = btoa(pass).substring(0, 8);
            if (signature !== attemptSignature) return "WRONG_PASS";
            return complexDecrypt(content);
        }

        // Check if a string is a URL/link
        function isUrl(str) {
            if (!str || typeof str !== 'string') return false;
            const trimmed = str.trim();
            
            // Check for common URL patterns
            const urlPattern = /^(https?:\/\/|www\.|[a-zA-Z0-9-]+\.[a-zA-Z]{2,})/i;
            if (!urlPattern.test(trimmed)) return false;
            
            // More specific URL validation
            try {
                // If it starts with http:// or https://, it's definitely a URL
                if (/^https?:\/\//i.test(trimmed)) return true;
                
                // If it contains a domain pattern (e.g., example.com, subdomain.example.com)
                const domainPattern = /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(\/.*)?$/i;
                if (domainPattern.test(trimmed)) return true;
                
                // Check if it looks like a URL with path/query
                if (/^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}(\/|\?|#)/.test(trimmed)) return true;
            } catch (e) {
                return false;
            }
            
            return false;
        }

        function setCryptoMode(mode) {
            currentMode = mode;
            const btnEncrypt = document.getElementById('mode-encrypt');
            const btnDecrypt = document.getElementById('mode-decrypt');
            const input = document.getElementById('crypto-input');
            const actionText = document.getElementById('action-text');
            const settingsPanel = document.getElementById('crypto-settings');
            const expiryContainer = document.getElementById('crypto-expiry-container');

            hiddenTargetUrls = [];
            document.getElementById('result-empty').classList.remove('hidden');
            document.getElementById('result-text').classList.add('hidden');
            document.getElementById('result-launch').classList.add('hidden');

            if (mode === 'encrypt') {
                btnEncrypt.className = "p-1.5 rounded-md transition-all bg-zinc-700 text-white";
                btnDecrypt.className = "p-1.5 rounded-md transition-all text-zinc-600 hover:text-zinc-400";
                input.placeholder = "Paste text or link(s) here. For multiple links, put each on a new line...";
                actionText.innerText = "Encrypt Payload";
                settingsPanel.classList.remove('hidden');
                settingsPanel.classList.add('grid');
                if(expiryContainer) expiryContainer.style.display = 'block';
                document.getElementById('crypto-pass').placeholder = "Optional PIN";
            } else {
                btnDecrypt.className = "p-1.5 rounded-md transition-all bg-zinc-700 text-white";
                btnEncrypt.className = "p-1.5 rounded-md transition-all text-zinc-600 hover:text-zinc-400";
                input.placeholder = "Paste encrypted string...";
                actionText.innerText = "Decrypt & Verify";
                settingsPanel.classList.remove('hidden');
                settingsPanel.classList.add('grid');
                if(expiryContainer) expiryContainer.style.display = 'none';
                document.getElementById('crypto-pass').placeholder = "Enter passcode if required";
            }
        }

        function handleCryptoProcess() {
            const inputVal = document.getElementById('crypto-input').value.trim();
            const passVal = document.getElementById('crypto-pass').value.trim();
            const expiryVal = parseInt(document.getElementById('crypto-expiry').value);
            const resultBox = document.getElementById('result-text');
            const emptyBox = document.getElementById('result-empty');
            
            if(!inputVal) return;
            
            emptyBox.classList.add('hidden');
            resultBox.classList.remove('hidden');
            document.getElementById('btn-copy').classList.remove('hidden');

            if (currentMode === 'encrypt') {
                const lines = inputVal.split(/\r?\n/).filter(line => line.trim() !== '');
                if (lines.length === 0) return;
                let payload = lines.join(DELIMITER);
                
                if(expiryVal > 0) {
                    const expiryTime = Date.now() + (expiryVal * 60 * 1000); 
                    payload += TIME_MARKER + expiryTime;
                }

                let finalOutput;
                if(passVal) {
                    finalOutput = wrapWithPass(payload, passVal);
                } else {
                    finalOutput = complexEncrypt(payload);
                }
                
                resultBox.className = "break-all font-mono text-sm text-emerald-400";
                resultBox.innerText = finalOutput;
            } else {
                let decrypted = null;

                if (inputVal.startsWith(PASS_MARKER)) {
                    if (!passVal) {
                        resultBox.innerText = "Error: This payload is locked. Please enter the passcode.";
                        resultBox.className = "text-red-500";
                        return;
                    }
                    const unlockResult = unwrapPass(inputVal, passVal);
                    if (unlockResult === "WRONG_PASS") {
                        resultBox.innerText = "Error: Invalid Passcode.";
                        resultBox.className = "text-red-500";
                        return;
                    }
                    decrypted = unlockResult;
                } else {
                    decrypted = complexDecrypt(inputVal);
                }
                
                if (decrypted) {
                    if(decrypted.includes(TIME_MARKER)) {
                        const parts = decrypted.split(TIME_MARKER);
                        const content = parts[0];
                        const expiry = parseInt(parts[1]);
                        
                        if(Date.now() > expiry) {
                            resultBox.innerHTML = "STATUS: <b>DECEASED</b><br>This payload has expired and has been purged.";
                            resultBox.className = "text-red-500";
                            return;
                        }
                        decrypted = content; 
                    }

                    // Check if decrypted content contains URLs
                    const parts = decrypted.split(DELIMITER);
                    const hasUrls = parts.some(part => isUrl(part.trim()));
                    
                    if (hasUrls) {
                        // Contains URLs - show launch buttons
                        hiddenTargetUrls = parts.filter(part => {
                            const trimmed = part.trim();
                            return trimmed && isUrl(trimmed);
                        });
                        
                    const container = document.getElementById('launch-buttons-container');
                    container.innerHTML = '';
                    
                    hiddenTargetUrls.forEach((url, index) => {
                        let safeUrl = url.trim();
                        if (safeUrl && !safeUrl.match(/^https?:\/\//i)) {
                            safeUrl = 'https://' + safeUrl;
                        }

                        const btn = document.createElement('button');
                        btn.type = "button";
                        btn.className = "bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-2 px-6 rounded-full flex items-center gap-2 transition-all shadow-[0_0_15px_rgba(16,185,129,0.4)] w-full justify-center shrink-0 mb-2";
                        btn.innerHTML = `Launch Target ${hiddenTargetUrls.length > 1 ? index + 1 : ''} <i data-lucide="arrow-right-circle" class="w-4 h-4"></i>`;
                        btn.onclick = () => window.open(safeUrl, '_blank', 'noopener,noreferrer');
                        container.appendChild(btn);
                    });
                    
                    lucide.createIcons();
                    document.getElementById('result-launch').classList.remove('hidden');
                    resultBox.innerText = decrypted;
                    } else {
                        // Plain text - display directly
                        document.getElementById('result-launch').classList.add('hidden');
                        resultBox.className = "break-all font-mono text-sm text-emerald-400";
                        resultBox.innerText = decrypted;
                    }
                } else {
                    resultBox.innerText = "Error: Decryption failed. Invalid signature or corrupted string.";
                    resultBox.className = "text-red-500";
                }
            }
        }

        // --- 3. STEGO LOGIC (Restored Full Logic) ---
        let generatedCarrierBlob = null;

        function generateNoiseCarrier() {
            const canvas = document.createElement('canvas');
            canvas.width = 800; 
            canvas.height = 800;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#09090b'; 
            ctx.fillRect(0, 0, 800, 800);
            
            for(let i=0; i<60000; i++) {
                const x = Math.random() * 800;
                const y = Math.random() * 800;
                const gray = Math.floor(Math.random() * 50) + 20; 
                const size = Math.random() * 2 + 1;
                ctx.fillStyle = `rgba(${gray},${gray},${gray}, 0.8)`;
                ctx.fillRect(x, y, size, size);
            }
            
            return new Promise(resolve => canvas.toBlob(resolve));
        }

        async function generateCarrierImage() {
            const statusDiv = document.getElementById('generated-status');
            statusDiv.innerHTML = '<span class="animate-pulse">Generating noise pattern...</span>';
            statusDiv.classList.remove('hidden');
            
            try {
                generatedCarrierBlob = await generateNoiseCarrier();
                statusDiv.innerHTML = '<i data-lucide="check" class="w-3 h-3 inline"></i> Carrier Generated & Ready';
                lucide.createIcons();
                document.getElementById('stego-upload-inject').value = '';
                document.getElementById('file-name-display').innerText = "Using Generated Image";
            } catch(e) {
                statusDiv.innerText = "Generation failed.";
            }
        }

        function stegoInject() {
            const fileInput = document.getElementById('stego-upload-inject');
            const textInput = document.getElementById('stego-text-inject').value.trim();
            const passInput = document.getElementById('stego-pass-inject').value.trim();
            
            let sourceBlob = null;
            if (fileInput.files[0]) {
                sourceBlob = fileInput.files[0];
            } else if (generatedCarrierBlob) {
                sourceBlob = generatedCarrierBlob;
            }

            if (!sourceBlob || !textInput) {
                alert("Please select/generate an image and enter payload text.");
                return;
            }

            let finalPayload = textInput;
            if(passInput) {
                finalPayload = wrapWithPass(textInput, passInput);
            }

            processStegoInjection(sourceBlob, finalPayload);
        }

        function processStegoInjection(blob, textPayload) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imgData.data;
                    
                    const payload = textPayload + String.fromCharCode(0);
                    const binary = [];
                    for (let i = 0; i < payload.length; i++) {
                        let bin = payload.charCodeAt(i).toString(2).padStart(8, '0');
                        for(let j=0; j<8; j++) binary.push(parseInt(bin[j]));
                    }

                    if (binary.length > data.length / 4) {
                        alert("Image is too small for this payload.");
                        return;
                    }

                    let binIndex = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        if (binIndex < binary.length) {
                            for(let j=0; j<3; j++) { 
                                if(binIndex < binary.length) {
                                    data[i+j] = (data[i+j] & ~1) | binary[binIndex];
                                    binIndex++;
                                }
                            }
                        } else {
                            break;
                        }
                    }

                    ctx.putImageData(imgData, 0, 0);
                    const link = document.createElement('a');
                    link.download = 'coded_image.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(blob);
        }

        async function stegoExtract() {
            const fileInput = document.getElementById('stego-upload-extract');
            const files = fileInput.files;
            const passInput = document.getElementById('stego-pass-extract').value.trim();
            const resultArea = document.getElementById('stego-result-area');
            
            if (files.length === 0) return alert("Please select at least one image.");

            resultArea.innerHTML = '';
            
            for(let i = 0; i < files.length; i++) {
                const file = files[i];
                const cardId = `stego-res-${i}`;
                
                const card = document.createElement('div');
                card.id = cardId;
                card.className = "bg-black/50 p-3 rounded border-l-2 border-zinc-700 animate-in mb-2";
                card.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-xs font-bold text-zinc-300 truncate w-3/4">${file.name}</span>
                        <i data-lucide="loader-2" class="w-3 h-3 text-zinc-500 animate-spin" id="${cardId}-icon"></i>
                    </div>
                    <div class="text-[10px] text-zinc-500 font-mono" id="${cardId}-status">Scanning...</div>
                    <div id="${cardId}-content" class="mt-2 hidden"></div>
                `;
                resultArea.appendChild(card);
                lucide.createIcons();

                try {
                    const text = await processSingleImage(file);
                    handleDecryptedText(text, passInput, cardId);
                } catch (e) {
                    const statusDiv = document.getElementById(`${cardId}-status`);
                    const icon = document.getElementById(`${cardId}-icon`);
                    statusDiv.innerHTML = `<span class="text-red-900 bg-red-900/10 px-1 rounded">No payload found</span>`;
                    icon.setAttribute('data-lucide', 'x-circle');
                    icon.classList.remove('animate-spin');
                    icon.classList.add('text-red-800');
                    card.classList.replace('border-zinc-700', 'border-red-900');
                    lucide.createIcons();
                }
            }
        }

        function processSingleImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imgData.data;
                            
                            let charBinary = "";
                            let resultText = "";
                            
                            for (let i = 0; i < data.length; i += 4) {
                                for(let j=0; j<3; j++) { 
                                    charBinary += (data[i+j] & 1).toString();
                                    if (charBinary.length === 8) {
                                        const charCode = parseInt(charBinary, 2);
                                        if (charCode === 0) { 
                                            resolve(resultText);
                                            return;
                                        }
                                        resultText += String.fromCharCode(charCode);
                                        charBinary = "";
                                    }
                                }
                            }
                            reject(new Error("No null terminator"));
                        } catch(err) {
                            reject(err);
                        }
                    };
                    img.onerror = () => reject(new Error("Invalid image"));
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function handleDecryptedText(extractedText, password, cardId) {
            const statusDiv = document.getElementById(`${cardId}-status`);
            const contentDiv = document.getElementById(`${cardId}-content`);
            const icon = document.getElementById(`${cardId}-icon`);
            const card = document.getElementById(cardId);
            
            let finalText = extractedText;
            let statusHtml = '<span class="text-emerald-500">Decrypted</span>';
            let cardColor = 'border-emerald-600';

            if (extractedText.startsWith(PASS_MARKER)) {
                if (!password) {
                    statusHtml = '<span class="text-amber-500 font-bold">LOCKED: Passcode Required</span>';
                    cardColor = 'border-amber-600';
                    icon.setAttribute('data-lucide', 'lock');
                    card.classList.replace('border-zinc-700', cardColor);
                    statusDiv.innerHTML = statusHtml;
                    icon.classList.remove('animate-spin');
                    icon.classList.add('text-amber-500');
                    lucide.createIcons();
                    return; 
                }
                const unlockResult = unwrapPass(extractedText, password);
                if (unlockResult === "WRONG_PASS") {
                    statusHtml = '<span class="text-red-500 font-bold">Wrong Passcode</span>';
                    cardColor = 'border-red-600';
                    icon.setAttribute('data-lucide', 'shield-alert');
                    card.classList.replace('border-zinc-700', cardColor);
                    statusDiv.innerHTML = statusHtml;
                    icon.classList.remove('animate-spin');
                    icon.classList.add('text-red-500');
                    lucide.createIcons();
                    return;
                }
                finalText = unlockResult;
            }

            // Try complex decrypt, but if it fails, use the text as-is (for password-only protected text)
            const autoDecrypt = complexDecrypt(finalText);
            if (autoDecrypt) {
                 if(autoDecrypt.includes(TIME_MARKER)) {
                    const parts = autoDecrypt.split(TIME_MARKER);
                    const content = parts[0];
                    const expiry = parseInt(parts[1]);
                    if(Date.now() > expiry) {
                         statusHtml = '<span class="text-red-600 font-bold">EXPIRED / DELETED</span>';
                         cardColor = 'border-red-900';
                         finalText = null;
                    } else {
                        finalText = content;
                    }
                } else {
                    finalText = autoDecrypt;
                }
            }
            // If complexDecrypt returns null, keep finalText as-is (password-only protected text)

            icon.classList.remove('animate-spin');
            
            if(finalText === null) {
                icon.setAttribute('data-lucide', 'skull');
                icon.classList.add('text-red-700');
            } else {
                icon.setAttribute('data-lucide', 'check-circle');
                icon.classList.add('text-emerald-500');
                
                const isUrl = finalText.includes('http') || finalText.includes('www');
                const multiLinks = finalText.split(DELIMITER);
                contentDiv.classList.remove('hidden');

                if (multiLinks.length > 1 || isUrl) {
                    const validLinks = multiLinks.filter(l => l.includes('http') || l.includes('www'));
                    if(validLinks.length > 0) {
                        validLinks.forEach((url, idx) => {
                            let safeUrl = url.trim();
                            if (safeUrl && !safeUrl.match(/^https?:\/\//i)) safeUrl = 'https://' + safeUrl;
                            const btn = document.createElement('button');
                            btn.className = "w-full text-left text-[10px] text-emerald-400 hover:text-emerald-300 hover:underline mb-1 truncate flex items-center gap-1";
                            btn.innerHTML = `<i data-lucide="external-link" class="w-3 h-3"></i> ${safeUrl}`;
                            btn.onclick = () => window.open(safeUrl, '_blank', 'noopener,noreferrer');
                            contentDiv.appendChild(btn);
                        });
                    } else {
                        contentDiv.innerHTML = `<p class="text-[10px] text-zinc-400 break-all" style="unicode-bidi: plaintext;">${finalText}</p>`;
                    }
                } else {
                        contentDiv.innerHTML = `<p class="text-[10px] text-zinc-400 break-all bg-zinc-900 p-1 rounded" style="unicode-bidi: plaintext;">${finalText}</p>`;
                }
            }
            card.classList.replace('border-zinc-700', cardColor);
            statusDiv.innerHTML = statusHtml;
            lucide.createIcons();
        }

        // --- 4. KEY FORGE LOGIC ---
        function strToBytes(str) {
            const utf8 = unescape(encodeURIComponent(str));
            const arr = new Uint8Array(utf8.length);
            for (let i = 0; i < utf8.length; i++) arr[i] = utf8.charCodeAt(i);
            return arr;
        }

        function bytesToStr(arr) {
            let str = '';
            for (let i = 0; i < arr.length; i++) str += String.fromCharCode(arr[i]);
            return decodeURIComponent(escape(str));
        }

        function bytesToHex(arr) {
            return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function hexToBytes(hex) {
            const pairs = hex.match(/.{1,2}/g) || [];
            return new Uint8Array(pairs.map(byte => parseInt(byte, 16)));
        }

        function forgeKeys() {
            const secret = document.getElementById('keys-input').value;
            const count = parseInt(document.getElementById('keys-count').value);
            const outputDiv = document.getElementById('forge-output');

            if (!secret) return alert("Enter a secret first.");

            const secretBytes = strToBytes(secret);
            const len = secretBytes.length;
            const keys = [];

            // Generate N-1 random keys
            let finalXor = new Uint8Array(len);
            for(let i=0; i<len; i++) finalXor[i] = secretBytes[i];

            for (let i = 0; i < count - 1; i++) {
                const randomBytes = new Uint8Array(len);
                crypto.getRandomValues(randomBytes);
                keys.push(randomBytes);
                // XOR this random key into our running total
                for(let j=0; j<len; j++) finalXor[j] ^= randomBytes[j];
            }

            // The last key is the result of (Secret XOR R1 XOR R2 ... XOR Rn-1)
            keys.push(finalXor);

            // Render Output
            outputDiv.classList.remove('hidden');
            outputDiv.innerHTML = '';
            
            const list = document.createElement('div');
            list.className = 'space-y-2';

            keys.forEach((k, idx) => {
                const hex = bytesToHex(k);
                const div = document.createElement('div');
                div.className = "flex gap-2 items-center bg-zinc-900 p-2 rounded border border-zinc-800";
                div.innerHTML = `
                    <span class="text-amber-600 font-bold select-none w-6">${idx+1}.</span>
                    <code class="flex-grow select-all text-amber-500 break-all">${hex}</code>
                    <button onclick="navigator.clipboard.writeText('${hex}').then(() => { const btn = this; const orig = btn.innerHTML; btn.innerHTML = '<i data-lucide=\\'check\\' class=\\'w-3 h-3\\'></i>'; setTimeout(() => btn.innerHTML = orig, 1000); }); lucide.createIcons();" class="text-zinc-500 hover:text-white transition-colors flex-shrink-0"><i data-lucide="copy" class="w-3 h-3"></i></button>
                `;
                list.appendChild(div);
            });
            outputDiv.appendChild(list);
            
            const note = document.createElement('div');
            note.className = "mt-4 text-center text-zinc-500 italic text-xs";
            note.innerText = "â ï¸ Copy all keys. If any key is lost, data is unrecoverable.";
            outputDiv.appendChild(note);
            lucide.createIcons();
        }

        function unlockKeys() {
            const input = document.getElementById('keys-unlock-input').value;
            const resultDiv = document.getElementById('unlock-result');
            
            if (!input.trim()) return;

            const lines = input.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
            
            if (lines.length < 2) {
                resultDiv.classList.remove('hidden');
                resultDiv.innerText = "Need at least 2 keys to combine.";
                resultDiv.className = "w-full bg-red-950/50 border border-red-900 rounded-lg p-3 text-red-400 text-center";
                return;
            }

            try {
                // Decode first key hex
                let combined = hexToBytes(lines[0]);
                
                // XOR with rest
                for(let i=1; i<lines.length; i++) {
                    const current = hexToBytes(lines[i]);
                    if(current.length !== combined.length) throw new Error("Length mismatch");
                    
                    for(let j=0; j<combined.length; j++) {
                        combined[j] ^= current[j];
                    }
                }

                const result = bytesToStr(combined);
                resultDiv.classList.remove('hidden');
                resultDiv.innerHTML = `<span class="text-zinc-500 text-xs block mb-2">Decrypted Secret:</span><span class="text-emerald-400 text-lg font-bold break-all">${result}</span>`;
                resultDiv.className = "w-full bg-zinc-950 border border-emerald-900/50 rounded-lg p-4 font-mono break-all text-center";

            } catch(e) {
                resultDiv.classList.remove('hidden');
                resultDiv.innerText = "Decryption Failed. Invalid keys or mismatch.";
                resultDiv.className = "w-full bg-red-950/50 border border-red-900 rounded-lg p-3 text-red-400 text-center";
            }
        }

        // --- 5. SONIC LAB EXPERIMENT (NEW) ---
        let audioContext;
        let analyser;
        let visualizerCanvas;
        let visualizerCtx;
        let animationFrameId = null;
        let isVisualizerActive = false;
        
        function initVisualizer() {
            if(audioContext && isVisualizerActive) return;
            try {
                if(!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                }
                visualizerCanvas = document.getElementById('sonic-canvas');
                if(!visualizerCanvas) return;
                visualizerCtx = visualizerCanvas.getContext('2d');
                visualizerCanvas.width = visualizerCanvas.offsetWidth;
                visualizerCanvas.height = visualizerCanvas.offsetHeight;
                isVisualizerActive = true;
                drawVisualizer();
            } catch(e) { console.log("Audio API blocked"); }
        }

        function stopVisualizer() {
            isVisualizerActive = false;
            if(animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function drawVisualizer() {
            if(!isVisualizerActive || !analyser || !visualizerCanvas || !visualizerCtx) {
                animationFrameId = null;
                return;
            }
            animationFrameId = requestAnimationFrame(drawVisualizer);
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            visualizerCtx.fillStyle = '#000';
            visualizerCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

            const barWidth = (visualizerCanvas.width / bufferLength) * 2.5;
            let barHeight;
            let x = 0;

            for(let i = 0; i < bufferLength; i++) {
                barHeight = dataArray[i] / 2;
                visualizerCtx.fillStyle = `rgb(${barHeight + 20}, ${50 + barHeight}, ${200})`;
                visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function playTone() {
            if(!audioContext) initVisualizer();
            if(!audioContext || !analyser) return;
            if(audioContext.state === 'suspended') audioContext.resume();
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
            
            gain.gain.setValueAtTime(0.1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            osc.connect(gain);
            gain.connect(analyser);
            analyser.connect(audioContext.destination);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.5);
        }

        function generateSonic() {
            const msg = document.getElementById('sonic-input').value;
            if(!msg) return alert("Enter message");

            const btn = document.getElementById('btn-sonic-gen');
            btn.innerHTML = "Generating...";
            playTone(); 

            setTimeout(() => {
                const sampleRate = 44100;
                const duration = 10; 
                const numSamples = sampleRate * duration;
                
                const header = "MKD_SONIC::";
                const payload = header + msg + "\0"; 
                const binary = [];
                for (let i = 0; i < payload.length; i++) {
                    let bin = payload.charCodeAt(i).toString(2).padStart(8, '0');
                    for(let j=0; j<8; j++) binary.push(parseInt(bin[j]));
                }

                const buffer = new Int16Array(numSamples);
                let binIdx = 0;

                for (let i = 0; i < numSamples; i++) {
                    const t = i / sampleRate;
                    const f1 = 50; 
                    const f2 = 55; 
                    let sample = Math.sin(2 * Math.PI * f1 * t) * 0.4 + 
                                 Math.sin(2 * Math.PI * f2 * t) * 0.4 + 
                                 (Math.random() - 0.5) * 0.1; 
                    
                    let intSample = Math.floor(sample * 30000);

                    if (binIdx < binary.length) {
                        intSample = (intSample & ~1) | binary[binIdx];
                        binIdx++;
                    }

                    buffer[i] = intSample;
                }

                if (binIdx < binary.length) {
                    alert("Message too long for 10s audio");
                    btn.innerHTML = `<i data-lucide="activity" class="w-4 h-4"></i> Generate`;
                    return;
                }

                const wavBytes = encodeWAV(buffer, sampleRate);
                const blob = new Blob([wavBytes], { type: 'audio/wav' });
                
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `sonic_artifact_${Date.now()}.wav`;
                link.click();
                
                btn.innerHTML = `<i data-lucide="check" class="w-4 h-4"></i> Done`;
                lucide.createIcons();
                setTimeout(() => btn.innerHTML = `<i data-lucide="activity" class="w-4 h-4"></i> Generate & Download WAV`, 2000);
            }, 100);
        }

        function handleSonicUpload(input) {
            document.getElementById('sonic-file-name').innerText = input.files[0]?.name || "Drop .WAV File";
        }

        function decodeSonic() {
            const input = document.getElementById('sonic-upload');
            if(!input.files[0]) return alert("Upload file first");

            const reader = new FileReader();
            reader.onload = function(e) {
                const buffer = e.target.result;
                const dataView = new DataView(buffer);
                
                let text = "";
                let binChar = "";
                
                try {
                    for (let i = 44; i < dataView.byteLength; i += 2) {
                        const sample = dataView.getInt16(i, true); 
                        const bit = sample & 1;
                        binChar += bit;

                        if (binChar.length === 8) {
                            const charCode = parseInt(binChar, 2);
                            if (charCode === 0) break;
                            text += String.fromCharCode(charCode);
                            binChar = "";
                        }
                    }

                    const resultDiv = document.getElementById('sonic-result');
                    const textDiv = document.getElementById('sonic-result-text');
                    resultDiv.classList.remove('hidden');

                    if (text.startsWith("MKD_SONIC::")) {
                        textDiv.innerText = text.replace("MKD_SONIC::", "");
                        textDiv.className = "text-cyan-400";
                        playTone();
                    } else {
                        textDiv.innerText = "No hidden data found or corrupted signal.";
                        textDiv.className = "text-red-500";
                    }
                } catch(e) {
                    alert("Error parsing audio.");
                }
            };
            reader.readAsArrayBuffer(input.files[0]);
        }

        function encodeWAV(samples, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');

            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); 
            view.setUint16(22, 1, true); 
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true); 
            view.setUint16(34, 16, true); 

            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);

            let offset = 44;
            for (let i = 0; i < samples.length; i++, offset += 2) {
                view.setInt16(offset, samples[i], true);
            }

            return buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // --- 5. GHOST COMMS (ZERO-KNOWLEDGE ENCRYPTED MESSAGING) ---
        let ghostCryptoKey = null;
        let ghostRoomId = null;
        let ghostHandle = null;
        let ghostUnsubscribe = null;
        let ghostRoomPassword = null;
        let isRoomCreator = false;
        let ghostRoomSettings = {
            enableDownload: false,
            enableDelete: false,
            enableGifs: false
        };

        // MASTER KEYS (100 Lifetime Keys)
        const MASTER_KEYS = [
            "GHOST-2025-KEY-001-ALPHA-BRAVO-CHARLIE",
            "GHOST-2025-KEY-002-DELTA-ECHO-FOXTROT",
            "GHOST-2025-KEY-003-GOLF-HOTEL-INDIA",
            "GHOST-2025-KEY-004-JULIET-KILO-LIMA",
            "GHOST-2025-KEY-005-MIKE-NOVEMBER-OSCAR",
            "GHOST-2025-KEY-006-PAPA-QUEBEC-ROMEO",
            "GHOST-2025-KEY-007-SIERRA-TANGO-UNIFORM",
            "GHOST-2025-KEY-008-VICTOR-WHISKEY-XRAY",
            "GHOST-2025-KEY-009-YANKEE-ZULU-ALPHA",
            "GHOST-2025-KEY-010-BRAVO-CHARLIE-DELTA",
            "GHOST-2025-KEY-011-ECHO-FOXTROT-GOLF",
            "GHOST-2025-KEY-012-HOTEL-INDIA-JULIET",
            "GHOST-2025-KEY-013-KILO-LIMA-MIKE",
            "GHOST-2025-KEY-014-NOVEMBER-OSCAR-PAPA",
            "GHOST-2025-KEY-015-QUEBEC-ROMEO-SIERRA",
            "GHOST-2025-KEY-016-TANGO-UNIFORM-VICTOR",
            "GHOST-2025-KEY-017-WHISKEY-XRAY-YANKEE",
            "GHOST-2025-KEY-018-ZULU-ALPHA-BRAVO",
            "GHOST-2025-KEY-019-CHARLIE-DELTA-ECHO",
            "GHOST-2025-KEY-020-FOXTROT-GOLF-HOTEL",
            "GHOST-2025-KEY-021-INDIA-JULIET-KILO",
            "GHOST-2025-KEY-022-LIMA-MIKE-NOVEMBER",
            "GHOST-2025-KEY-023-OSCAR-PAPA-QUEBEC",
            "GHOST-2025-KEY-024-ROMEO-SIERRA-TANGO",
            "GHOST-2025-KEY-025-UNIFORM-VICTOR-WHISKEY",
            "GHOST-2025-KEY-026-XRAY-YANKEE-ZULU",
            "GHOST-2025-KEY-027-ALPHA-BRAVO-CHARLIE",
            "GHOST-2025-KEY-028-DELTA-ECHO-FOXTROT",
            "GHOST-2025-KEY-029-GOLF-HOTEL-INDIA",
            "GHOST-2025-KEY-030-JULIET-KILO-LIMA",
            "GHOST-2025-KEY-031-MIKE-NOVEMBER-OSCAR",
            "GHOST-2025-KEY-032-PAPA-QUEBEC-ROMEO",
            "GHOST-2025-KEY-033-SIERRA-TANGO-UNIFORM",
            "GHOST-2025-KEY-034-VICTOR-WHISKEY-XRAY",
            "GHOST-2025-KEY-035-YANKEE-ZULU-ALPHA",
            "GHOST-2025-KEY-036-BRAVO-CHARLIE-DELTA",
            "GHOST-2025-KEY-037-ECHO-FOXTROT-GOLF",
            "GHOST-2025-KEY-038-HOTEL-INDIA-JULIET",
            "GHOST-2025-KEY-039-KILO-LIMA-MIKE",
            "GHOST-2025-KEY-040-NOVEMBER-OSCAR-PAPA",
            "GHOST-2025-KEY-041-QUEBEC-ROMEO-SIERRA",
            "GHOST-2025-KEY-042-TANGO-UNIFORM-VICTOR",
            "GHOST-2025-KEY-043-WHISKEY-XRAY-YANKEE",
            "GHOST-2025-KEY-044-ZULU-ALPHA-BRAVO",
            "GHOST-2025-KEY-045-CHARLIE-DELTA-ECHO",
            "GHOST-2025-KEY-046-FOXTROT-GOLF-HOTEL",
            "GHOST-2025-KEY-047-INDIA-JULIET-KILO",
            "GHOST-2025-KEY-048-LIMA-MIKE-NOVEMBER",
            "GHOST-2025-KEY-049-OSCAR-PAPA-QUEBEC",
            "GHOST-2025-KEY-050-ROMEO-SIERRA-TANGO",
            "GHOST-2025-KEY-051-UNIFORM-VICTOR-WHISKEY",
            "GHOST-2025-KEY-052-XRAY-YANKEE-ZULU",
            "GHOST-2025-KEY-053-ALPHA-BRAVO-CHARLIE",
            "GHOST-2025-KEY-054-DELTA-ECHO-FOXTROT",
            "GHOST-2025-KEY-055-GOLF-HOTEL-INDIA",
            "GHOST-2025-KEY-056-JULIET-KILO-LIMA",
            "GHOST-2025-KEY-057-MIKE-NOVEMBER-OSCAR",
            "GHOST-2025-KEY-058-PAPA-QUEBEC-ROMEO",
            "GHOST-2025-KEY-059-SIERRA-TANGO-UNIFORM",
            "GHOST-2025-KEY-060-VICTOR-WHISKEY-XRAY",
            "GHOST-2025-KEY-061-YANKEE-ZULU-ALPHA",
            "GHOST-2025-KEY-062-BRAVO-CHARLIE-DELTA",
            "GHOST-2025-KEY-063-ECHO-FOXTROT-GOLF",
            "GHOST-2025-KEY-064-HOTEL-INDIA-JULIET",
            "GHOST-2025-KEY-065-KILO-LIMA-MIKE",
            "GHOST-2025-KEY-066-NOVEMBER-OSCAR-PAPA",
            "GHOST-2025-KEY-067-QUEBEC-ROMEO-SIERRA",
            "GHOST-2025-KEY-068-TANGO-UNIFORM-VICTOR",
            "GHOST-2025-KEY-069-WHISKEY-XRAY-YANKEE",
            "GHOST-2025-KEY-070-ZULU-ALPHA-BRAVO",
            "GHOST-2025-KEY-071-CHARLIE-DELTA-ECHO",
            "GHOST-2025-KEY-072-FOXTROT-GOLF-HOTEL",
            "GHOST-2025-KEY-073-INDIA-JULIET-KILO",
            "GHOST-2025-KEY-074-LIMA-MIKE-NOVEMBER",
            "GHOST-2025-KEY-075-OSCAR-PAPA-QUEBEC",
            "GHOST-2025-KEY-076-ROMEO-SIERRA-TANGO",
            "GHOST-2025-KEY-077-UNIFORM-VICTOR-WHISKEY",
            "GHOST-2025-KEY-078-XRAY-YANKEE-ZULU",
            "GHOST-2025-KEY-079-ALPHA-BRAVO-CHARLIE",
            "GHOST-2025-KEY-080-DELTA-ECHO-FOXTROT",
            "GHOST-2025-KEY-081-GOLF-HOTEL-INDIA",
            "GHOST-2025-KEY-082-JULIET-KILO-LIMA",
            "GHOST-2025-KEY-083-MIKE-NOVEMBER-OSCAR",
            "GHOST-2025-KEY-084-PAPA-QUEBEC-ROMEO",
            "GHOST-2025-KEY-085-SIERRA-TANGO-UNIFORM",
            "GHOST-2025-KEY-086-VICTOR-WHISKEY-XRAY",
            "GHOST-2025-KEY-087-YANKEE-ZULU-ALPHA",
            "GHOST-2025-KEY-088-BRAVO-CHARLIE-DELTA",
            "GHOST-2025-KEY-089-ECHO-FOXTROT-GOLF",
            "GHOST-2025-KEY-090-HOTEL-INDIA-JULIET",
            "GHOST-2025-KEY-091-KILO-LIMA-MIKE",
            "GHOST-2025-KEY-092-NOVEMBER-OSCAR-PAPA",
            "GHOST-2025-KEY-093-QUEBEC-ROMEO-SIERRA",
            "GHOST-2025-KEY-094-TANGO-UNIFORM-VICTOR",
            "GHOST-2025-KEY-095-WHISKEY-XRAY-YANKEE",
            "GHOST-2025-KEY-096-ZULU-ALPHA-BRAVO",
            "GHOST-2025-KEY-097-CHARLIE-DELTA-ECHO",
            "GHOST-2025-KEY-098-FOXTROT-GOLF-HOTEL",
            "GHOST-2025-KEY-099-INDIA-JULIET-KILO",
            "GHOST-2025-KEY-100-LIMA-MIKE-NOVEMBER"
        ];

        // Validate master key
        function validateMasterKey(key) {
            return MASTER_KEYS.includes(key.trim());
        }

        // Open/Close Modal
        function openGhostComms() {
            document.getElementById('ghost-modal').classList.remove('hidden');
            document.getElementById('ghost-notification-dot').classList.add('hidden');
            lucide.createIcons();
        }

        function closeGhostComms() {
            document.getElementById('ghost-modal').classList.add('hidden');
        }

        // Check URL for room link
        function checkRoomLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room');
            const password = urlParams.get('pass');
            
            if (roomId && password) {
                openGhostComms();
                document.getElementById('ghost-room-id-join').value = roomId;
                document.getElementById('ghost-password-join').value = password;
                // Auto-join will be handled by user clicking join
            }
        }

        // Generate shareable link
        function generateRoomLink(roomId, password) {
            const currentUrl = window.location.origin + window.location.pathname;
            return `${currentUrl}?room=${encodeURIComponent(roomId)}&pass=${encodeURIComponent(password)}`;
        }

        // Copy room link
        function copyRoomLink() {
            if (!ghostRoomId || !ghostRoomPassword) return;
            
            const link = generateRoomLink(ghostRoomId, ghostRoomPassword);
            navigator.clipboard.writeText(link).then(() => {
                const btn = document.getElementById('ghost-share-btn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i data-lucide="check" class="w-4 h-4"></i> Copied!';
                btn.classList.add('bg-emerald-600');
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('bg-emerald-600');
                }, 2000);
                lucide.createIcons();
            }).catch(() => {
                prompt("Copy this link:", link);
            });
        }

        // Join via link
        async function joinViaLink() {
            const urlParams = new URLSearchParams(window.location.search);
            let roomId = urlParams.get('room') || document.getElementById('ghost-room-id-join')?.value.trim();
            let password = urlParams.get('pass') || document.getElementById('ghost-password-join')?.value.trim();
            const handle = document.getElementById('ghost-handle-join').value.trim();

            if (!roomId || !password || !handle) {
                alert("Please fill in all fields or use a shared link.");
                return;
            }

            isRoomCreator = false;
            await joinGhostRoomDirect(roomId, password, handle);
        }

        // Create room (requires master key)
        async function createGhostRoom() {
            const masterKey = document.getElementById('ghost-master-key').value.trim();
            const roomId = document.getElementById('ghost-room-id-create').value.trim();
            const password = document.getElementById('ghost-password-create').value.trim();
            const handle = document.getElementById('ghost-handle-create').value.trim();

            if (!masterKey || !roomId || !password || !handle) {
                alert("Please fill in all fields.");
                return;
            }

            if (!validateMasterKey(masterKey)) {
                alert("Invalid master key. Only authorized users can create rooms.");
                return;
            }

            // Get room settings
            ghostRoomSettings = {
                enableDownload: document.getElementById('ghost-enable-download').checked,
                enableDelete: document.getElementById('ghost-enable-delete').checked,
                enableGifs: document.getElementById('ghost-enable-gifs').checked
            };

            isRoomCreator = true;
            await joinGhostRoomDirect(roomId, password, handle, true);
        }

        // PBKDF2 Key Derivation (100,000 iterations) - Global scope
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );

            const key = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: encoder.encode(salt),
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                passwordKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );

            return key;
        }

        // AES-GCM Encryption - Global scope (with emoji support via UTF-8)
        async function encryptMessage(text, key) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text); // UTF-8 encoding handles emojis properly
            
            // Generate random IV (12 bytes for GCM)
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );

            // Return IV + encrypted data as base64
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);

            return {
                iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join(''),
                data: btoa(String.fromCharCode(...combined))
            };
        }

        // AES-GCM Decryption - Global scope (with emoji support via UTF-8)
        async function decryptMessage(encryptedData, ivHex, key) {
            try {
                const iv = new Uint8Array(ivHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                
                // Extract actual encrypted data (skip IV)
                const encrypted = data.slice(12);

                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );

                const decoder = new TextDecoder('utf-8'); // Explicit UTF-8 for emoji support
                return decoder.decode(decrypted);
            } catch (error) {
                throw new Error('Decryption failed - wrong password or corrupted data');
            }
        }

        // Direct join function
        async function joinGhostRoomDirect(roomId, password, handle, isCreating = false) {

            // Wait a moment for Firebase to initialize if needed
            if (!window.firebaseDB) {
                await new Promise(resolve => setTimeout(resolve, 500));
                if (!window.firebaseDB) {
                    alert("Firebase not initialized. Please check your Firebase configuration and ensure Firestore Database is created.");
                    return;
                }
            }

            try {
                // Derive encryption key from password + room ID
                ghostCryptoKey = await deriveKey(password, roomId);
                ghostRoomId = roomId;
                ghostHandle = handle;
                ghostRoomPassword = password;

                // Save or load room settings
                if (isCreating) {
                    // Save room settings when creating
                    const roomSettingsRef = window.firebaseCollection(window.firebaseDB, `rooms/${roomId}/settings`);
                    await window.firebaseAddDoc(roomSettingsRef, {
                        ...ghostRoomSettings,
                        createdAt: window.firebaseServerTimestamp(),
                        creator: handle
                    });
                } else {
                    // Load room settings when joining
                    try {
                        const roomSettingsRef = window.firebaseCollection(window.firebaseDB, `rooms/${roomId}/settings`);
                        const roomSettingsQuery = window.firebaseQuery(roomSettingsRef, window.firebaseOrderBy('createdAt', 'desc'));
                        const roomSnapshot = await new Promise((resolve) => {
                            const unsubscribe = window.firebaseOnSnapshot(roomSettingsQuery, (snapshot) => {
                                unsubscribe();
                                resolve(snapshot);
                            });
                        });
                        
                        if (!roomSnapshot.empty) {
                            const roomData = roomSnapshot.docs[0].data();
                            ghostRoomSettings = {
                                enableDownload: roomData.enableDownload || false,
                                enableDelete: roomData.enableDelete || false,
                                enableGifs: roomData.enableGifs || false
                            };
                        }
                    } catch (e) {
                        console.warn('Could not load room settings:', e);
                    }
                }

                // Hide join panel, show share button and disconnect
                document.getElementById('ghost-join-panel').classList.add('hidden');
                if (isRoomCreator) {
                    document.getElementById('ghost-share-btn').classList.remove('hidden');
                }
                document.getElementById('ghost-disconnect-btn').classList.remove('hidden');
                
                // Update chat header
                document.getElementById('ghost-room-display').textContent = roomId;
                document.getElementById('ghost-room-status').textContent = `Connected as ${handle}${isRoomCreator ? ' (Creator)' : ''}`;
                document.getElementById('ghost-encryption-indicator').className = 'w-2 h-2 rounded-full bg-emerald-500 animate-pulse';
                
                // Enable messaging and features based on settings
                document.getElementById('ghost-message-input').disabled = false;
                document.getElementById('ghost-send-btn').disabled = false;
                document.getElementById('ghost-emoji-btn').disabled = false;
                document.getElementById('ghost-audio-btn').disabled = false;
                
                // Enable download button if feature is enabled
                if (ghostRoomSettings.enableDownload) {
                    document.getElementById('ghost-download-btn').classList.remove('hidden');
                }
                
                // Enable GIF button (always show, allows file upload even if feature disabled)
                    document.getElementById('ghost-gif-btn').classList.remove('hidden');
                    document.getElementById('ghost-gif-btn').disabled = false;
                
                // Always show Chaos and Sonic buttons (they're fun features)
                document.getElementById('ghost-chaos-btn').classList.remove('hidden');
                document.getElementById('ghost-sonic-btn').classList.remove('hidden');
                
                // Enable call button and listen for incoming calls
                // Wait a bit before starting to listen to avoid showing old calls
                setTimeout(() => {
                    document.getElementById('ghost-call-btn').classList.remove('hidden');
                    listenForIncomingCalls();
                }, 2000);
                
                // Initialize emoji picker
                initializeEmojiPicker();

                // Clear messages
                document.getElementById('ghost-messages').innerHTML = '';

                // Listen for new messages
                const messagesRef = window.firebaseCollection(window.firebaseDB, `rooms/${roomId}/messages`);
                const q = window.firebaseQuery(messagesRef, window.firebaseOrderBy('timestamp', 'asc'));

                ghostUnsubscribe = window.firebaseOnSnapshot(q, async (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added') {
                            const msgData = change.doc.data();
                            await displayGhostMessage(msgData, change.doc.id);
                        } else if (change.type === 'modified') {
                            // Handle message updates (for deleted messages)
                            const msgData = change.doc.data();
                            if (msgData.deleted) {
                                updateMessageDisplay(change.doc.id, true);
                            }
                        }
                    });
                });

                // Show success
                addSystemMessage(`Joined room "${roomId}" as "${handle}"`);

            } catch (error) {
                console.error('Join error:', error);
                alert("Error joining room: " + error.message);
            }
        }

        // Get user initials for avatar
        function getUserInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        // Get color for user
        function getUserColor(name) {
            if (!name) return 'emerald';
            const colors = ['emerald', 'blue', 'purple', 'rose', 'cyan', 'amber', 'indigo'];
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Display encrypted message
        async function displayGhostMessage(msgData, messageId) {
            try {
                // Check if message is deleted
                if (msgData.deleted) {
                    const messagesDiv = document.getElementById('ghost-messages');
                    const existingMsg = document.getElementById(`msg-${messageId}`);
                    if (existingMsg) {
                        existingMsg.innerHTML = `
                            <div class="flex items-center gap-2 text-zinc-600 italic text-sm py-2">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                                <span>This message was deleted</span>
                            </div>
                        `;
                        lucide.createIcons();
                    }
                    return;
                }

                const decrypted = await decryptMessage(msgData.data, msgData.iv, ghostCryptoKey);
                const messagesDiv = document.getElementById('ghost-messages');
                
                // Remove "join a room" placeholder if exists
                const placeholder = messagesDiv.querySelector('.text-center');
                if (placeholder) placeholder.remove();

                const isOwnMessage = msgData.sender === ghostHandle;
                const senderName = msgData.sender || 'Unknown';
                const timestamp = msgData.timestamp?.toDate() || new Date();
                const timeStr = timestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                const dateStr = timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const isToday = new Date().toDateString() === timestamp.toDateString();
                const isGif = msgData.isGif || false;
                const isAudio = msgData.isAudio || false;
                const mediaType = msgData.mediaType || 'gif';
                
                const userColor = getUserColor(senderName);
                const colorClasses = {
                    emerald: 'bg-emerald-600/20 text-emerald-400 border-emerald-600/30',
                    blue: 'bg-blue-600/20 text-blue-400 border-blue-600/30',
                    purple: 'bg-purple-600/20 text-purple-400 border-purple-600/30',
                    rose: 'bg-rose-600/20 text-rose-400 border-rose-600/30',
                    cyan: 'bg-cyan-600/20 text-cyan-400 border-cyan-600/30',
                    amber: 'bg-amber-600/20 text-amber-400 border-amber-600/30',
                    indigo: 'bg-indigo-600/20 text-indigo-400 border-indigo-600/30'
                };

                const msgDiv = document.createElement('div');
                msgDiv.id = `msg-${messageId}`;
                msgDiv.className = `message-bubble flex gap-2 ${isOwnMessage ? 'flex-row-reverse' : 'flex-row'} max-w-[85%] group`;
                
                let messageContent = '';
                if (isGif) {
                    if (mediaType === 'video') {
                        messageContent = `<video src="${decrypted}" alt="Video" class="max-w-full rounded-lg" style="max-height: 300px; object-fit: contain;" controls autoplay loop muted playsinline></video>`;
                    } else {
                        messageContent = `<img src="${decrypted}" alt="GIF" class="max-w-full rounded-lg" style="max-height: 300px; object-fit: contain;">`;
                    }
                } else if (isAudio && mediaType === 'audio') {
                    messageContent = `<audio src="${decrypted}" controls class="w-full max-w-sm" style="outline: none;" preload="auto">
                        <p class="text-xs text-zinc-500">Your browser does not support audio playback.</p>
                    </audio>`;
                } else {
                    messageContent = `<p class="text-sm break-words whitespace-pre-wrap" style="unicode-bidi: plaintext;">${decrypted}</p>`;
                }
                
                if (!isOwnMessage) {
                    // Avatar for other users
                    msgDiv.innerHTML = `
                        <div class="flex-shrink-0 w-8 h-8 rounded-full ${colorClasses[userColor]} border flex items-center justify-center text-xs font-bold">
                            ${getUserInitials(senderName)}
                        </div>
                        <div class="flex flex-col gap-1 flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <span class="text-xs font-semibold text-zinc-400">${senderName}</span>
                                <span class="text-[10px] text-zinc-600">${isToday ? timeStr : dateStr + ' ' + timeStr}</span>
                            </div>
                            <div class="message-other rounded-2xl px-4 py-2.5 shadow-lg">
                                ${messageContent}
                            </div>
                        </div>
                    `;
                } else {
                    // Own message (no avatar, right-aligned)
                    const deleteBtn = ghostRoomSettings.enableDelete ? 
                        `<button onclick="deleteGhostMessage('${messageId}')" class="opacity-0 group-hover:opacity-100 transition-opacity text-zinc-500 hover:text-rose-500 p-1">
                            <i data-lucide="trash-2" class="w-3 h-3"></i>
                        </button>` : '';
                    
                    msgDiv.innerHTML = `
                        <div class="flex flex-col gap-1 flex-1 min-w-0 items-end">
                            <div class="message-own rounded-2xl px-4 py-2.5 shadow-lg max-w-full relative">
                                ${messageContent}
                            </div>
                            <div class="flex items-center gap-1.5">
                                ${deleteBtn}
                                <span class="text-[10px] text-zinc-600">${isToday ? timeStr : dateStr + ' ' + timeStr}</span>
                                <i data-lucide="check-check" class="w-3 h-3 text-emerald-500"></i>
                            </div>
                        </div>
                    `;
                }
                
                messagesDiv.appendChild(msgDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                lucide.createIcons();
            } catch (error) {
                console.error('Decryption error:', error);
                addSystemMessage(`Failed to decrypt message from ${msgData.sender || 'Unknown'}`);
            }
        }

        // Update message display (for deleted messages)
        function updateMessageDisplay(messageId, isDeleted) {
            const msgDiv = document.getElementById(`msg-${messageId}`);
            if (msgDiv && isDeleted) {
                msgDiv.innerHTML = `
                    <div class="flex items-center gap-2 text-zinc-600 italic text-sm py-2">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                        <span>This message was deleted</span>
                    </div>
                `;
                lucide.createIcons();
            }
        }

        // Send encrypted message
        async function sendGhostMessage(messageText = null, isGif = false, mediaType = 'gif') {
            const messageInput = document.getElementById('ghost-message-input');
            const message = messageText || messageInput.value.trim();

            if (!message || !ghostCryptoKey) {
                console.warn('Cannot send: no message or crypto key');
                return;
            }

            if (!ghostRoomId) {
                alert("Not connected to a room. Please join or create a room first.");
                return;
            }

            try {
                // Disable input while sending
                const sendBtn = document.getElementById('ghost-send-btn');
                sendBtn.disabled = true;
                sendBtn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i>';
                lucide.createIcons();

                const encrypted = await encryptMessage(message, ghostCryptoKey);

                const messageData = {
                        sender: ghostHandle,
                        timestamp: window.firebaseServerTimestamp(),
                        iv: encrypted.iv,
                        data: encrypted.data
                };

                if (isGif) {
                    messageData.isGif = true;
                    messageData.mediaType = mediaType; // 'gif' or 'video'
                } else if (mediaType === 'audio') {
                    messageData.isAudio = true;
                    messageData.mediaType = 'audio';
                    }

                await window.firebaseAddDoc(
                    window.firebaseCollection(window.firebaseDB, `rooms/${ghostRoomId}/messages`),
                    messageData
                );

                if (!messageText) {
                messageInput.value = '';
                    messageInput.style.height = 'auto';
                }
                const charCount = document.getElementById('ghost-char-count');
                if (charCount) {
                    const currentLength = messageText ? messageText.length : 0;
                    charCount.textContent = currentLength;
                }
                
                // Re-enable send button
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i data-lucide="send" class="w-4 h-4"></i>';
                lucide.createIcons();
            } catch (error) {
                console.error('Send error:', error);
                alert("Error sending message: " + error.message);
                
                // Re-enable send button on error
                const sendBtn = document.getElementById('ghost-send-btn');
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i data-lucide="send" class="w-4 h-4"></i>';
                lucide.createIcons();
            }
        }

        // Delete message (for everyone)
        async function deleteGhostMessage(messageId) {
            if (!ghostRoomSettings.enableDelete) {
                alert("Delete messages feature is not enabled in this room.");
                return;
            }

            if (!confirm("Delete this message for everyone?")) {
                return;
            }

            try {
                const messageDocRef = window.firebaseDoc(window.firebaseDB, 'rooms', ghostRoomId, 'messages', messageId);
                await window.firebaseUpdateDoc(messageDocRef, { 
                    deleted: true,
                    deletedBy: ghostHandle,
                    deletedAt: window.firebaseServerTimestamp()
                });
                
                // Update display immediately
                updateMessageDisplay(messageId, true);
            } catch (error) {
                console.error('Delete error:', error);
                alert("Error deleting message: " + error.message);
            }
        }

        // Download chat history
        async function downloadChatHistory() {
            if (!ghostRoomSettings.enableDownload) {
                alert("Download chat history feature is not enabled in this room.");
                return;
            }

            try {
                const messagesRef = window.firebaseCollection(window.firebaseDB, `rooms/${ghostRoomId}/messages`);
                const q = window.firebaseQuery(messagesRef, window.firebaseOrderBy('timestamp', 'asc'));
                
                const messagesSnapshot = await window.firebaseGetDocs(q);

                let chatHistory = `Ghost Comms Chat History - Room: ${ghostRoomId}\n`;
                chatHistory += `Exported on: ${new Date().toLocaleString()}\n`;
                chatHistory += `==========================================\n\n`;

                for (const doc of messagesSnapshot.docs) {
                    const msgData = doc.data();
                    if (msgData.deleted) {
                        chatHistory += `[DELETED] ${msgData.sender || 'Unknown'}: This message was deleted\n`;
                        continue;
                    }

                    try {
                        const decrypted = await decryptMessage(msgData.data, msgData.iv, ghostCryptoKey);
                        const timestamp = msgData.timestamp?.toDate() || new Date();
                        const timeStr = timestamp.toLocaleString();
                        chatHistory += `[${timeStr}] ${msgData.sender || 'Unknown'}: ${decrypted}\n`;
                    } catch (e) {
                        chatHistory += `[ERROR] ${msgData.sender || 'Unknown'}: Failed to decrypt message\n`;
                    }
                }

                // Download as file
                const blob = new Blob([chatHistory], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `ghost-comms-${ghostRoomId}-${Date.now()}.txt`;
                link.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert("Error downloading chat history: " + error.message);
            }
        }

        // Emoji picker functions
        const commonEmojis = ['ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð¤£', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð¥°', 'ð', 'ð¤©', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð', 'ð¤ª', 'ð', 'ð¤', 'ð¤', 'ð¤­', 'ð¤«', 'ð¤', 'ð¤', 'ð¤¨', 'ð', 'ð', 'ð¶', 'ð', 'ð', 'ð', 'ð¬', 'ð¤¥', 'ð', 'ð', 'ðª', 'ð¤¤', 'ð´', 'ð·', 'ð¤', 'ð¤', 'ð¤¢', 'ð¤®', 'ð¤§', 'ð¥µ', 'ð¥¶', 'ð¶âð«ï¸', 'ðµ', 'ð¤¯', 'ð¤ ', 'ð¥³', 'ð', 'ð¤', 'ð§', 'ð', 'ð', 'ð', 'â¹ï¸', 'ð®', 'ð¯', 'ð²', 'ð³', 'ð¥º', 'ð¦', 'ð§', 'ð¨', 'ð°', 'ð¥', 'ð¢', 'ð­', 'ð±', 'ð', 'ð£', 'ð', 'ð', 'ð©', 'ð«', 'ð¥±', 'ð¤', 'ð¡', 'ð ', 'ð¤¬', 'ð', 'ð¿', 'ð', 'â ï¸', 'ð©', 'ð¤¡', 'ð¹', 'ðº', 'ð»', 'ð½', 'ð¾', 'ð¤', 'ðº', 'ð¸', 'ð¹', 'ð»', 'ð¼', 'ð½', 'ð', 'ð¿', 'ð¾'];

        function initializeEmojiPicker() {
            const emojiGrid = document.getElementById('ghost-emoji-grid');
            if (!emojiGrid) return;
            
            emojiGrid.innerHTML = '';
            commonEmojis.forEach(emoji => {
                const emojiBtn = document.createElement('button');
                emojiBtn.className = 'w-8 h-8 text-xl hover:bg-zinc-800 rounded transition-colors flex items-center justify-center';
                emojiBtn.textContent = emoji;
                emojiBtn.onclick = () => insertEmoji(emoji);
                emojiGrid.appendChild(emojiBtn);
            });
        }

        function toggleEmojiPicker() {
            const picker = document.getElementById('ghost-emoji-picker');
            const gifPicker = document.getElementById('ghost-gif-picker');
            if (gifPicker) gifPicker.classList.add('hidden');
            if (picker) picker.classList.toggle('hidden');
        }

        function insertEmoji(emoji) {
            const messageInput = document.getElementById('ghost-message-input');
            const cursorPos = messageInput.selectionStart;
            const textBefore = messageInput.value.substring(0, cursorPos);
            const textAfter = messageInput.value.substring(cursorPos);
            messageInput.value = textBefore + emoji + textAfter;
            messageInput.selectionStart = messageInput.selectionEnd = cursorPos + emoji.length;
            messageInput.focus();
            
            // Update character count
            const charCount = document.getElementById('ghost-char-count');
            if (charCount) charCount.textContent = messageInput.value.length;
            
            // Close picker
            document.getElementById('ghost-emoji-picker').classList.add('hidden');
        }

        // GIF picker functions
        let gifSearchTimeout = null;
        let currentGifCategory = 'trending';
        const GIPHY_API_KEY = 'dc6zaTOxFJmzC'; // Public API key for GIPHY

        // Load GIFs by category
        async function loadGifCategory(category) {
            if (!ghostRoomSettings.enableGifs) return;
            
            currentGifCategory = category;
            
            // Update tab styles
            document.querySelectorAll('[id^="gif-tab-"]').forEach(btn => {
                btn.className = 'px-3 py-1.5 text-xs font-medium rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 whitespace-nowrap';
            });
            const activeTab = document.getElementById(`gif-tab-${category}`);
            if (activeTab) {
                activeTab.className = 'px-3 py-1.5 text-xs font-medium rounded-lg bg-emerald-600 text-white whitespace-nowrap';
            }
            
            const categoryQueries = {
                'trending': '',
                'reactions': 'reactions',
                'funny': 'funny',
                'love': 'love'
            };
            
            await searchGifs(categoryQueries[category] || '');
        }

        async function searchGifs(query) {
            if (!ghostRoomSettings.enableGifs) return;
            
            const gridDiv = document.getElementById('ghost-gif-grid');
            const loadingDiv = document.getElementById('ghost-gif-loading');
            
            if (!gridDiv) return;
            
            // Show loading
            gridDiv.innerHTML = '';
            loadingDiv.classList.remove('hidden');
            
            try {
                let url;
                if (query && query.trim().length > 0) {
                    url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=30&rating=g`;
                } else {
                    url = `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=30&rating=g`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                loadingDiv.classList.add('hidden');
                
                if (data.data && data.data.length > 0) {
                    gridDiv.innerHTML = '';
                    
                    data.data.forEach(gif => {
                        const gifItem = document.createElement('div');
                        gifItem.className = 'relative group cursor-pointer rounded-lg overflow-hidden bg-zinc-800 hover:ring-2 hover:ring-emerald-500 transition-all aspect-square';
                        gifItem.innerHTML = `
                            <img src="${gif.images.fixed_height_small.url}" 
                                 alt="${gif.title || 'GIF'}" 
                                 class="w-full h-full object-cover"
                                 loading="lazy">
                            <div class="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors flex items-center justify-center">
                                <i data-lucide="play" class="w-6 h-6 text-white opacity-0 group-hover:opacity-100 transition-opacity"></i>
                            </div>
                        `;
                        gifItem.onclick = () => sendGif(gif.images.original.url, gif.images.original.mp4);
                        gridDiv.appendChild(gifItem);
                    });
                    
                    lucide.createIcons();
                } else {
                    gridDiv.innerHTML = '<div class="col-span-2 text-center py-8"><p class="text-zinc-500 text-sm">No GIFs found</p></div>';
                }
            } catch (error) {
                console.error('GIF search error:', error);
                loadingDiv.classList.add('hidden');
                gridDiv.innerHTML = '<div class="col-span-2 text-center py-8"><p class="text-red-500 text-sm">Error loading GIFs</p></div>';
            }
        }

        function toggleGifPicker() {
            if (!ghostRoomSettings.enableGifs) {
                // If GIFs not enabled, allow file upload
                document.getElementById('ghost-gif-upload').click();
                return;
            }
            
            const picker = document.getElementById('ghost-gif-picker');
            const emojiPicker = document.getElementById('ghost-emoji-picker');
            if (emojiPicker) emojiPicker.classList.add('hidden');
            if (picker) {
                const isHidden = picker.classList.contains('hidden');
                picker.classList.toggle('hidden');
                
                if (!isHidden) {
                    // Opening picker - load trending GIFs
                    loadGifCategory('trending');
                }
            }
        }

        function sendGif(gifUrl, videoUrl = null) {
            if (!ghostRoomSettings.enableGifs) {
                alert("GIF feature is not enabled in this room.");
                return;
            }
            
            // Prefer video URL if available, otherwise use GIF
            const mediaUrl = videoUrl || gifUrl;
            sendGhostMessage(mediaUrl, true, videoUrl ? 'video' : 'gif');
            document.getElementById('ghost-gif-picker').classList.add('hidden');
        }

        // Handle GIF file upload
        function handleGifUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!ghostRoomSettings.enableGifs) {
                alert("GIF feature is not enabled in this room.");
                return;
            }
            
            // Check if it's a GIF or video
            const isVideo = file.type.startsWith('video/');
            const isGif = file.type === 'image/gif';
            
            if (!isGif && !isVideo) {
                alert("Please select a GIF or video file.");
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const dataUrl = e.target.result;
                sendGhostMessage(dataUrl, true, isVideo ? 'video' : 'gif');
            };
            reader.readAsDataURL(file);
            
            // Reset input
            event.target.value = '';
        }

        // Audio Recording Functions
        let audioRecorder = null;
        let audioStream = null;
        let isRecording = false;

        async function toggleAudioRecord() {
            if (isRecording) {
                stopAudioRecording();
            } else {
                await startAudioRecording();
            }
        }

        async function startAudioRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                audioStream = stream;
                audioRecorder = new MediaRecorder(stream);
                const chunks = [];
                
                audioRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };
                
                audioRecorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onload = async function(e) {
                        const audioDataUrl = e.target.result;
                        // Send as base64 encoded audio
                        await sendGhostMessage(audioDataUrl, false, 'audio');
                    };
                    reader.readAsDataURL(blob);
                    
                    // Stop all tracks
                    if (audioStream) {
                        audioStream.getTracks().forEach(track => track.stop());
                        audioStream = null;
                    }
                };
                
                audioRecorder.start();
                isRecording = true;
                
                // Update button
                const btn = document.getElementById('ghost-audio-btn');
                if (btn) {
                    btn.innerHTML = '<i data-lucide="mic-off" class="w-5 h-5"></i>';
                    btn.classList.add('bg-red-600', 'animate-pulse');
                    btn.classList.remove('bg-zinc-800');
                    lucide.createIcons();
                }
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Could not access microphone. Please allow permissions.');
            }
        }

        function stopAudioRecording() {
            if (audioRecorder && isRecording) {
                audioRecorder.stop();
                isRecording = false;
                
                // Update button
                const btn = document.getElementById('ghost-audio-btn');
                if (btn) {
                    btn.innerHTML = '<i data-lucide="mic" class="w-5 h-5"></i>';
                    btn.classList.remove('bg-red-600', 'animate-pulse');
                    btn.classList.add('bg-zinc-800');
                    lucide.createIcons();
                }
            }
        }

        // Setup GIF search
        document.addEventListener('DOMContentLoaded', () => {
            const gifSearch = document.getElementById('ghost-gif-search');
            if (gifSearch) {
                gifSearch.addEventListener('input', (e) => {
                    clearTimeout(gifSearchTimeout);
                    const query = e.target.value.trim();
                    
                    if (query.length === 0) {
                        // If search is cleared, reload current category
                        loadGifCategory(currentGifCategory);
                    } else if (query.length >= 2) {
                        gifSearchTimeout = setTimeout(() => {
                            searchGifs(query);
                        }, 500);
                    }
                });
                
                // Allow Enter key to search
                gifSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const query = gifSearch.value.trim();
                        if (query.length > 0) {
                            searchGifs(query);
                        }
                    }
                });
            }
        });

        // Disconnect from room
        function disconnectGhost() {
            if (ghostUnsubscribe) {
                ghostUnsubscribe();
                ghostUnsubscribe = null;
            }

            ghostCryptoKey = null;
            ghostRoomId = null;
            ghostHandle = null;
            ghostRoomPassword = null;
            isRoomCreator = false;

            // Show join panel again
            document.getElementById('ghost-join-panel').classList.remove('hidden');
            document.getElementById('ghost-share-btn').classList.add('hidden');
            document.getElementById('ghost-disconnect-btn').classList.add('hidden');
            
            // Reset chat header
            document.getElementById('ghost-room-display').textContent = 'Not Connected';
            document.getElementById('ghost-room-status').textContent = 'Join or create a room to start';
            document.getElementById('ghost-encryption-indicator').className = 'w-2 h-2 rounded-full bg-zinc-700';
            
            // Disable messaging
            document.getElementById('ghost-message-input').disabled = true;
            document.getElementById('ghost-send-btn').disabled = true;
            
            // Clear messages
            document.getElementById('ghost-messages').innerHTML = `
                <div class="text-center text-zinc-600 text-sm py-12">
                    <div class="w-16 h-16 bg-emerald-600/10 rounded-full flex items-center justify-center mx-auto mb-3 border border-emerald-600/20">
                        <i data-lucide="message-square-lock" class="w-8 h-8 text-emerald-500/50"></i>
                    </div>
                    <p class="font-medium">Join or create a room to start messaging</p>
                    <p class="text-xs text-zinc-700 mt-1">Messages are end-to-end encrypted</p>
                </div>
            `;
            lucide.createIcons();
        }

        // Check for room link on page load
        window.addEventListener('DOMContentLoaded', () => {
            checkRoomLink();
            
            // Display master keys in console (for you to copy)
            console.log('%cð MASTER KEYS (100 Lifetime Keys)', 'color: #10b981; font-size: 16px; font-weight: bold;');
            console.log('%cCopy these keys - they have lifetime validity:', 'color: #a1a1aa; font-size: 12px;');
            MASTER_KEYS.forEach((key, index) => {
                console.log(`${(index + 1).toString().padStart(3, '0')}. ${key}`);
            });
        });

        // Add system message
        function addSystemMessage(text) {
            const messagesDiv = document.getElementById('ghost-messages');
            const placeholder = messagesDiv.querySelector('.text-center');
            if (placeholder) placeholder.remove();

            const msgDiv = document.createElement('div');
            msgDiv.className = 'message-bubble text-center py-3';
            msgDiv.innerHTML = `
                <div class="inline-flex items-center gap-2 bg-zinc-800/50 border border-zinc-700 rounded-full px-4 py-1.5">
                    <i data-lucide="info" class="w-3 h-3 text-zinc-500"></i>
                    <span class="text-xs text-zinc-500 font-medium">${text}</span>
                </div>
            `;
            messagesDiv.appendChild(msgDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            lucide.createIcons();
        }

        // Auto-resize textarea and character counter
        document.addEventListener('DOMContentLoaded', () => {
            const messageInput = document.getElementById('ghost-message-input');
            const charCount = document.getElementById('ghost-char-count');
            const messagesDiv = document.getElementById('ghost-messages');
            
            // Fix scroll in messages area
            if (messagesDiv) {
                messagesDiv.addEventListener('wheel', (e) => {
                    e.stopPropagation();
                }, { passive: true });
                
                // Ensure scroll works
                messagesDiv.style.overflowY = 'auto';
                messagesDiv.style.overflowX = 'hidden';
            }
            
            if (messageInput) {
                // Auto-resize textarea
                messageInput.addEventListener('input', (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = Math.min(e.target.scrollHeight, 120) + 'px';
                    
                    // Update character count (no limit)
                    if (charCount) {
                        const count = e.target.value.length;
                        charCount.textContent = count;
                            charCount.className = 'text-[10px] text-zinc-700';
                    }
                });

                // Enter to send, Shift+Enter for new line
                messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        if (messageInput.value.trim() && !messageInput.disabled) {
                            sendGhostMessage();
                        }
                    }
                });
                
                // Windows Emoji Picker Support (Win + . or Win + ;)
                messageInput.addEventListener('keydown', (e) => {
                    // Note: Windows emoji picker is handled by OS, but we ensure the input accepts it
                    // The OS will insert emojis directly into the input field
                });
            }
        });

        // ============================================
        // THE UPLINK - WebRTC Voice Calling Module with Advanced Echo Cancellation
        // ============================================
        let peerConnection = null;
        let localStream = null;
        let remoteAudioElement = null;
        let callId = null;
        let callUnsubscribe = null;
        let answerUnsubscribe = null;
        let offerCandidatesUnsubscribe = null;
        let answerCandidatesUnsubscribe = null;
        let isCaller = false;
        let callActive = false;

        // Web Audio API components for echo cancellation
        let callAudioContext = null;
        let remoteAudioSource = null;
        let remoteGainNode = null;
        let remoteAnalyser = null;
        let localAudioSource = null;
        let localAnalyser = null;
        let echoCancellationNode = null;
        let compressorNode = null;
        let limiterNode = null;
        let destinationNode = null;

        // Device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isAndroid = /Android/.test(navigator.userAgent);

        // ICE Servers Configuration (Google's free STUN servers)
        const iceServers = {
            iceServers: [
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }
            ],
            iceCandidatePoolSize: 10
        };

        // Enhanced Media Constraints with maximum echo cancellation
        const getMediaConstraints = () => {
            const baseConstraints = {
                video: false,
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    // Additional constraints for better echo cancellation
                    googEchoCancellation: true,
                    googNoiseSuppression: true,
                    googAutoGainControl: true,
                    googHighpassFilter: true,
                    googTypingNoiseDetection: true,
                    googNoiseReduction: true,
                    // Sample rate for better quality
                    sampleRate: 48000,
                    channelCount: 1,
                    // Latency settings
                    latency: 0.01,
                    googAudioMirroring: false
                }
            };

            // Mobile-specific optimizations
            if (isMobile) {
                baseConstraints.audio.sampleRate = 16000; // Lower sample rate for mobile
                baseConstraints.audio.latency = 0.02;
            }

            return baseConstraints;
        };

        // Initialize Web Audio API for echo cancellation
        async function initializeAudioContext() {
            try {
                if (callAudioContext && callAudioContext.state !== 'closed') {
                    return callAudioContext;
                }

                // Create audio context with optimal settings
                callAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: isMobile ? 16000 : 48000,
                    latencyHint: isMobile ? 'interactive' : 'balanced'
                });

                // Resume context if suspended (required for autoplay policies)
                if (callAudioContext.state === 'suspended') {
                    await callAudioContext.resume();
                }

                // Create audio processing nodes
                remoteGainNode = callAudioContext.createGain();
                remoteGainNode.gain.value = 0.7; // Start at 70% volume to prevent feedback

                remoteAnalyser = callAudioContext.createAnalyser();
                remoteAnalyser.fftSize = 2048;
                remoteAnalyser.smoothingTimeConstant = 0.8;

                localAnalyser = callAudioContext.createAnalyser();
                localAnalyser.fftSize = 2048;
                localAnalyser.smoothingTimeConstant = 0.8;

                // Create compressor to normalize audio levels
                compressorNode = callAudioContext.createDynamicsCompressor();
                compressorNode.threshold.value = -24;
                compressorNode.knee.value = 30;
                compressorNode.ratio.value = 12;
                compressorNode.attack.value = 0.003;
                compressorNode.release.value = 0.25;

                // Create limiter to prevent clipping
                limiterNode = callAudioContext.createDynamicsCompressor();
                limiterNode.threshold.value = -3;
                limiterNode.knee.value = 0;
                limiterNode.ratio.value = 20;
                limiterNode.attack.value = 0.001;
                limiterNode.release.value = 0.01;

                // Connect processing chain: source -> gain -> compressor -> limiter -> destination
                remoteGainNode.connect(compressorNode);
                compressorNode.connect(limiterNode);
                limiterNode.connect(remoteAnalyser);
                remoteAnalyser.connect(callAudioContext.destination);

                // Monitor audio levels to prevent feedback
                monitorAudioLevels();

                return callAudioContext;
            } catch (error) {
                console.error('Error initializing audio context:', error);
                return null;
            }
        }

        // Monitor audio levels to prevent feedback loops
        function monitorAudioLevels() {
            if (!remoteAnalyser || !localAnalyser) return;

            const remoteDataArray = new Uint8Array(remoteAnalyser.frequencyBinCount);
            const localDataArray = new Uint8Array(localAnalyser.frequencyBinCount);

            function checkLevels() {
                if (!callActive || !remoteAnalyser || !localAnalyser || !callAudioContext) return;

                remoteAnalyser.getByteFrequencyData(remoteDataArray);
                localAnalyser.getByteFrequencyData(localDataArray);

                // Calculate average levels
                const remoteLevel = remoteDataArray.reduce((a, b) => a + b, 0) / remoteDataArray.length;
                const localLevel = localDataArray.reduce((a, b) => a + b, 0) / localDataArray.length;

                // If local mic is picking up remote audio (echo), reduce remote volume
                if (remoteLevel > 50 && localLevel > 40 && remoteLevel * 0.8 < localLevel) {
                    // Potential feedback detected, reduce remote volume
                    const currentGain = remoteGainNode.gain.value;
                    remoteGainNode.gain.setTargetAtTime(
                        Math.max(0.3, currentGain * 0.9),
                        callAudioContext.currentTime,
                        0.1
                    );
                } else if (remoteLevel < 30) {
                    // Audio is quiet, can increase volume slightly
                    const currentGain = remoteGainNode.gain.value;
                    remoteGainNode.gain.setTargetAtTime(
                        Math.min(0.8, currentGain * 1.05),
                        callAudioContext.currentTime,
                        0.2
                    );
                }

                requestAnimationFrame(checkLevels);
            }

            checkLevels();
        }

        // Setup local audio monitoring
        function setupLocalAudioMonitoring(stream) {
            if (!callAudioContext || !stream) return;

            try {
                localAudioSource = callAudioContext.createMediaStreamSource(stream);
                localAudioSource.connect(localAnalyser);
                // Don't connect to destination to prevent feedback
            } catch (error) {
                console.warn('Could not setup local audio monitoring:', error);
            }
        }

        // Initialize call
        async function initiateCall() {
            if (!ghostRoomId) {
                alert("Please join a room first.");
                return;
            }

            if (callActive) {
                alert("A call is already active.");
                return;
            }

            // Clean up any existing call first
            await cleanupCall();

            try {
                // Check microphone permission first
                await requestMicrophoneAccess();
                
                // Initialize audio context first
                await initializeAudioContext();
                if (!callAudioContext) {
                    throw new Error('Could not initialize audio context');
                }

                // Get user media with enhanced constraints and optimal device
                const constraints = await getEnhancedMediaConstraints();
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Setup local audio monitoring for echo detection
                setupLocalAudioMonitoring(localStream);
                
                isCaller = true;
                
                // Create peer connection
                peerConnection = new RTCPeerConnection(iceServers);
                
                // Handle errors
                peerConnection.onerror = (error) => {
                    console.error('Peer connection error:', error);
                };
                
                // Add local tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Handle ICE candidates
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate && callId) {
                        try {
                            await window.firebaseAddDoc(
                                window.firebaseCollection(window.firebaseDB, `calls/${callId}/offerCandidates`),
                                { 
                                    candidate: event.candidate.candidate, 
                                    sdpMLineIndex: event.candidate.sdpMLineIndex, 
                                    sdpMid: event.candidate.sdpMid 
                                }
                            );
                        } catch (e) {
                            console.error('Error adding ICE candidate:', e);
                        }
                    }
                };
                
                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', peerConnection.connectionState);
                    // Only cleanup on actual failures, not on 'disconnected' which is normal during connection
                    if (peerConnection.connectionState === 'failed') {
                        // Give it more time before cleanup - connection might recover
                        setTimeout(() => {
                            if (peerConnection && peerConnection.connectionState === 'failed' && callActive) {
                                console.warn('Connection failed after timeout, cleaning up');
                                cleanupCall();
                            }
                        }, 10000); // Increased timeout to 10 seconds to allow reconnection
                    } else if (peerConnection.connectionState === 'closed') {
                        // Only cleanup if we're still in a call (not already cleaned up)
                        if (callActive) {
                            console.warn('Connection closed unexpectedly');
                            cleanupCall();
                        }
                    } else if (peerConnection.connectionState === 'connected') {
                        console.log('Connection established successfully');
                    } else if (peerConnection.connectionState === 'disconnected') {
                        // 'disconnected' is normal during connection establishment - don't cleanup
                        console.log('Connection disconnected (may reconnect)');
                    }
                };
                
                // Handle ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', peerConnection.iceConnectionState);
                    // Only cleanup on actual failures - 'disconnected' can be temporary during connection
                    if (peerConnection.iceConnectionState === 'failed') {
                        setTimeout(() => {
                            if (peerConnection && peerConnection.iceConnectionState === 'failed' && callActive) {
                                console.warn('ICE connection failed after timeout, cleaning up');
                                cleanupCall();
                            }
                        }, 10000); // Increased timeout to 10 seconds
                    } else if (peerConnection.iceConnectionState === 'connected' || 
                               peerConnection.iceConnectionState === 'completed') {
                        console.log('ICE connection established successfully');
                    } else if (peerConnection.iceConnectionState === 'disconnected') {
                        // 'disconnected' is normal during connection - don't cleanup
                        console.log('ICE disconnected (may reconnect)');
                    }
                };
                
                // Handle remote stream with Web Audio API for echo cancellation
                peerConnection.ontrack = async (event) => {
                    console.log('Received remote track', event);
                    console.log('Track kind:', event.track.kind);
                    console.log('Track enabled:', event.track.enabled);
                    console.log('Track readyState:', event.track.readyState);
                    
                    if (event.streams && event.streams[0]) {
                        const remoteStream = event.streams[0];
                        const audioTracks = remoteStream.getAudioTracks();
                        console.log('Remote stream audio tracks:', audioTracks.length);
                        
                        if (audioTracks.length === 0) {
                            console.error('No audio tracks in remote stream!');
                            return;
                        }
                        
                        audioTracks.forEach((track, index) => {
                            console.log(`Audio track ${index}:`, {
                                enabled: track.enabled,
                                readyState: track.readyState,
                                muted: track.muted,
                                label: track.label
                            });
                        });
                        try {
                            // Ensure audio context is initialized and nodes exist
                            if (!callAudioContext || callAudioContext.state === 'closed') {
                                await initializeAudioContext();
                            }

                            if (!callAudioContext) {
                                throw new Error('Audio context not initialized');
                            }

                            if (callAudioContext.state === 'suspended') {
                                await callAudioContext.resume();
                            }

                            // PRIMARY METHOD: Use HTML5 Audio element (most reliable)
                            // Create or reuse audio element
                            if (!remoteAudioElement) {
                                remoteAudioElement = new Audio();
                                remoteAudioElement.autoplay = true;
                                remoteAudioElement.volume = 1.0; // Full volume
                                remoteAudioElement.setAttribute('playsinline', 'true'); // iOS compatibility
                                remoteAudioElement.muted = false;
                                
                                // Add event listeners for debugging
                                remoteAudioElement.addEventListener('play', () => {
                                    console.log('Remote audio element started playing');
                                });
                                remoteAudioElement.addEventListener('pause', () => {
                                    console.log('Remote audio element paused');
                                });
                                remoteAudioElement.addEventListener('error', (e) => {
                                    console.error('Remote audio element error:', e);
                                });
                                remoteAudioElement.addEventListener('loadedmetadata', () => {
                                    console.log('Remote audio metadata loaded');
                                });
                            }
                            
                            // Set remote stream to audio element
                            remoteAudioElement.srcObject = event.streams[0];
                            remoteAudioElement.volume = 1.0; // Ensure volume is set
                            remoteAudioElement.muted = false; // Ensure not muted
                            
                            // Enable all audio tracks
                            audioTracks.forEach(track => {
                                track.enabled = true;
                                console.log('Enabled audio track:', track.label);
                            });
                            
                            // Play the audio element
                            try {
                                await remoteAudioElement.play();
                                console.log('Remote audio element playing successfully');
                                console.log('Audio element volume:', remoteAudioElement.volume);
                                console.log('Audio element muted:', remoteAudioElement.muted);
                                console.log('Audio element paused:', remoteAudioElement.paused);
                            } catch (playError) {
                                console.error('Failed to play remote audio element:', playError);
                                // Try user interaction workaround
                                if (playError.name === 'NotAllowedError') {
                                    console.warn('Autoplay blocked, user interaction required');
                                }
                            }
                            
                            // SECONDARY METHOD: Also try Web Audio API for echo cancellation
                            try {
                                // Ensure audio nodes are created
                                if (!remoteGainNode || !compressorNode || !limiterNode) {
                                    console.log('Initializing Web Audio API nodes for echo cancellation...');
                                    await initializeAudioContext();
                                }

                                // Create media stream source from remote stream
                                if (remoteAudioSource) {
                                    try {
                                        remoteAudioSource.disconnect();
                                    } catch (e) {
                                        // Ignore disconnect errors
                                    }
                                }

                                remoteAudioSource = callAudioContext.createMediaStreamSource(event.streams[0]);
                                
                                // Connect through processing chain: source -> gain -> compressor -> limiter -> destination
                                if (remoteGainNode) {
                                    remoteAudioSource.connect(remoteGainNode);
                                    console.log('Web Audio API echo cancellation active');
                                    console.log('Web Audio API gain:', remoteGainNode.gain.value);
                                }
                            } catch (webAudioError) {
                                console.warn('Web Audio API setup failed, using audio element only:', webAudioError);
                                // Audio element will still work
                            }

                            console.log('Remote audio connected - Primary: Audio Element, Secondary: Web Audio API');
                        } catch (e) {
                            console.error('Error handling remote track:', e);
                            // Fallback to basic audio element only
                            try {
                                if (!remoteAudioElement) {
                                    remoteAudioElement = new Audio();
                                    remoteAudioElement.autoplay = true;
                                    remoteAudioElement.volume = 1.0;
                                    remoteAudioElement.setAttribute('playsinline', 'true');
                                    remoteAudioElement.muted = false;
                                }
                                remoteAudioElement.srcObject = event.streams[0];
                                remoteAudioElement.volume = 1.0;
                                remoteAudioElement.muted = false;
                                
                                // Enable all audio tracks
                                const stream = event.streams[0];
                                stream.getAudioTracks().forEach(track => {
                                    track.enabled = true;
                                });
                                
                                await remoteAudioElement.play();
                                console.log('Using fallback audio element only - playing');
                            } catch (err) {
                                console.error('Error with fallback audio element:', err);
                                // Try to show user-friendly error
                                if (err.name === 'NotAllowedError') {
                                    console.warn('Autoplay blocked - user interaction may be required');
                                }
                            }
                        }
                    }
                };
                
                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                // Save offer to Firestore - create new document
                const callDocRef = await window.firebaseAddDoc(
                    window.firebaseCollection(window.firebaseDB, 'calls'),
                    {
                        offer: {
                            type: offer.type,
                            sdp: offer.sdp
                        },
                        roomId: ghostRoomId,
                        caller: ghostHandle,
                        timestamp: window.firebaseServerTimestamp(),
                        status: 'calling'
                    }
                );
                callId = callDocRef.id; // Use actual document ID
                
                // Mark call as active
                callActive = true;
                
                // Listen for answer and call state changes
                listenForAnswer();
                
                // Show active call interface
                showActiveCall();
                
                console.log('Call initiated, waiting for answer');
                
            } catch (error) {
                console.error('Call initiation error:', error);
                let errorMessage = 'Could not start call. ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Please allow microphone permissions in your browser settings.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'No microphone found. Please connect a microphone.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Microphone is being used by another application.';
                } else if (error.message && error.message.includes('microphone')) {
                    errorMessage += 'Microphone access error: ' + error.message;
                } else {
                    errorMessage += 'Error: ' + (error.message || error.toString());
                }
                alert(errorMessage);
                await cleanupCall();
            }
        }

        // Track processed call IDs to prevent duplicate notifications
        const processedCallIds = new Set();
        let lastCallCheckTime = 0;

        // Listen for incoming calls
        function listenForIncomingCalls() {
            if (!ghostRoomId || !window.firebaseDB) return;
            
            // Unsubscribe from existing listener if any
            if (callUnsubscribe) {
                callUnsubscribe();
                callUnsubscribe = null;
            }
            
            // Clear processed calls older than 30 seconds
            const now = Date.now();
            if (now - lastCallCheckTime > 30000) {
                processedCallIds.clear();
                lastCallCheckTime = now;
            }
            
            console.log('Setting up incoming call listener for room:', ghostRoomId);
            
            const callsRef = window.firebaseCollection(window.firebaseDB, 'calls');
            const q = window.firebaseQuery(callsRef, window.firebaseOrderBy('timestamp', 'desc'));
            
            callUnsubscribe = window.firebaseOnSnapshot(q, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    // Only process new calls that haven't been seen
                    if (change.type === 'added' && !isCaller && !callActive) {
                        const callData = change.doc.data();
                        const callDocId = change.doc.id;
                        
                        // Skip if already processed
                        if (processedCallIds.has(callDocId)) {
                            return;
                        }
                        
                        // Only show calls that are:
                        // 1. For this room
                        // 2. Not from this user
                        // 3. Status is 'calling' (actively calling, not ended or active)
                        // 4. Created in the last 30 seconds (prevent old calls from showing)
                        const callTimestamp = callData.timestamp?.toMillis ? callData.timestamp.toMillis() : 
                                             (callData.timestamp?.seconds ? callData.timestamp.seconds * 1000 : Date.now());
                        const callAge = Date.now() - callTimestamp;
                        
                        if (callData.roomId === ghostRoomId && 
                            callData.caller !== ghostHandle && 
                            callData.status === 'calling' &&
                            !callData.ended &&
                            callAge < 30000) { // Only show calls less than 30 seconds old
                            
                            processedCallIds.add(callDocId);
                            callId = callDocId;
                            
                            const callerNameEl = document.getElementById('caller-name-display');
                            if (callerNameEl) {
                                callerNameEl.textContent = callData.caller || 'Unknown';
                            }
                            const incomingModal = document.getElementById('incoming-call-modal');
                            if (incomingModal) {
                                incomingModal.classList.remove('hidden');
                            }
                        }
                    }
                    
                    // Handle call updates (ended calls, status changes)
                    if (change.type === 'modified') {
                        const callData = change.doc.data();
                        const callDocId = change.doc.id;
                        
                        // Only process if this is the current call
                        if (callDocId === callId) {
                            if (callData.status === 'ended' || callData.ended) {
                                // If we're in a call that just ended, cleanup
                                if (callActive) {
                                    cleanupCall();
                                }
                            } else if (callData.status === 'active' && !callActive && !isCaller) {
                                // Call was accepted by us, don't do anything - acceptCall is handling it
                                console.log('Call status changed to active (we accepted it)');
                            }
                        }
                    }
                });
            });
        }

        // Accept incoming call
        async function acceptCall() {
            if (!callId || !window.firebaseDB) return;
            
            if (callActive) {
                alert("A call is already active.");
                return;
            }
            
            // Hide incoming modal immediately
            const incomingModal = document.getElementById('incoming-call-modal');
            if (incomingModal) {
                incomingModal.classList.add('hidden');
            }
            
            // Don't cleanup here - we need to preserve the callId and existing listeners
            // Only cleanup if there's actually a conflicting call
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                console.warn('Existing peer connection found, cleaning up first');
                await cleanupCall();
            }
            
            try {
                // Check microphone permission first
                await requestMicrophoneAccess();
                
                // Initialize audio context first
                await initializeAudioContext();
                if (!callAudioContext) {
                    throw new Error('Could not initialize audio context');
                }

                // Get user media with enhanced constraints and optimal device
                const constraints = await getEnhancedMediaConstraints();
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Setup local audio monitoring for echo detection
                setupLocalAudioMonitoring(localStream);
                
                // Create peer connection
                peerConnection = new RTCPeerConnection(iceServers);
                
                // Handle errors
                peerConnection.onerror = (error) => {
                    console.error('Peer connection error:', error);
                };
                
                // Add local tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Handle ICE candidates
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate && callId) {
                        try {
                            await window.firebaseAddDoc(
                                window.firebaseCollection(window.firebaseDB, `calls/${callId}/answerCandidates`),
                                { 
                                    candidate: event.candidate.candidate, 
                                    sdpMLineIndex: event.candidate.sdpMLineIndex, 
                                    sdpMid: event.candidate.sdpMid 
                                }
                            );
                        } catch (e) {
                            console.error('Error adding ICE candidate:', e);
                        }
                    }
                };
                
                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', peerConnection.connectionState);
                    // Only cleanup on actual failures, not on 'disconnected' which is normal during connection
                    if (peerConnection.connectionState === 'failed') {
                        // Give it more time before cleanup - connection might recover
                        setTimeout(() => {
                            if (peerConnection && peerConnection.connectionState === 'failed' && callActive) {
                                console.warn('Connection failed after timeout, cleaning up');
                                cleanupCall();
                            }
                        }, 10000); // Increased timeout to 10 seconds to allow reconnection
                    } else if (peerConnection.connectionState === 'closed') {
                        // Only cleanup if we're still in a call (not already cleaned up)
                        if (callActive) {
                            console.warn('Connection closed unexpectedly');
                            cleanupCall();
                        }
                    } else if (peerConnection.connectionState === 'connected') {
                        console.log('Connection established successfully');
                    } else if (peerConnection.connectionState === 'disconnected') {
                        // 'disconnected' is normal during connection establishment - don't cleanup
                        console.log('Connection disconnected (may reconnect)');
                    }
                };
                
                // Handle ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', peerConnection.iceConnectionState);
                    // Only cleanup on actual failures - 'disconnected' can be temporary during connection
                    if (peerConnection.iceConnectionState === 'failed') {
                        setTimeout(() => {
                            if (peerConnection && peerConnection.iceConnectionState === 'failed' && callActive) {
                                console.warn('ICE connection failed after timeout, cleaning up');
                                cleanupCall();
                            }
                        }, 10000); // Increased timeout to 10 seconds
                    } else if (peerConnection.iceConnectionState === 'connected' || 
                               peerConnection.iceConnectionState === 'completed') {
                        console.log('ICE connection established successfully');
                    } else if (peerConnection.iceConnectionState === 'disconnected') {
                        // 'disconnected' is normal during connection - don't cleanup
                        console.log('ICE disconnected (may reconnect)');
                    }
                };
                
                // Handle remote stream with Web Audio API for echo cancellation
                peerConnection.ontrack = async (event) => {
                    console.log('Received remote track', event);
                    console.log('Track kind:', event.track.kind);
                    console.log('Track enabled:', event.track.enabled);
                    console.log('Track readyState:', event.track.readyState);
                    
                    if (event.streams && event.streams[0]) {
                        const remoteStream = event.streams[0];
                        const audioTracks = remoteStream.getAudioTracks();
                        console.log('Remote stream audio tracks:', audioTracks.length);
                        
                        if (audioTracks.length === 0) {
                            console.error('No audio tracks in remote stream!');
                            return;
                        }
                        
                        audioTracks.forEach((track, index) => {
                            console.log(`Audio track ${index}:`, {
                                enabled: track.enabled,
                                readyState: track.readyState,
                                muted: track.muted,
                                label: track.label
                            });
                        });
                        try {
                            // Ensure audio context is initialized and nodes exist
                            if (!callAudioContext || callAudioContext.state === 'closed') {
                                await initializeAudioContext();
                            }

                            if (!callAudioContext) {
                                throw new Error('Audio context not initialized');
                            }

                            if (callAudioContext.state === 'suspended') {
                                await callAudioContext.resume();
                            }

                            // PRIMARY METHOD: Use HTML5 Audio element (most reliable)
                            // Create or reuse audio element
                            if (!remoteAudioElement) {
                                remoteAudioElement = new Audio();
                                remoteAudioElement.autoplay = true;
                                remoteAudioElement.volume = 1.0; // Full volume
                                remoteAudioElement.setAttribute('playsinline', 'true'); // iOS compatibility
                                remoteAudioElement.muted = false;
                                
                                // Add event listeners for debugging
                                remoteAudioElement.addEventListener('play', () => {
                                    console.log('Remote audio element started playing');
                                });
                                remoteAudioElement.addEventListener('pause', () => {
                                    console.log('Remote audio element paused');
                                });
                                remoteAudioElement.addEventListener('error', (e) => {
                                    console.error('Remote audio element error:', e);
                                });
                                remoteAudioElement.addEventListener('loadedmetadata', () => {
                                    console.log('Remote audio metadata loaded');
                                });
                            }
                            
                            // Set remote stream to audio element
                            remoteAudioElement.srcObject = event.streams[0];
                            remoteAudioElement.volume = 1.0; // Ensure volume is set
                            remoteAudioElement.muted = false; // Ensure not muted
                            
                            // Enable all audio tracks
                            audioTracks.forEach(track => {
                                track.enabled = true;
                                console.log('Enabled audio track:', track.label);
                            });
                            
                            // Play the audio element
                            try {
                                await remoteAudioElement.play();
                                console.log('Remote audio element playing successfully');
                                console.log('Audio element volume:', remoteAudioElement.volume);
                                console.log('Audio element muted:', remoteAudioElement.muted);
                                console.log('Audio element paused:', remoteAudioElement.paused);
                            } catch (playError) {
                                console.error('Failed to play remote audio element:', playError);
                                // Try user interaction workaround
                                if (playError.name === 'NotAllowedError') {
                                    console.warn('Autoplay blocked, user interaction required');
                                }
                            }
                            
                            // SECONDARY METHOD: Also try Web Audio API for echo cancellation
                            try {
                                // Ensure audio nodes are created
                                if (!remoteGainNode || !compressorNode || !limiterNode) {
                                    console.log('Initializing Web Audio API nodes for echo cancellation...');
                                    await initializeAudioContext();
                                }

                                // Create media stream source from remote stream
                                if (remoteAudioSource) {
                                    try {
                                        remoteAudioSource.disconnect();
                                    } catch (e) {
                                        // Ignore disconnect errors
                                    }
                                }

                                remoteAudioSource = callAudioContext.createMediaStreamSource(event.streams[0]);
                                
                                // Connect through processing chain: source -> gain -> compressor -> limiter -> destination
                                if (remoteGainNode) {
                                    remoteAudioSource.connect(remoteGainNode);
                                    console.log('Web Audio API echo cancellation active');
                                    console.log('Web Audio API gain:', remoteGainNode.gain.value);
                                }
                            } catch (webAudioError) {
                                console.warn('Web Audio API setup failed, using audio element only:', webAudioError);
                                // Audio element will still work
                            }

                            console.log('Remote audio connected - Primary: Audio Element, Secondary: Web Audio API');
                        } catch (e) {
                            console.error('Error handling remote track:', e);
                            // Fallback to basic audio element only
                            try {
                                if (!remoteAudioElement) {
                                    remoteAudioElement = new Audio();
                                    remoteAudioElement.autoplay = true;
                                    remoteAudioElement.volume = 1.0;
                                    remoteAudioElement.setAttribute('playsinline', 'true');
                                    remoteAudioElement.muted = false;
                                }
                                remoteAudioElement.srcObject = event.streams[0];
                                remoteAudioElement.volume = 1.0;
                                remoteAudioElement.muted = false;
                                
                                // Enable all audio tracks
                                const stream = event.streams[0];
                                stream.getAudioTracks().forEach(track => {
                                    track.enabled = true;
                                });
                                
                                await remoteAudioElement.play();
                                console.log('Using fallback audio element only - playing');
                            } catch (err) {
                                console.error('Error with fallback audio element:', err);
                                // Try to show user-friendly error
                                if (err.name === 'NotAllowedError') {
                                    console.warn('Autoplay blocked - user interaction may be required');
                                }
                            }
                        }
                    }
                };
                
                // Get offer from Firestore
                const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                const callDocSnap = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Timeout waiting for call document')), 10000);
                    const unsubscribe = window.firebaseOnSnapshot(callDocRef, (doc) => {
                        if (doc.exists()) {
                            const data = doc.data();
                            // Check if call was already ended
                            if (data.status === 'ended' || data.ended) {
                                clearTimeout(timeout);
                                unsubscribe();
                                reject(new Error('Call was already ended'));
                                return;
                            }
                            clearTimeout(timeout);
                            unsubscribe();
                            resolve(doc);
                        }
                    });
                });
                
                const offerData = callDocSnap.data();
                if (!offerData || !offerData.offer) {
                    throw new Error('Offer not found');
                }
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData.offer));
                
                // Create answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                // Save answer to Firestore
                await window.firebaseUpdateDoc(callDocRef, {
                    answer: {
                        type: answer.type,
                        sdp: answer.sdp
                    },
                    status: 'active'
                });
                
                // Mark call as active BEFORE listening for candidates to prevent race conditions
                callActive = true;
                
                // Listen for ICE candidates from caller
                listenForOfferCandidates();
                
                // Show active call (modal already hidden above)
                showActiveCall();
                
                console.log('Call accepted and connection established');
                
            } catch (error) {
                console.error('Accept call error:', error);
                let errorMessage = 'Could not accept call. ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Please allow microphone permissions in your browser settings.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'No microphone found. Please connect a microphone.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Microphone is being used by another application.';
                } else if (error.message && error.message.includes('Timeout')) {
                    errorMessage += 'Call timed out. The caller may have hung up.';
                } else if (error.message && error.message.includes('ended')) {
                    errorMessage += 'This call has already ended.';
                } else if (error.message && error.message.includes('microphone')) {
                    errorMessage += 'Microphone access error: ' + error.message;
                } else {
                    errorMessage += 'Error: ' + (error.message || error.toString());
                }
                alert(errorMessage);
                await cleanupCall();
            }
        }

        // Deny call
        async function denyCall() {
            if (callId && window.firebaseDB) {
                try {
                    const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                    await window.firebaseUpdateDoc(callDocRef, {
                        status: 'rejected',
                        rejectedAt: window.firebaseServerTimestamp(),
                        rejectedBy: ghostHandle
                    });
                } catch (e) {
                    console.error('Error rejecting call:', e);
                }
            }
            document.getElementById('incoming-call-modal').classList.add('hidden');
            callId = null;
        }

        // Listen for answer (caller side)
        async function listenForAnswer() {
            if (!callId || !window.firebaseDB) return;
            
            // Unsubscribe from any existing listener first
            if (answerUnsubscribe) {
                answerUnsubscribe();
                answerUnsubscribe = null;
            }
            
            const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
            answerUnsubscribe = window.firebaseOnSnapshot(callDocRef, async (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    
                    // Check if call was ended by other side
                    if (data.status === 'ended' || data.ended || data.status === 'rejected') {
                        if (callActive) {
                            cleanupCall();
                        }
                        return;
                    }
                    
                    // If status is 'active', the call was accepted - don't cleanup, just continue
                    if (data.status === 'active' && !callActive) {
                        console.log('Call accepted by other party');
                        // Don't cleanup - call is being established
                    }
                    
                    if (data?.answer && peerConnection && peerConnection.remoteDescription === null) {
                        try {
                            console.log('Setting remote description from answer');
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                            listenForAnswerCandidates();
                        } catch (e) {
                            console.error('Error setting remote description:', e);
                            // Don't cleanup on error - might be recoverable
                        }
                    }
                }
            });
        }

        // Listen for answer candidates (caller side)
        async function listenForAnswerCandidates() {
            if (!callId || !window.firebaseDB) return;
            
            const candidatesRef = window.firebaseCollection(window.firebaseDB, `calls/${callId}/answerCandidates`);
            answerCandidatesUnsubscribe = window.firebaseOnSnapshot(candidatesRef, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && peerConnection && peerConnection.remoteDescription) {
                        try {
                            const candidate = change.doc.data();
                            const iceCandidate = new RTCIceCandidate({
                                candidate: candidate.candidate,
                                sdpMLineIndex: candidate.sdpMLineIndex,
                                sdpMid: candidate.sdpMid
                            });
                            await peerConnection.addIceCandidate(iceCandidate);
                        } catch (e) {
                            // Ignore errors for duplicate candidates
                            if (!e.message.includes('duplicate')) {
                                console.error('Error adding ICE candidate:', e);
                            }
                        }
                    }
                });
            });
        }

        // Listen for offer candidates (receiver side)
        async function listenForOfferCandidates() {
            if (!callId || !window.firebaseDB) return;
            
            const candidatesRef = window.firebaseCollection(window.firebaseDB, `calls/${callId}/offerCandidates`);
            offerCandidatesUnsubscribe = window.firebaseOnSnapshot(candidatesRef, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && peerConnection && peerConnection.remoteDescription) {
                        try {
                            const candidate = change.doc.data();
                            const iceCandidate = new RTCIceCandidate({
                                candidate: candidate.candidate,
                                sdpMLineIndex: candidate.sdpMLineIndex,
                                sdpMid: candidate.sdpMid
                            });
                            await peerConnection.addIceCandidate(iceCandidate);
                        } catch (e) {
                            // Ignore errors for duplicate candidates
                            if (!e.message.includes('duplicate')) {
                                console.error('Error adding ICE candidate:', e);
                            }
                        }
                    }
                });
            });
        }

        // Show active call interface
        function showActiveCall() {
            // Don't set callActive here - it should be set before calling this function
            // callActive = true; // Removed - set by caller
            
            const activeCallUI = document.getElementById('active-call-interface');
            const callBtn = document.getElementById('ghost-call-btn');
            
            if (activeCallUI) {
                activeCallUI.classList.remove('hidden');
            }
            if (callBtn) {
                callBtn.classList.add('hidden');
            }
            
            // Ensure remote audio is playing when call interface is shown
            // This helps with autoplay policies
            if (remoteAudioElement && remoteAudioElement.paused) {
                remoteAudioElement.play().catch(e => {
                    console.warn('Could not resume remote audio:', e);
                });
            }
            
            // Note: Call end listening is already handled by listenForAnswer() and listenForIncomingCalls()
            // No need to create duplicate listeners here
        }

        // Hangup call
        async function hangupCall() {
            cleanupCall();
        }

        // Cleanup call resources
        async function cleanupCall() {
            try {
                const wasActive = callActive;
                callActive = false;
                
                // Remove current callId from processedCallIds to allow new calls
                if (callId) {
                    processedCallIds.delete(callId);
                    console.log('Removed callId from processedCallIds:', callId);
                }
                
                // Unsubscribe from all listeners
                if (callUnsubscribe) {
                    callUnsubscribe();
                    callUnsubscribe = null;
                }
                if (answerUnsubscribe) {
                    answerUnsubscribe();
                    answerUnsubscribe = null;
                }
                if (offerCandidatesUnsubscribe) {
                    offerCandidatesUnsubscribe();
                    offerCandidatesUnsubscribe = null;
                }
                if (answerCandidatesUnsubscribe) {
                    answerCandidatesUnsubscribe();
                    answerCandidatesUnsubscribe = null;
                }
                
                // Re-enable incoming call listener if call was active
                if (wasActive && ghostRoomId && window.firebaseDB) {
                    // Small delay to ensure cleanup is complete
                    setTimeout(() => {
                        if (!callActive) {
                            listenForIncomingCalls();
                        }
                    }, 1000);
                }
                
                // Disconnect Web Audio API nodes
                if (remoteAudioSource) {
                    try {
                        remoteAudioSource.disconnect();
                    } catch (e) {
                        console.warn('Error disconnecting remote audio source:', e);
                    }
                    remoteAudioSource = null;
                }

                if (localAudioSource) {
                    try {
                        localAudioSource.disconnect();
                    } catch (e) {
                        console.warn('Error disconnecting local audio source:', e);
                    }
                    localAudioSource = null;
                }

                // Reset gain node
                if (remoteGainNode) {
                    try {
                        remoteGainNode.disconnect();
                    } catch (e) {
                        console.warn('Error disconnecting gain node:', e);
                    }
                }

                // Stop all tracks
                if (localStream) {
                    try {
                        localStream.getTracks().forEach(track => {
                            track.stop();
                            track.enabled = false;
                        });
                    } catch (e) {
                        console.warn('Error stopping tracks:', e);
                    }
                    localStream = null;
                }
                
                // Stop remote audio element
                if (remoteAudioElement) {
                    try {
                        remoteAudioElement.pause();
                        remoteAudioElement.srcObject = null;
                        if (remoteAudioElement.src) {
                            remoteAudioElement.src = '';
                        }
                    } catch (e) {
                        console.warn('Error stopping remote audio:', e);
                    }
                    remoteAudioElement = null;
                }
                
                // Close peer connection
                if (peerConnection) {
                    try {
                        // Remove all tracks before closing
                        peerConnection.getSenders().forEach(sender => {
                            if (sender.track) {
                                sender.track.stop();
                            }
                        });
                        peerConnection.close();
                    } catch (e) {
                        console.warn('Error closing peer connection:', e);
                    }
                    peerConnection = null;
                }

                // Note: We don't close the audio context here to avoid reinitialization overhead
                // It will be reused for the next call
                
                // Update call document in Firestore to notify other side
                if (callId && window.firebaseDB) {
                    try {
                        const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                        await window.firebaseUpdateDoc(callDocRef, { 
                            ended: true, 
                            endedAt: window.firebaseServerTimestamp(),
                            status: 'ended',
                            endedBy: ghostHandle
                        });
                    } catch (e) {
                        console.warn('Could not update call document:', e);
                    }
                }
                
                // Hide UI
                const activeCallUI = document.getElementById('active-call-interface');
                if (activeCallUI) activeCallUI.classList.add('hidden');
                const incomingModal = document.getElementById('incoming-call-modal');
                if (incomingModal) incomingModal.classList.add('hidden');
                const callBtn = document.getElementById('ghost-call-btn');
                if (callBtn) callBtn.classList.remove('hidden');
                
                const endedCallId = callId;
                callId = null;
                isCaller = false;
                
                // Ensure ended call is removed from processedCallIds
                if (endedCallId) {
                    processedCallIds.delete(endedCallId);
                    console.log('Removed ended callId from processedCallIds:', endedCallId);
                }
                
            } catch (error) {
                console.error('Error in cleanupCall:', error);
                // Force cleanup even if there's an error
                callActive = false;
                if (callId) {
                    processedCallIds.delete(callId);
                }
                callId = null;
                isCaller = false;
            }
        }

        // Cleanup on disconnect
        async function disconnectGhostWithCleanup() {
            await cleanupCall();
            if (callUnsubscribe) {
                callUnsubscribe();
                callUnsubscribe = null;
            }
            disconnectGhost();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', async () => {
            if (callActive) {
                await cleanupCall();
            }
        });

        // Cleanup on page visibility change (mobile tab switch)
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden && callActive) {
                // Page is hidden, but don't cleanup - just pause
                if (remoteAudioElement) {
                    remoteAudioElement.pause();
                }
                // Suspend audio context to save resources
                if (callAudioContext && callAudioContext.state !== 'closed') {
                    await callAudioContext.suspend();
                }
            } else if (!document.hidden && callActive) {
                // Page is visible again, resume audio
                try {
                    if (callAudioContext && callAudioContext.state === 'suspended') {
                        await callAudioContext.resume();
                    }
                    if (remoteAudioElement) {
                        await remoteAudioElement.play();
                    }
                } catch (e) {
                    console.warn('Could not resume audio:', e);
                }
            }
        });

        // Handle page focus/blur for better audio management
        window.addEventListener('blur', async () => {
            if (callActive && callAudioContext && callAudioContext.state !== 'closed') {
                // Reduce volume slightly when page loses focus
                if (remoteGainNode) {
                    remoteGainNode.gain.setTargetAtTime(
                        remoteGainNode.gain.value * 0.8,
                        callAudioContext.currentTime,
                        0.1
                    );
                }
            }
        });

        window.addEventListener('focus', async () => {
            if (callActive && callAudioContext) {
                if (callAudioContext.state === 'suspended') {
                    await callAudioContext.resume();
                }
                // Restore volume when page regains focus
                if (remoteGainNode) {
                    remoteGainNode.gain.setTargetAtTime(
                        Math.min(0.8, remoteGainNode.gain.value * 1.2),
                        callAudioContext.currentTime,
                        0.1
                    );
                }
            }
        });

        // Add volume control function for user adjustment
        function adjustCallVolume(volume) {
            if (remoteGainNode && callAudioContext) {
                const clampedVolume = Math.max(0.1, Math.min(1.0, volume));
                remoteGainNode.gain.setTargetAtTime(
                    clampedVolume,
                    callAudioContext.currentTime,
                    0.1
                );
                if (remoteAudioElement) {
                    remoteAudioElement.volume = clampedVolume;
                }
            }
        }

        // Get optimal audio device
        async function getOptimalAudioDevice() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                // Prefer devices with "headset" or "headphone" in the name (better echo cancellation)
                const headsetDevice = audioInputs.find(device => 
                    device.label.toLowerCase().includes('headset') || 
                    device.label.toLowerCase().includes('headphone')
                );
                
                if (headsetDevice) {
                    return { deviceId: { exact: headsetDevice.deviceId } };
                }
                
                // Fallback to default
                return true;
            } catch (error) {
                console.warn('Could not enumerate devices:', error);
                return true; // Use default
            }
        }

        // Enhanced media constraints with device selection
        const getEnhancedMediaConstraints = async () => {
            const baseConstraints = getMediaConstraints();
            const deviceId = await getOptimalAudioDevice();
            
            if (deviceId !== true) {
                baseConstraints.audio.deviceId = deviceId;
            }
            
            return baseConstraints;
        };

        // Check microphone permissions
        async function checkMicrophonePermission() {
            try {
                if (navigator.permissions && navigator.permissions.query) {
                    const result = await navigator.permissions.query({ name: 'microphone' });
                    return result.state; // 'granted', 'denied', or 'prompt'
                }
                // Fallback: try to get media to check permission
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());
                    return 'granted';
                } catch (e) {
                    if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                        return 'denied';
                    }
                    return 'prompt';
                }
            } catch (e) {
                console.warn('Could not check microphone permission:', e);
                return 'prompt'; // Assume we can prompt
            }
        }

        // Request microphone permission with better error handling
        async function requestMicrophoneAccess() {
            try {
                // First check current permission state
                const permissionState = await checkMicrophonePermission();
                
                if (permissionState === 'denied') {
                    throw new Error('Microphone permission was denied. Please enable it in your browser settings.');
                }
                
                // Try to get media with basic constraints first
                const basicConstraints = { audio: true };
                const stream = await navigator.mediaDevices.getUserMedia(basicConstraints);
                
                // Stop the test stream
                stream.getTracks().forEach(track => track.stop());
                
                return true;
            } catch (error) {
                console.error('Microphone access error:', error);
                throw error;
            }
        }

    </script>
</body>
</html>
</html>
