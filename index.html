<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Postmortem | Ultimate Suite</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, doc, updateDoc, getDocs, getDoc, deleteDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // ============================================
        // FIREBASE CONFIGURATION
        // ============================================
        const firebaseConfig = {
            apiKey: "AIzaSyC8Ce3i_s0sfemJ6iRZhsdUnZMNFSfwIuM",
            authDomain: "link-postmortem.firebaseapp.com",
            projectId: "link-postmortem",
            storageBucket: "link-postmortem.firebasestorage.app",
            messagingSenderId: "349174304404",
            appId: "1:349174304404:web:b6f9d8ae5db19f926a6e81",
            measurementId: "G-GE65L6YQ7D"
        };
        // ============================================

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);

            // Make Firebase functions globally available
            window.firebaseDB = db;
            window.firebaseAddDoc = addDoc;
            window.firebaseCollection = collection;
            window.firebaseQuery = query;
            window.firebaseOrderBy = orderBy;
            window.firebaseOnSnapshot = onSnapshot;
            window.firebaseServerTimestamp = serverTimestamp;
            window.firebaseDoc = doc;
            window.firebaseUpdateDoc = updateDoc;
            window.firebaseGetDocs = getDocs;
            window.firebaseGetDoc = getDoc;
            window.firebaseDeleteDoc = deleteDoc;

            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            window.firebaseDB = null;
        }
    </script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;900&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace']
                    },
                    colors: {
                        zinc: { 950: '#09090b' },
                        cyan: { 950: '#083344' }
                    },
                    animation: {
                        'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #000000;
            color: #d4d4d8;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        textarea::-webkit-scrollbar {
            width: 8px;
        }

        textarea::-webkit-scrollbar-track {
            background: #18181b;
        }

        textarea::-webkit-scrollbar-thumb {
            background: #3f3f46;
            border-radius: 4px;
        }

        textarea::-webkit-scrollbar-thumb:hover {
            background: #52525b;
        }

        .btn-scroll::-webkit-scrollbar {
            width: 4px;
        }

        .btn-scroll::-webkit-scrollbar-track {
            background: transparent;
        }

        .btn-scroll::-webkit-scrollbar-thumb {
            background: #3f3f46;
            border-radius: 4px;
        }

        .animate-in {
            animation: fadeIn 0.5s ease-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .no-select {
            user-select: none;
            -webkit-user-select: none;
        }

        /* Sonic Visualizer Canvas */
        #sonic-canvas {
            width: 100%;
            height: 100px;
            background: #000;
            border-bottom: 1px solid #1e293b;
        }

        /* YouTube Result Styles */
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Ghost Comms Chat Styles */
        #ghost-messages::-webkit-scrollbar {
            width: 6px;
        }

        #ghost-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        #ghost-messages::-webkit-scrollbar-thumb {
            background: #3f3f46;
            border-radius: 3px;
        }

        #ghost-messages::-webkit-scrollbar-thumb:hover {
            background: #52525b;
        }

        .message-bubble {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-own {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.2);
        }

        .message-other {
            background: #27272a;
            color: #e4e4e7;
            margin-right: auto;
            border-bottom-left-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Modern Chat Window Styles */
        #ghost-modal {
            animation: fadeIn 0.3s ease-out;
        }

        @media (max-width: 768px) {
            #ghost-modal>div {
                max-width: 100vw;
                max-height: 100vh;
                border-radius: 0;
            }

            #ghost-join-panel {
                max-height: 50vh;
            }

            .message-bubble {
                max-width: 90% !important;
            }
        }

        /* Floating Button Styles */
        #ghost-float-btn {
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        #ghost-modal {
            animation: fadeIn 0.3s ease-out;
        }

        /* HACKER TRAP - GLITCH MODE */
        .system-breach {
            animation: glitch 0.3s infinite, colorShift 0.5s infinite, shake 0.1s infinite;
            filter: invert(1) hue-rotate(180deg);
            position: relative;
            overflow: hidden;
        }

        .system-breach::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 0, 0, 0.1) 2px, rgba(255, 0, 0, 0.1) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0, 255, 0, 0.1) 2px, rgba(0, 255, 0, 0.1) 4px);
            pointer-events: none;
            z-index: 9999;
            animation: noise 0.2s infinite;
        }

        @keyframes glitch {

            0%,
            100% {
                transform: translate(0);
            }

            20% {
                transform: translate(-2px, 2px);
            }

            40% {
                transform: translate(-2px, -2px);
            }

            60% {
                transform: translate(2px, 2px);
            }

            80% {
                transform: translate(2px, -2px);
            }
        }

        @keyframes colorShift {
            0% {
                filter: invert(1) hue-rotate(0deg);
            }

            25% {
                filter: invert(1) hue-rotate(90deg);
            }

            50% {
                filter: invert(1) hue-rotate(180deg);
            }

            75% {
                filter: invert(1) hue-rotate(270deg);
            }

            100% {
                filter: invert(1) hue-rotate(360deg);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        @keyframes noise {
            0% {
                opacity: 0.1;
            }

            50% {
                opacity: 0.3;
            }

            100% {
                opacity: 0.1;
            }
        }

        /* SECURITY BREACH MODAL */
        #security-breach-modal {
            animation: fadeIn 0.2s ease-out;
            z-index: 10000;
        }

        .breach-warning {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            border: 3px solid #fca5a5;
            box-shadow: 0 0 30px rgba(220, 38, 38, 0.8), inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* CHAOS MODE - PHYSICS */
        .physics-active {
            position: relative;
        }

        .physics-body {
            position: absolute;
            pointer-events: none;
        }

        /* SONIC PULSE - AUDIO VISUALIZATION */
        .pulse-active {
            transition: box-shadow 0.1s ease-out, transform 0.1s ease-out;
        }

        /* GLITCH OVERLAY FOR PIRACY DETECTION */
        .glitch-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
            color: red;
            font-family: 'Courier New', monospace;
            text-align: center;
            padding-top: 20%;
            font-size: 2rem;
        }

        /* MOBILE RESPONSIVE FIXES */
        @media (max-width: 768px) {

            /* Fix container padding on mobile */
            .container {
                padding-left: 1rem;
                padding-right: 1rem;
            }

            /* Fix navigation on mobile */
            nav {
                padding-left: 1rem;
                padding-right: 1rem;
            }

            /* Fix ghost modal on mobile */
            #ghost-modal {
                padding: 0;
                align-items: stretch;
            }

            #ghost-modal>div {
                max-width: 100%;
                max-height: 100vh;
                height: 100vh;
                border-radius: 0;
                margin: 0;
            }

            /* Fix ghost join panel on mobile */
            #ghost-join-panel {
                width: 100%;
                max-width: 100%;
                border-right: none;
                border-bottom: 1px solid rgb(39 39 42);
            }

            /* Stack ghost modal content on mobile */
            #ghost-modal>div>div.flex {
                flex-direction: column;
            }

            /* Fix chat area on mobile */
            #ghost-modal .flex-1.flex.flex-col {
                min-height: 0;
            }

            /* Fix messages container on mobile */
            #ghost-messages {
                min-height: 300px;
                padding: 1rem;
            }

            /* Fix input area on mobile */
            .input-area {
                padding: 0.75rem;
            }

            /* Fix message bubbles on mobile */
            .message-bubble {
                max-width: 90% !important;
                font-size: 0.875rem;
            }

            /* Fix buttons on mobile */
            button,
            .icon-btn {
                min-height: 44px;
                /* Touch target size */
                min-width: 44px;
            }

            /* Fix floating button on mobile */
            #ghost-float-btn {
                width: 56px;
                height: 56px;
                bottom: 1rem;
                right: 1rem;
            }

            /* Fix modals on mobile */
            .call-modal,
            #incoming-call-modal,
            #memory-warning-modal {
                padding: 1rem;
            }

            .call-modal>div,
            #incoming-call-modal>div,
            #memory-warning-modal>div {
                max-width: 95%;
                padding: 1.5rem;
            }

            /* Fix active call interface on mobile */
            #active-call-interface {
                left: 50%;
                transform: translateX(-50%);
                width: calc(100% - 2rem);
                max-width: 100%;
                padding: 0.75rem;
            }

            /* Fix text sizes on mobile */
            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            /* Fix tabs on mobile */
            .tab-content {
                padding: 1rem 0;
            }

            /* Fix form inputs on mobile */
            input,
            textarea,
            select {
                font-size: 16px;
                /* Prevents zoom on iOS */
            }

            /* Fix ghost message input on mobile */
            #ghost-message-input {
                font-size: 16px;
                padding: 0.75rem;
            }

            /* Fix emoji and GIF pickers on mobile */
            #ghost-emoji-picker,
            #ghost-gif-picker {
                width: calc(100vw - 2rem);
                max-width: 100%;
                left: 1rem;
                right: 1rem;
            }

            /* Fix GIF grid on mobile */
            #ghost-gif-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            /* Fix emoji grid on mobile - 6 columns with smaller buttons */
            #ghost-emoji-grid {
                grid-template-columns: repeat(6, 1fr) !important;
                gap: 0.25rem !important;
            }

            #ghost-emoji-grid button {
                width: 2.25rem !important;
                height: 2.25rem !important;
                font-size: 1.125rem !important;
            }

            /* Fix emoji category tabs on mobile - smaller and scrollable */
            #ghost-emoji-picker>div:first-child {
                gap: 0.25rem !important;
                padding: 0.5rem !important;
            }

            #ghost-emoji-picker>div:first-child button {
                padding: 0.25rem 0.5rem !important;
                font-size: 1rem !important;
                min-width: unset !important;
                min-height: unset !important;
            }
        }

        @media (max-width: 480px) {

            /* Extra small mobile fixes */
            h1 {
                font-size: 1.5rem;
            }

            .message-bubble {
                max-width: 95% !important;
                padding: 0.5rem;
            }

            #ghost-float-btn {
                width: 48px;
                height: 48px;
            }

            /* Stack header controls on very small screens */
            .header-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>

<body class="selection:bg-rose-900 selection:text-white min-h-screen flex flex-col no-select">

    <!-- NAVIGATION -->
    <nav class="sticky top-0 z-50 bg-black/80 backdrop-blur-xl border-b border-zinc-900">
        <div class="container mx-auto px-4 md:px-8 h-16 flex items-center justify-between">
            <div class="flex items-center gap-3 cursor-pointer" onclick="location.reload()">
                <div
                    class="w-8 h-8 bg-zinc-900 border border-zinc-800 rounded-lg flex items-center justify-center text-rose-600 font-bold text-xl shadow-[0_0_15px_rgba(225,29,72,0.3)]">
                    <i data-lucide="skull" class="w-5 h-5"></i>
                </div>
                <span class="text-xl font-bold text-white tracking-wider">
                    Link <span class="text-rose-600">Postmortem</span>
                </span>
            </div>

            <!-- Desktop Nav -->
            <div class="hidden md:flex items-center gap-1 bg-zinc-900/50 p-1 rounded-full border border-zinc-800">
                <button type="button" onclick="switchTab('downloader')" id="btn-nav-downloader"
                    class="px-5 py-1.5 rounded-full text-xs font-medium transition-all bg-zinc-800 text-white shadow-lg">Downloader</button>
                <button type="button" onclick="switchTab('crypter')" id="btn-nav-crypter"
                    class="px-5 py-1.5 rounded-full text-xs font-medium transition-all text-zinc-500 hover:text-zinc-300">Encrypter</button>
                <button type="button" onclick="switchTab('keys')" id="btn-nav-keys"
                    class="px-5 py-1.5 rounded-full text-xs font-medium transition-all text-zinc-500 hover:text-zinc-300">Key
                    Forge</button>
                <button type="button" onclick="switchTab('stego')" id="btn-nav-stego"
                    class="px-5 py-1.5 rounded-full text-xs font-medium transition-all text-zinc-500 hover:text-zinc-300">Stego
                    Lab</button>
                <button type="button" onclick="switchTab('sonic')" id="btn-nav-sonic"
                    class="px-5 py-1.5 rounded-full text-xs font-medium transition-all text-cyan-500 hover:text-cyan-300 border border-transparent hover:border-cyan-900/50 flex items-center gap-1">
                    <i data-lucide="waves" class="w-3 h-3"></i> Sonic Lab
                </button>
            </div>

            <!-- Mobile Menu Toggle -->
            <button type="button" onclick="toggleMenu()" class="md:hidden p-2 text-zinc-400">
                <i data-lucide="menu" class="w-6 h-6"></i>
            </button>
        </div>

        <!-- Mobile Menu -->
        <div id="mobile-menu" class="hidden md:hidden bg-zinc-950 border-b border-zinc-900 p-4 flex flex-col gap-4">
            <button type="button" onclick="switchTab('downloader'); toggleMenu()"
                class="text-left text-zinc-300 font-medium p-2 hover:bg-zinc-900 rounded">Downloader</button>
            <button type="button" onclick="switchTab('crypter'); toggleMenu()"
                class="text-left text-zinc-300 font-medium p-2 hover:bg-zinc-900 rounded">Link Crypter</button>
            <button type="button" onclick="switchTab('keys'); toggleMenu()"
                class="text-left text-zinc-300 font-medium p-2 hover:bg-zinc-900 rounded">Key Forge</button>
            <button type="button" onclick="switchTab('stego'); toggleMenu()"
                class="text-left text-zinc-300 font-medium p-2 hover:bg-zinc-900 rounded">Steganography</button>
            <button type="button" onclick="switchTab('sonic'); toggleMenu()"
                class="text-left text-cyan-400 font-medium p-2 hover:bg-zinc-900 rounded">Sonic Lab</button>
        </div>
    </nav>

    <!-- MAIN CONTENT -->
    <main class="relative pt-12 pb-24 overflow-hidden flex-grow relative">

        <!-- Background Gradients -->
        <div class="absolute top-0 left-1/2 -translate-x-1/2 w-full h-full z-0 pointer-events-none opacity-20">
            <div
                class="absolute top-20 left-1/4 w-[300px] md:w-[500px] h-[300px] md:h-[500px] bg-rose-900/40 rounded-full mix-blend-screen filter blur-[80px] md:blur-[100px] animate-pulse">
            </div>
            <div
                class="absolute bottom-20 right-1/4 w-[300px] md:w-[400px] h-[300px] md:h-[400px] bg-indigo-900/40 rounded-full mix-blend-screen filter blur-[80px] md:blur-[100px]">
            </div>
        </div>

        <div class="container mx-auto px-4 relative z-10">

            <!-- TAB: DOWNLOADER -->
            <div id="tab-downloader" class="tab-content active animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-6xl font-black tracking-tight mb-4 text-white">
                        Extract <span
                            class="text-transparent bg-clip-text bg-gradient-to-r from-rose-500 to-orange-600">Remote</span>
                        Content
                    </h1>
                    <p class="text-zinc-500 max-w-xl mx-auto text-lg">
                        Bypass restrictions and access your files directly via our secure tunnel.
                    </p>
                </div>

                <div
                    class="max-w-3xl mx-auto bg-zinc-900/50 backdrop-blur-md rounded-2xl shadow-2xl border border-zinc-800 p-3 mb-8">
                    <form onsubmit="handleDownload(event)" class="relative flex flex-col md:flex-row gap-2">
                        <div class="relative flex-grow">
                            <div
                                class="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none text-zinc-500">
                                <i data-lucide="link" class="w-5 h-5"></i>
                            </div>
                            <input type="text" id="dl-input" placeholder="Paste source link (Cloud or Direct)..."
                                class="w-full pl-12 pr-10 py-4 rounded-xl bg-black border border-zinc-800 focus:border-rose-600 focus:ring-1 focus:ring-rose-600 outline-none transition-all text-white placeholder:text-zinc-600">
                            <button type="button" onclick="clearInput('dl-input')"
                                class="absolute inset-y-0 right-0 pr-4 flex items-center text-zinc-600 hover:text-zinc-300 transition-colors">
                                <i data-lucide="x" class="w-4 h-4"></i>
                            </button>
                        </div>
                        <button type="submit" id="dl-btn"
                            class="bg-rose-600 hover:bg-rose-700 disabled:bg-zinc-700 disabled:text-zinc-500 text-white font-bold py-4 px-8 rounded-xl transition-all flex items-center justify-center gap-2 shadow-[0_0_20px_rgba(225,29,72,0.3)] hover:shadow-[0_0_30px_rgba(225,29,72,0.5)]">
                            <i data-lucide="download" class="w-5 h-5"></i>
                            <span>Extract</span>
                        </button>
                    </form>
                </div>

                <div id="dl-error"
                    class="hidden max-w-3xl mx-auto mb-8 p-4 bg-rose-950/30 text-rose-400 border border-rose-900/50 rounded-xl flex items-center justify-center gap-2">
                    <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                    <span id="dl-error-text"></span>
                </div>

                <div id="media-result" class="hidden max-w-3xl mx-auto mt-8 animate-in">
                    <div
                        class="bg-zinc-900 border border-zinc-800 rounded-xl p-6 flex flex-col items-center text-center">
                        <div
                            class="w-16 h-16 bg-rose-900/20 rounded-full flex items-center justify-center text-rose-500 mb-4 animate-pulse">
                            <i data-lucide="file-video" class="w-8 h-8"></i>
                        </div>
                        <h3 class="text-xl font-bold text-white mb-2">Direct Media Detected</h3>
                        <p class="text-zinc-400 mb-6 text-sm max-w-md">The link appears to be a direct media file. You
                            can access it directly.</p>
                        <a id="media-download-btn" href="#" target="_blank" rel="noopener noreferrer"
                            class="bg-white text-black hover:bg-zinc-200 font-bold py-3 px-8 rounded-full flex items-center gap-2 transition-all shadow-lg hover:scale-105">
                            <i data-lucide="download" class="w-4 h-4"></i> <span id="media-btn-label">Download /
                                Play</span>
                        </a>
                    </div>
                </div>


                <div id="dl-result" class="hidden max-w-5xl mx-auto mt-8 animate-in">
                    <div
                        class="bg-zinc-900 border border-zinc-800 rounded-xl p-4 mb-4 flex flex-col md:flex-row items-center justify-between gap-4">
                        <div class="flex items-center gap-3">
                            <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                            <p class="text-sm text-zinc-300">Tunnel established. Loading content...</p>
                        </div>
                        <a id="dl-external-link" href="#" target="_blank" rel="noopener noreferrer"
                            class="bg-zinc-800 hover:bg-zinc-700 border border-zinc-700 text-white px-5 py-2.5 rounded-lg text-sm font-semibold flex items-center gap-2 transition-colors">
                            Open in New Tab <i data-lucide="external-link" class="w-4 h-4"></i>
                        </a>
                    </div>
                    <div
                        class="bg-black rounded-2xl shadow-2xl overflow-hidden border border-zinc-800 relative h-[600px]">
                        <iframe id="dl-iframe" src="" title="Secure Download Server" class="w-full h-full border-0"
                            sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe>
                    </div>
                </div>
            </div>

            <!-- TAB: CRYPTER -->
            <div id="tab-crypter" class="tab-content animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4 text-white">
                        Link <span class="text-rose-600">Obfuscator</span>
                    </h1>
                    <p class="text-zinc-500 max-w-lg mx-auto">Encrypt multiple links into a single payload with
                        time-locks.</p>
                </div>

                <div
                    class="max-w-4xl mx-auto grid md:grid-cols-2 gap-6 bg-zinc-900/30 p-2 rounded-2xl border border-zinc-800 backdrop-blur-sm">
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col h-full">
                        <div class="flex justify-between items-center mb-4">
                            <label class="text-sm font-bold text-zinc-400 uppercase tracking-wider">Input
                                Payload</label>
                            <div class="flex bg-zinc-900 rounded-lg p-1 border border-zinc-800">
                                <button type="button" onclick="setCryptoMode('encrypt')" id="mode-encrypt"
                                    class="p-1.5 rounded-md transition-all bg-zinc-700 text-white"><i data-lucide="lock"
                                        class="w-4 h-4"></i></button>
                                <button type="button" onclick="setCryptoMode('decrypt')" id="mode-decrypt"
                                    class="p-1.5 rounded-md transition-all text-zinc-600 hover:text-zinc-400"><i
                                        data-lucide="unlock" class="w-4 h-4"></i></button>
                            </div>
                        </div>
                        <div class="relative w-full flex-grow flex flex-col">
                            <textarea id="crypto-input" placeholder="Paste link(s) here..."
                                class="w-full flex-grow bg-zinc-900 border border-zinc-800 rounded-lg p-4 pr-10 text-zinc-300 focus:border-rose-600 outline-none resize-none font-mono text-sm min-h-[150px]"></textarea>
                            <div class="absolute top-2 right-2 flex flex-col gap-1">
                                <button type="button" onclick="clearInput('crypto-input')"
                                    class="p-1.5 text-zinc-500 hover:text-white bg-zinc-800/50 rounded"><i
                                        data-lucide="x" class="w-3 h-3"></i></button>
                                <button type="button" onclick="pasteToInput('crypto-input')"
                                    class="p-1.5 text-zinc-500 hover:text-white bg-zinc-800/50 rounded"><i
                                        data-lucide="clipboard" class="w-3 h-3"></i></button>
                            </div>
                        </div>
                        <div id="crypto-settings" class="mt-4 grid grid-cols-2 gap-3">
                            <div>
                                <label
                                    class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Passcode</label>
                                <input type="text" id="crypto-pass" placeholder="Optional PIN"
                                    class="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-3 py-2 text-sm text-white focus:border-rose-600 outline-none">
                            </div>
                            <div id="crypto-expiry-container">
                                <label
                                    class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Lifespan</label>
                                <select id="crypto-expiry"
                                    class="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-3 py-2 text-sm text-zinc-300 focus:border-rose-600 outline-none">
                                    <option value="0">Eternal</option>
                                    <option value="5">5 Minutes</option>
                                    <option value="60">1 Hour</option>
                                    <option value="1440">24 Hours</option>
                                </select>
                            </div>
                        </div>
                        <button type="button" onclick="handleCryptoProcess()" id="crypto-action-btn"
                            class="mt-4 w-full bg-white text-black hover:bg-zinc-200 font-bold py-3 rounded-lg flex items-center justify-center gap-2">
                            <i data-lucide="lock" id="action-icon" class="w-4 h-4"></i> <span id="action-text">Encrypt
                                Payload</span>
                        </button>
                    </div>

                    <div
                        class="bg-zinc-900/80 p-6 rounded-xl border border-zinc-800 flex flex-col h-full relative overflow-hidden">
                        <div class="absolute top-0 right-0 w-20 h-20 bg-rose-600/10 blur-xl rounded-full"></div>
                        <div class="flex justify-between items-center mb-4 relative z-10">
                            <label class="text-sm font-bold text-zinc-400 uppercase tracking-wider">Result</label>
                            <div class="flex gap-2">
                                <button type="button" id="btn-copy" onclick="copyToClipboard()"
                                    class="hidden text-xs flex items-center gap-1 text-rose-500 hover:text-rose-400 font-medium"><i
                                        data-lucide="copy" class="w-3 h-3"></i> <span>Copy</span></button>
                            </div>
                        </div>
                        <div
                            class="flex-grow bg-black border border-zinc-800 rounded-lg p-4 relative min-h-[150px] flex flex-col overflow-hidden">
                            <div id="result-empty"
                                class="h-full flex flex-col items-center justify-center text-zinc-700">
                                <i data-lucide="refresh-cw" class="mb-2 opacity-20 w-8 h-8"></i> <span
                                    class="text-xs">Waiting...</span>
                            </div>
                            <div id="result-text" class="hidden break-all font-mono text-sm text-emerald-400"></div>
                            <div id="result-launch"
                                class="hidden absolute inset-0 flex flex-col items-center justify-start bg-black/60 backdrop-blur-[1px] pt-4">
                                <div id="launch-buttons-container"
                                    class="flex flex-col gap-2 w-full px-4 overflow-y-auto btn-scroll items-center mb-2 justify-start flex-grow"
                                    style="max-height: 200px;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- TAB: KEY FORGE -->
            <div id="tab-keys" class="tab-content animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4 text-white">
                        Key <span class="text-amber-500">Forge</span>
                    </h1>
                    <p class="text-zinc-500 max-w-lg mx-auto">
                        Split your secret into multiple keys. <br><span class="text-amber-500/80">ALL</span> generated
                        keys are required to unlock the data.
                    </p>
                </div>

                <div
                    class="max-w-4xl mx-auto grid md:grid-cols-2 gap-6 bg-zinc-900/30 p-4 rounded-2xl border border-zinc-800 backdrop-blur-sm">

                    <!-- KEY GENERATION -->
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col gap-4">
                        <div class="flex items-center gap-2 mb-2 border-b border-amber-900/30 pb-2">
                            <i data-lucide="hammer" class="text-amber-500 w-5 h-5"></i>
                            <h3 class="font-bold text-white uppercase tracking-wider text-sm">Forge New Keys</h3>
                        </div>

                        <div>
                            <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-1 block">Secret
                                Message / URL</label>
                            <textarea id="keys-input" placeholder="Enter the secret to split..."
                                class="w-full bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-amber-100 focus:border-amber-500 outline-none resize-none font-mono text-xs h-24 placeholder:text-zinc-700"></textarea>
                        </div>

                        <div class="bg-zinc-900/50 p-3 rounded-lg border border-zinc-800">
                            <div class="flex justify-between items-center mb-2">
                                <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider">Number of
                                    Keys</label>
                                <span id="keys-count-val" class="text-amber-500 font-bold font-mono text-sm">3</span>
                            </div>
                            <input type="range" id="keys-count" min="2" max="10" value="3"
                                class="w-full h-2 bg-zinc-800 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                oninput="document.getElementById('keys-count-val').innerText = this.value; document.getElementById('keys-req-val').innerText = this.value;">
                            <p class="text-[10px] text-zinc-500 mt-2 text-center">
                                * To decrypt, the user will need exactly <span id="keys-req-val"
                                    class="text-amber-500 font-bold">3</span> keys.
                            </p>
                        </div>

                        <button onclick="forgeKeys()"
                            class="w-full bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 mt-auto shadow-lg shadow-amber-900/20">
                            <i data-lucide="key" class="w-4 h-4"></i> Generate Keys
                        </button>

                        <div id="forge-output"
                            class="hidden w-full bg-zinc-950 border border-amber-900/50 rounded-lg p-3 font-mono text-[10px] text-amber-400 break-all relative max-h-40 overflow-y-auto btn-scroll">
                            <!-- Output -->
                        </div>
                    </div>

                    <!-- KEY UNLOCK -->
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col gap-4">
                        <div class="flex items-center gap-2 mb-2 border-b border-zinc-800 pb-2">
                            <i data-lucide="unlock" class="text-zinc-400 w-5 h-5"></i>
                            <h3 class="font-bold text-white uppercase tracking-wider text-sm">Unlock Vault</h3>
                        </div>

                        <div class="flex-grow flex flex-col">
                            <label class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-1 block">Input
                                Keys (One per line)</label>
                            <textarea id="keys-unlock-input" placeholder="Paste Key 1&#10;Paste Key 2&#10;..."
                                class="w-full flex-grow bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-zinc-300 focus:border-amber-500 outline-none resize-none font-mono text-xs placeholder:text-zinc-700 min-h-[150px]"></textarea>
                        </div>

                        <button onclick="unlockKeys()"
                            class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-3 rounded-lg border border-zinc-700 flex items-center justify-center gap-2">
                            <i data-lucide="folder-open" class="w-4 h-4"></i> Combine & Reveal
                        </button>

                        <div id="unlock-result"
                            class="hidden w-full bg-zinc-950 border border-zinc-800 rounded-lg p-3 font-mono text-sm text-center break-all">
                        </div>
                    </div>

                </div>
            </div>

            <!-- TAB: STEGO LAB -->
            <div id="tab-stego" class="tab-content animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4 text-white">
                        Stego <span class="text-rose-600">Lab</span>
                    </h1>
                    <p class="text-zinc-500 max-w-lg mx-auto">Inject encrypted payloads into image pixels.</p>
                </div>

                <div
                    class="max-w-5xl mx-auto grid md:grid-cols-2 gap-8 bg-zinc-900/30 p-4 rounded-2xl border border-zinc-800 backdrop-blur-sm">
                    <!-- Inject -->
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col gap-4">
                        <div class="flex items-center gap-2 mb-2 border-b border-zinc-800 pb-2">
                            <i data-lucide="file-plus" class="text-rose-500 w-5 h-5"></i>
                            <h3 class="font-bold text-white uppercase tracking-wider text-sm">Injection</h3>
                        </div>
                        <div class="space-y-3">
                            <div>
                                <label
                                    class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-1 block">Carrier</label>
                                <div class="flex gap-2">
                                    <label
                                        class="flex-1 cursor-pointer bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded-lg p-2 text-xs text-center border border-zinc-700 flex items-center justify-center gap-2">
                                        <input type="file" id="stego-upload-inject" accept="image/*" class="hidden"
                                            onchange="document.getElementById('file-name-display').innerText = this.files[0]?.name || 'Upload Image'" />
                                        <i data-lucide="upload" class="w-3 h-3"></i> <span id="file-name-display">Upload
                                            Image</span>
                                    </label>
                                    <button type="button" onclick="generateCarrierImage()"
                                        class="flex-1 bg-indigo-900/50 hover:bg-indigo-900 text-indigo-200 rounded-lg p-2 text-xs border border-indigo-800 flex items-center justify-center gap-2">
                                        <i data-lucide="cpu" class="w-3 h-3"></i> Auto-Generate
                                    </button>
                                </div>
                                <div id="generated-status" class="hidden text-[10px] text-indigo-400 mt-1 text-center">
                                    <i data-lucide="check" class="w-3 h-3 inline"></i> Carrier Generated
                                </div>
                            </div>
                            <textarea id="stego-text-inject" placeholder="Payload..."
                                class="w-full bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-zinc-300 focus:border-rose-600 outline-none resize-none font-mono text-xs h-20"></textarea>
                            <input type="text" id="stego-pass-inject" placeholder="Passcode (Optional)"
                                class="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-3 py-2 text-sm text-white focus:border-rose-600 outline-none">
                        </div>
                        <button type="button" onclick="stegoInject()"
                            class="w-full bg-rose-600 hover:bg-rose-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 mt-auto">
                            <i data-lucide="syringe" class="w-4 h-4"></i> Inject & Download
                        </button>
                    </div>

                    <!-- Extract -->
                    <div class="bg-black/50 p-6 rounded-xl border border-zinc-800 flex flex-col gap-4">
                        <div class="flex items-center gap-2 mb-2 border-b border-zinc-800 pb-2">
                            <i data-lucide="scan-eye" class="text-emerald-500 w-5 h-5"></i>
                            <h3 class="font-bold text-white uppercase tracking-wider text-sm">Batch Extraction</h3>
                        </div>
                        <div>
                            <input type="file" id="stego-upload-extract" multiple accept="image/*"
                                class="block w-full text-sm text-zinc-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-zinc-800 file:text-white hover:file:bg-zinc-700 cursor-pointer" />
                        </div>
                        <input type="text" id="stego-pass-extract" placeholder="Decryption Passcode"
                            class="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-3 py-2 text-sm text-white focus:border-emerald-600 outline-none">
                        <div id="stego-result-area"
                            class="w-full bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-zinc-500 font-mono text-xs h-64 overflow-y-auto break-all relative">
                            <div
                                class="absolute inset-0 flex items-center justify-center opacity-30 pointer-events-none">
                                Waiting...</div>
                        </div>
                        <button type="button" onclick="stegoExtract()"
                            class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-3 rounded-lg border border-zinc-700 flex items-center justify-center gap-2">
                            <i data-lucide="download-cloud" class="w-4 h-4"></i> Extract Data
                        </button>
                    </div>
                </div>
            </div>

            <!-- TAB: SONIC LAB (NEW EXPERIMENT) -->
            <div id="tab-sonic" class="tab-content animate-in">
                <div class="text-center mb-10">
                    <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4 text-white">
                        Sonic <span class="text-cyan-500">Lab</span> <span
                            class="text-xs align-top bg-cyan-900/30 text-cyan-300 px-2 py-1 rounded ml-2 font-mono font-normal tracking-wide">BETA</span>
                    </h1>
                    <p class="text-zinc-500 max-w-lg mx-auto">
                        Audio Steganography. Hide data inside "Dark Ambient" drone frequencies.
                    </p>
                </div>

                <!-- Visualizer -->
                <div
                    class="max-w-4xl mx-auto mb-8 bg-black border border-cyan-900/50 rounded-xl overflow-hidden shadow-[0_0_30px_rgba(8,145,178,0.1)] relative">
                    <canvas id="sonic-canvas"></canvas>
                    <div class="absolute top-2 left-3 text-[10px] font-mono text-cyan-500/50 uppercase tracking-widest">
                        Frequency Domain Monitor</div>
                </div>

                <div
                    class="max-w-4xl mx-auto grid md:grid-cols-2 gap-8 bg-cyan-950/10 p-6 rounded-2xl border border-cyan-900/30 backdrop-blur-sm">

                    <!-- ENCODE AUDIO -->
                    <div class="space-y-4">
                        <div class="flex items-center gap-2 text-cyan-400 border-b border-cyan-900/30 pb-2">
                            <i data-lucide="mic" class="w-5 h-5"></i>
                            <h3 class="font-bold uppercase tracking-wider text-sm">Generate Carrier Signal</h3>
                        </div>
                        <p class="text-xs text-zinc-500">Creates a generated 10s audio file with data embedded in the
                            noise floor.</p>

                        <textarea id="sonic-input" placeholder="Enter secret message to modulate..."
                            class="w-full bg-zinc-900 border border-zinc-800 rounded-lg p-3 text-cyan-100 focus:border-cyan-500 outline-none resize-none font-mono text-xs h-32 placeholder:text-zinc-600"></textarea>

                        <button onclick="generateSonic()" id="btn-sonic-gen"
                            class="w-full bg-cyan-900 hover:bg-cyan-800 text-cyan-100 border border-cyan-700/50 font-bold py-3 rounded-lg transition-all flex items-center justify-center gap-2 shadow-lg shadow-cyan-900/20">
                            <i data-lucide="activity" class="w-4 h-4"></i> Generate & Download WAV
                        </button>
                    </div>

                    <!-- DECODE AUDIO -->
                    <div class="space-y-4">
                        <div class="flex items-center gap-2 text-rose-400 border-b border-rose-900/30 pb-2">
                            <i data-lucide="headphones" class="w-5 h-5"></i>
                            <h3 class="font-bold uppercase tracking-wider text-sm">Analyze Audio Signal</h3>
                        </div>
                        <p class="text-xs text-zinc-500">Upload a WAV file generated by this lab.</p>

                        <div
                            class="border-2 border-dashed border-zinc-800 rounded-xl p-8 text-center hover:border-cyan-800 transition-colors group cursor-pointer relative bg-zinc-900/50">
                            <input type="file" id="sonic-upload" accept=".wav"
                                class="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                onchange="handleSonicUpload(this)">
                            <div class="flex flex-col items-center">
                                <i data-lucide="music"
                                    class="w-8 h-8 text-zinc-600 group-hover:text-cyan-500 mb-2 transition-colors"></i>
                                <span class="text-sm text-zinc-400 font-mono" id="sonic-file-name">Drop .WAV File</span>
                            </div>
                        </div>

                        <div id="sonic-result"
                            class="hidden w-full bg-black border border-cyan-900/50 rounded-lg p-4 font-mono text-xs break-all relative min-h-[80px]">
                            <div class="text-[10px] text-zinc-600 uppercase mb-1">Decoded Signal:</div>
                            <div id="sonic-result-text" class="text-cyan-400"></div>
                        </div>

                        <button onclick="decodeSonic()" id="btn-sonic-decode"
                            class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-3 rounded-lg transition-all flex items-center justify-center gap-2 mt-auto">
                            <i data-lucide="search" class="w-4 h-4"></i> Analyze Spectrum
                        </button>
                    </div>

                </div>
            </div>

        </div>
    </main>

    <!-- FOOTER -->
    <footer class="bg-black border-t border-zinc-900 py-12 mt-auto">
        <div class="container mx-auto px-4 text-center">
            <p class="text-zinc-400 font-medium">Designed & Developed by <span
                    class="text-rose-500 font-bold">MKD</span></p>
            <p class="text-xs text-zinc-600 flex items-center justify-center gap-1 mt-1">
                Made with <i data-lucide="heart" class="w-3 h-3 text-red-600 fill-current"></i> by Indian Developer
            </p>
            <p class="text-[10px] text-zinc-700 mt-2"> 2025 Link Postmortem. Secure Build.</p>
        </div>
    </footer>

    <script>
            // Immediate function definitions for modals
            (function () {
                function closeMemoryWarningNow() {
                    try {
                        const mw = document.getElementById('memory-warning-modal');
                        if (mw) {
                            mw.style.display = 'none';
                            mw.classList.add('hidden');
                            console.log('Memory warning dismissed');
                            return true;
                        }
                    } catch (e) {
                        console.error('Error:', e);
                    }
                    return false;
                }

                // Make available immediately
                window.closeMemoryWarning = closeMemoryWarningNow;

                // Also set up buttons immediately if they exist
                function setupButtons() {
                    const memoryBtn = document.getElementById('memory-warning-btn');
                    if (memoryBtn) {
                        memoryBtn.onclick = function () { closeMemoryWarningNow(); return false; };
                    }
                }

                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', setupButtons);
                } else {
                    setupButtons();
                }
            })();
    </script>

    <!-- FLOATING GHOST COMMS BUTTON -->
    <button onclick="openChatSelection()" id="ghost-float-btn"
        class="fixed bottom-6 right-6 w-16 h-16 bg-emerald-600 hover:bg-emerald-700 text-white rounded-full shadow-2xl shadow-emerald-900/50 hover:shadow-emerald-900/70 transition-all flex items-center justify-center z-50 group">
        <i data-lucide="message-square-lock" class="w-7 h-7 group-hover:scale-110 transition-transform"></i>
        <span
            class="absolute -top-1 -right-1 w-4 h-4 bg-rose-500 rounded-full border-2 border-black animate-pulse hidden"
            id="ghost-notification-dot"></span>
    </button>

    <!-- CHAT SELECTION POPUP MODAL -->
    <div id="chat-selection-modal"
        class="hidden fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/90 backdrop-blur-md">
        <div class="bg-zinc-900 border-2 border-emerald-600/50 rounded-2xl shadow-2xl w-full max-w-md p-8 animate-in">
            <div class="text-center mb-6">
                <div
                    class="w-16 h-16 bg-emerald-600/20 rounded-full flex items-center justify-center mx-auto mb-4 border border-emerald-600/30">
                    <i data-lucide="message-square-lock" class="w-8 h-8 text-emerald-400"></i>
                </div>
                <h2 class="text-2xl font-bold text-white mb-2">Ghost Comms</h2>
                <p class="text-sm text-zinc-400">Choose an option to continue</p>
            </div>

            <div class="space-y-4">
                <button onclick="showCreateRoom()" id="create-room-btn"
                    class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-4 px-6 rounded-xl transition-all flex items-center justify-center gap-3 shadow-lg shadow-emerald-900/30 hover:shadow-emerald-900/50 group">
                    <i data-lucide="plus-circle" class="w-5 h-5 group-hover:scale-110 transition-transform"></i>
                    <span>Create Chatroom</span>
                </button>

                <button onclick="showJoinRoom()" id="join-room-btn"
                    class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-4 px-6 rounded-xl transition-all flex items-center justify-center gap-3 border border-zinc-700 hover:border-zinc-600 group">
                    <i data-lucide="log-in" class="w-5 h-5 group-hover:scale-110 transition-transform"></i>
                    <span>Join Chatroom</span>
                </button>
            </div>

            <button onclick="closeChatSelection()"
                class="mt-6 w-full text-zinc-500 hover:text-zinc-300 text-sm transition-colors">
                Cancel
            </button>
        </div>
    </div>

    <!-- GHOST COMMS MODAL -->
    <div id="ghost-modal"
        class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm">
        <div
            class="bg-zinc-900 border border-zinc-800 rounded-2xl shadow-2xl w-full max-w-6xl max-h-[90vh] flex flex-col overflow-hidden">
            <!-- Modal Header -->
            <div class="bg-zinc-950 border-b border-zinc-800 px-6 py-4 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div
                        class="w-10 h-10 bg-emerald-600/20 rounded-full flex items-center justify-center border border-emerald-600/30">
                        <i data-lucide="message-square-lock" class="w-5 h-5 text-emerald-400"></i>
                    </div>
                    <div>
                        <h2 class="font-bold text-white">Ghost Comms</h2>
                        <p class="text-xs text-zinc-500">Zero-Knowledge Encrypted Chat</p>
                    </div>
                </div>
                <button onclick="closeGhostComms()" class="text-zinc-500 hover:text-white transition-colors">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>

            <!-- Modal Content -->
            <div class="flex-1 overflow-hidden flex flex-col md:flex-row">
                <!-- LEFT SIDE: Join/Create Room (Hidden when in room) -->
                <div id="ghost-join-panel"
                    class="w-full md:w-96 bg-zinc-950 border-r border-zinc-800 p-4 md:p-6 overflow-y-auto">
                    <div class="space-y-6">
                        <!-- Create Room Section -->
                        <div>
                            <div class="flex items-center gap-2 text-emerald-400 mb-4">
                                <i data-lucide="plus-circle" class="w-5 h-5"></i>
                                <h3 class="font-bold uppercase tracking-wider text-sm">Create Room</h3>
                            </div>

                            <div class="space-y-4">
                                <div>
                                    <label
                                        class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Master
                                        Key</label>
                                    <input type="password" id="ghost-master-key"
                                        placeholder="Enter master key to create room"
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none font-mono">
                                    <p class="text-[10px] text-zinc-600 mt-1">Key required to create new rooms</p>
                                </div>

                                <div>
                                    <label
                                        class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Room
                                        ID</label>
                                    <input type="text" id="ghost-room-id-create" placeholder="e.g., RedHawk"
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none font-mono">
                                </div>

                                <div>
                                    <label
                                        class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Room
                                        Password</label>
                                    <input type="password" id="ghost-password-create" placeholder="Room access password"
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none">
                                </div>

                                <div>
                                    <label
                                        class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Your
                                        Handle</label>
                                    <input type="text" id="ghost-handle-create" placeholder="Your Name"
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none">
                                </div>

                                <!-- Room Settings -->
                                <div class="bg-zinc-950/50 border border-zinc-800 rounded-lg p-4 space-y-3">
                                    <label class="text-xs font-bold text-zinc-400 uppercase tracking-wider block">Room
                                        Features</label>

                                    <label class="flex items-center gap-3 cursor-pointer group">
                                        <input type="checkbox" id="ghost-enable-download"
                                            class="w-4 h-4 rounded border-zinc-700 bg-zinc-900 text-emerald-600 focus:ring-emerald-600 focus:ring-offset-0 focus:ring-2">
                                        <div class="flex-1">
                                            <div class="text-sm text-zinc-300 group-hover:text-white transition-colors">
                                                Download Chat History</div>
                                            <div class="text-[10px] text-zinc-600">Allow participants to download chat
                                                history</div>
                                        </div>
                                    </label>

                                    <label class="flex items-center gap-3 cursor-pointer group">
                                        <input type="checkbox" id="ghost-enable-delete"
                                            class="w-4 h-4 rounded border-zinc-700 bg-zinc-900 text-emerald-600 focus:ring-emerald-600 focus:ring-offset-0 focus:ring-2">
                                        <div class="flex-1">
                                            <div class="text-sm text-zinc-300 group-hover:text-white transition-colors">
                                                Delete Messages</div>
                                            <div class="text-[10px] text-zinc-600">Allow participants to delete their
                                                messages (for everyone)</div>
                                        </div>
                                    </label>

                                    <label class="flex items-center gap-3 cursor-pointer group">
                                        <input type="checkbox" id="ghost-enable-gifs"
                                            class="w-4 h-4 rounded border-zinc-700 bg-zinc-900 text-emerald-600 focus:ring-emerald-600 focus:ring-offset-0 focus:ring-2">
                                        <div class="flex-1">
                                            <div class="text-sm text-zinc-300 group-hover:text-white transition-colors">
                                                Send GIFs</div>
                                            <div class="text-[10px] text-zinc-600">Allow participants to send GIF images
                                            </div>
                                        </div>
                                    </label>
                                </div>

                                <button onclick="createGhostRoom()" id="ghost-create-btn"
                                    class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 rounded-lg transition-all flex items-center justify-center gap-2 shadow-lg shadow-emerald-900/20">
                                    <i data-lucide="shield-check" class="w-4 h-4"></i> Create & Join Room
                                </button>
                            </div>
                        </div>

                        <div class="border-t border-zinc-800 pt-6">
                            <div class="flex items-center gap-2 text-zinc-400 mb-4">
                                <i data-lucide="link" class="w-5 h-5"></i>
                                <h3 class="font-bold uppercase tracking-wider text-sm">Join via Link</h3>
                            </div>

                            <div class="space-y-4">
                                <div>
                                    <label
                                        class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Room
                                        ID</label>
                                    <input type="text" id="ghost-room-id-join" placeholder="From shared link"
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none font-mono">
                                </div>

                                <div>
                                    <label
                                        class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Room
                                        Password</label>
                                    <input type="password" id="ghost-password-join" placeholder="From shared link"
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none">
                                </div>

                                <div>
                                    <label
                                        class="text-xs font-bold text-zinc-500 uppercase tracking-wider mb-2 block">Your
                                        Handle</label>
                                    <input type="text" id="ghost-handle-join" placeholder="Your Name"
                                        class="w-full bg-black border border-zinc-800 rounded-lg px-4 py-3 text-sm text-white focus:border-emerald-600 outline-none">
                                </div>

                                <button onclick="joinViaLink()" id="ghost-join-link-btn"
                                    class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-bold py-3 rounded-lg transition-all flex items-center justify-center gap-2">
                                    <i data-lucide="log-in" class="w-4 h-4"></i> Join Room
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- RIGHT SIDE: Chat Area -->
                <div class="flex-1 flex flex-col bg-zinc-900/50 min-w-0">
                    <!-- Chat Header -->
                    <div
                        class="bg-zinc-950 border-b border-zinc-800 px-4 md:px-6 py-3 md:py-4 flex items-center justify-between flex-shrink-0">
                        <div class="flex items-center gap-3">
                            <div
                                class="w-10 h-10 bg-emerald-600/20 rounded-full flex items-center justify-center border border-emerald-600/30">
                                <i data-lucide="shield-check" class="w-5 h-5 text-emerald-400"></i>
                            </div>
                            <div>
                                <h3 class="font-bold text-white text-sm" id="ghost-room-display">Not Connected</h3>
                                <p class="text-[10px] text-zinc-500" id="ghost-room-status">Join or create a room to
                                    start</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-3">
                            <div class="relative" id="call-button-container">
                                <button onclick="toggleCallOptions()" id="ghost-call-btn"
                                    class="hidden text-xs bg-cyan-600 hover:bg-cyan-700 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-all">
                                    <i data-lucide="phone" class="w-4 h-4"></i> Call
                                </button>
                                <!-- Call Mode Selection Popup -->
                                <div id="call-options-popup"
                                    class="hidden absolute top-full left-0 md:left-auto md:right-0 mt-2 bg-zinc-900 border border-cyan-600 rounded-xl shadow-2xl overflow-hidden z-50 w-[200px] md:min-w-[180px]">
                                    <div class="p-3 border-b border-zinc-700 text-center bg-zinc-800/50">
                                        <span class="text-xs text-cyan-400 font-bold uppercase tracking-wider">Start
                                            Call</span>
                                    </div>
                                    <button onclick="startCallWithMode('audio')"
                                        class="w-full px-4 py-4 flex items-center gap-4 hover:bg-cyan-900/30 transition-colors text-left active:bg-cyan-900/50">
                                        <div
                                            class="w-10 h-10 bg-emerald-600/20 rounded-full flex items-center justify-center">
                                            <i data-lucide="mic" class="w-5 h-5 text-emerald-400"></i>
                                        </div>
                                        <div>
                                            <div class="text-white font-medium text-sm">Voice Call</div>
                                            <div class="text-zinc-500 text-[11px]">Audio only</div>
                                        </div>
                                    </button>
                                    <button onclick="startCallWithMode('video')"
                                        class="w-full px-4 py-4 flex items-center gap-4 hover:bg-cyan-900/30 transition-colors text-left border-t border-zinc-800 active:bg-cyan-900/50">
                                        <div
                                            class="w-10 h-10 bg-cyan-600/20 rounded-full flex items-center justify-center">
                                            <i data-lucide="video" class="w-5 h-5 text-cyan-400"></i>
                                        </div>
                                        <div>
                                            <div class="text-white font-medium text-sm">Video Call</div>
                                            <div class="text-zinc-500 text-[11px]">Camera + Audio</div>
                                        </div>
                                    </button>
                                    <button onclick="startCallWithMode('screen')"
                                        class="hidden md:flex w-full px-4 py-4 items-center gap-4 hover:bg-cyan-900/30 transition-colors text-left border-t border-zinc-800 active:bg-cyan-900/50">
                                        <div
                                            class="w-10 h-10 bg-purple-600/20 rounded-full flex items-center justify-center">
                                            <i data-lucide="monitor" class="w-5 h-5 text-purple-400"></i>
                                        </div>
                                        <div>
                                            <div class="text-white font-medium text-sm">Screen Share</div>
                                            <div class="text-zinc-500 text-[11px]">Share screen</div>
                                        </div>
                                    </button>
                                </div>
                            </div>
                            <button onclick="copyRoomLink()" id="ghost-share-btn"
                                class="hidden text-xs bg-zinc-800 hover:bg-zinc-700 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-all">
                                <i data-lucide="share-2" class="w-4 h-4"></i> Share Link
                            </button>
                            <button onclick="disconnectGhostWithCleanup()" id="ghost-disconnect-btn"
                                class="hidden text-xs text-rose-500 hover:text-rose-400 transition-colors">
                                <i data-lucide="log-out" class="w-4 h-4"></i> Leave
                            </button>
                            <div id="ghost-encryption-indicator" class="w-2 h-2 rounded-full bg-zinc-700"></div>
                            <span class="text-[10px] text-zinc-500 font-mono">E2E</span>
                        </div>
                    </div>

                    <!-- Messages Container -->
                    <div id="ghost-messages"
                        class="flex-1 min-h-[400px] overflow-y-auto bg-gradient-to-b from-zinc-950 via-zinc-900/50 to-zinc-950 p-4 md:p-6 space-y-4"
                        style="overflow-y: auto; overflow-x: hidden; scroll-behavior: smooth;">
                        <div class="text-center text-zinc-600 text-sm py-12">
                            <div
                                class="w-16 h-16 bg-emerald-600/10 rounded-full flex items-center justify-center mx-auto mb-3 border border-emerald-600/20">
                                <i data-lucide="message-square-lock" class="w-8 h-8 text-emerald-500/50"></i>
                            </div>
                            <p class="font-medium">Join or create a room to start messaging</p>
                            <p class="text-xs text-zinc-700 mt-1">Messages are end-to-end encrypted</p>
                        </div>
                    </div>

                    <!-- Input Area -->
                    <div class="bg-zinc-950 border-t border-zinc-800 p-3 md:p-4 flex-shrink-0">
                        <div class="flex items-end gap-3">
                            <!-- Emoji Picker Button -->
                            <button onclick="toggleEmojiPicker()" id="ghost-emoji-btn"
                                class="w-11 h-11 flex-shrink-0 bg-zinc-800 hover:bg-zinc-700 disabled:bg-zinc-900 disabled:text-zinc-700 text-zinc-400 rounded-full transition-all flex items-center justify-center disabled:cursor-not-allowed"
                                disabled>
                                <i data-lucide="smile" class="w-5 h-5"></i>
                            </button>

                            <!-- GIF Picker Button (if enabled) -->
                            <button onclick="toggleGifPicker()" id="ghost-gif-btn"
                                class="hidden w-11 h-11 flex-shrink-0 bg-zinc-800 hover:bg-zinc-700 disabled:bg-zinc-900 disabled:text-zinc-700 text-zinc-400 rounded-full transition-all flex items-center justify-center disabled:cursor-not-allowed"
                                disabled>
                                <i data-lucide="image" class="w-5 h-5"></i>
                            </button>

                            <!-- Audio Record Button -->
                            <button onclick="toggleAudioRecord()" id="ghost-audio-btn"
                                class="w-11 h-11 flex-shrink-0 bg-zinc-800 hover:bg-zinc-700 disabled:bg-zinc-900 disabled:text-zinc-700 text-zinc-400 rounded-full transition-all flex items-center justify-center disabled:cursor-not-allowed"
                                disabled>
                                <i data-lucide="mic" class="w-5 h-5"></i>
                            </button>

                            <!-- Hidden file input for GIF upload -->
                            <input type="file" id="ghost-gif-upload" accept="image/gif,video/*" style="display: none;"
                                onchange="handleGifUpload(event)">

                            <div class="flex-1 relative min-w-0">
                                <textarea id="ghost-message-input" placeholder="Type a message..."
                                    class="w-full bg-zinc-900 border border-zinc-800 rounded-2xl px-4 py-3 pl-4 pr-14 text-sm text-white focus:border-emerald-600 focus:ring-2 focus:ring-emerald-600/20 outline-none resize-none min-h-[48px] max-h-[200px] placeholder:text-zinc-600"
                                    disabled rows="1"></textarea>

                                <!-- Send Button - Properly positioned -->
                                <button onclick="sendGhostMessage()" id="ghost-send-btn"
                                    class="absolute right-2 bottom-2 w-9 h-9 bg-emerald-600 hover:bg-emerald-700 disabled:bg-zinc-800 disabled:text-zinc-600 text-white rounded-full transition-all flex items-center justify-center shadow-lg hover:shadow-emerald-600/50 disabled:shadow-none disabled:cursor-not-allowed"
                                    disabled>
                                    <i data-lucide="send" class="w-4 h-4"></i>
                                </button>

                                <!-- Emoji Picker Popup -->
                                <div id="ghost-emoji-picker"
                                    class="hidden absolute bottom-full left-0 mb-2 bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-[340px] max-h-[400px] flex flex-col z-50">
                                    <!-- Category Tabs -->
                                    <div class="flex gap-1 p-2 border-b border-zinc-800 overflow-x-auto flex-shrink-0">
                                        <button onclick="loadEmojiCategory('smileys')" id="emoji-tab-smileys"
                                            class="px-2 py-1 text-lg rounded bg-emerald-600" title="Smileys"></button>
                                        <button onclick="loadEmojiCategory('gestures')" id="emoji-tab-gestures"
                                            class="px-2 py-1 text-lg rounded hover:bg-zinc-800"
                                            title="Gestures"></button>
                                        <button onclick="loadEmojiCategory('hearts')" id="emoji-tab-hearts"
                                            class="px-2 py-1 text-lg rounded hover:bg-zinc-800"
                                            title="Hearts"></button>
                                        <button onclick="loadEmojiCategory('celebration')" id="emoji-tab-celebration"
                                            class="px-2 py-1 text-lg rounded hover:bg-zinc-800"
                                            title="Celebration"></button>
                                        <button onclick="loadEmojiCategory('symbols')" id="emoji-tab-symbols"
                                            class="px-2 py-1 text-lg rounded hover:bg-zinc-800"
                                            title="Symbols"></button>
                                        <button onclick="loadEmojiCategory('animals')" id="emoji-tab-animals"
                                            class="px-2 py-1 text-lg rounded hover:bg-zinc-800"
                                            title="Animals"></button>
                                        <button onclick="loadEmojiCategory('food')" id="emoji-tab-food"
                                            class="px-2 py-1 text-lg rounded hover:bg-zinc-800" title="Food"></button>
                                        <button onclick="loadEmojiCategory('activities')" id="emoji-tab-activities"
                                            class="px-2 py-1 text-lg rounded hover:bg-zinc-800"
                                            title="Activities"></button>
                                    </div>
                                    <!-- Emoji Grid -->
                                    <div class="overflow-y-auto p-2 flex-1">
                                        <div class="grid grid-cols-8 gap-1" id="ghost-emoji-grid"></div>
                                    </div>
                                </div>

                                <!-- GIF Picker Popup -->
                                <div id="ghost-gif-picker"
                                    class="hidden absolute bottom-full left-0 mb-2 bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-[400px] max-h-[500px] flex flex-col z-50">
                                    <!-- Search Bar -->
                                    <div class="p-3 border-b border-zinc-800">
                                        <div class="relative">
                                            <input type="text" id="ghost-gif-search" placeholder="Search GIFs..."
                                                class="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 pl-10 text-sm text-white placeholder:text-zinc-600 outline-none focus:border-emerald-600">
                                            <i data-lucide="search"
                                                class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-zinc-500"></i>
                                        </div>
                                    </div>

                                    <!-- Categories/Tabs -->
                                    <div class="flex gap-2 px-3 py-2 border-b border-zinc-800 overflow-x-auto">
                                        <button onclick="loadGifCategory('trending')" id="gif-tab-trending"
                                            class="px-3 py-1.5 text-xs font-medium rounded-lg bg-emerald-600 text-white whitespace-nowrap">Trending</button>
                                        <button onclick="loadGifCategory('reactions')" id="gif-tab-reactions"
                                            class="px-3 py-1.5 text-xs font-medium rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 whitespace-nowrap">Reactions</button>
                                        <button onclick="loadGifCategory('funny')" id="gif-tab-funny"
                                            class="px-3 py-1.5 text-xs font-medium rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 whitespace-nowrap">Funny</button>
                                        <button onclick="loadGifCategory('love')" id="gif-tab-love"
                                            class="px-3 py-1.5 text-xs font-medium rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 whitespace-nowrap">Love</button>
                                    </div>

                                    <!-- GIF Grid -->
                                    <div id="ghost-gif-results" class="flex-1 overflow-y-auto p-3">
                                        <div class="grid grid-cols-2 gap-2" id="ghost-gif-grid"></div>
                                        <div id="ghost-gif-loading" class="hidden text-center py-8">
                                            <i data-lucide="loader-2"
                                                class="w-6 h-6 animate-spin text-emerald-500 mx-auto"></i>
                                            <p class="text-xs text-zinc-500 mt-2">Loading GIFs...</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="mt-2 flex items-center justify-between">
                            <div class="flex items-center gap-3">
                                <p class="text-[10px] text-zinc-700 font-mono"> Encrypted with AES-GCM</p>
                                <button onclick="downloadChatHistory()" id="ghost-download-btn"
                                    class="hidden text-[10px] text-emerald-500 hover:text-emerald-400 transition-colors flex items-center gap-1">
                                    <i data-lucide="download" class="w-3 h-3"></i> Download History
                                </button>
                                <button onclick="toggleChaosMode()" id="ghost-chaos-btn"
                                    class="hidden text-[10px] text-rose-500 hover:text-rose-400 transition-colors flex items-center gap-1">
                                    <i data-lucide="zap" class="w-3 h-3"></i> Gravity
                                </button>
                                <button onclick="toggleSonicPulse()" id="ghost-sonic-btn"
                                    class="hidden text-[10px] text-cyan-500 hover:text-cyan-400 transition-colors flex items-center gap-1">
                                    <i data-lucide="radio" class="w-3 h-3"></i> Visualize
                                </button>
                            </div>
                            <p class="text-[10px] text-zinc-700" id="ghost-char-count">0</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- SECURITY BREACH MODAL -->
    <div id="security-breach-modal"
        class="hidden fixed inset-0 z-[10000] flex items-center justify-center p-4 bg-black/95 backdrop-blur-sm">
        <div class="breach-warning rounded-2xl p-8 max-w-md text-center shadow-2xl">
            <div class="mb-6">
                <div
                    class="w-20 h-20 bg-red-600 rounded-full flex items-center justify-center mx-auto mb-4 animate-pulse">
                    <i data-lucide="shield-alert" class="w-10 h-10 text-white"></i>
                </div>
                <h2 class="text-3xl font-black text-white mb-2 tracking-wider">UNAUTHORIZED ACCESS</h2>
                <h3 class="text-xl font-bold text-red-200 mb-4">SYSTEM COMPROMISED</h3>
                <p class="text-red-100 text-sm">Intrusion detected. Security protocols activated.</p>
            </div>
            <button onclick="closeBreachModal()"
                class="bg-white text-red-600 font-bold px-8 py-3 rounded-lg hover:bg-red-50 transition-colors">
                ACKNOWLEDGE
            </button>
        </div>
    </div>

    <!-- INCOMING CALL MODAL (The Uplink) -->
    <div id="incoming-call-modal"
        class="hidden fixed inset-0 z-[10001] flex items-center justify-center p-4 bg-black/95 backdrop-blur-sm">
        <div class="bg-zinc-900 border-2 border-cyan-600 rounded-2xl p-8 max-w-md text-center shadow-2xl">
            <div class="mb-6">
                <div
                    class="w-20 h-20 bg-cyan-600/20 rounded-full flex items-center justify-center mx-auto mb-4 animate-pulse">
                    <i data-lucide="phone-incoming" class="w-10 h-10 text-cyan-500"></i>
                </div>
                <h2 class="text-2xl font-black text-white mb-2 tracking-wider">INCOMING TRANSMISSION...</h2>
                <p class="text-cyan-300 text-sm" id="caller-name-display">Unknown Caller</p>
            </div>
            <div class="flex gap-4 justify-center">
                <button onclick="acceptCall()" id="accept-call-btn"
                    class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold px-8 py-3 rounded-lg transition-colors flex items-center gap-2">
                    <i data-lucide="phone" class="w-5 h-5"></i> ACCEPT
                </button>
                <button onclick="denyCall()" id="deny-call-btn"
                    class="bg-red-600 hover:bg-red-700 text-white font-bold px-8 py-3 rounded-lg transition-colors flex items-center gap-2">
                    <i data-lucide="phone-off" class="w-5 h-5"></i> DENY
                </button>
            </div>
        </div>
    </div>

    <!-- FULL-SCREEN VIDEO CALL WINDOW (The Uplink v2) -->
    <div id="video-call-window" class="hidden fixed inset-0 z-[10000] bg-black flex flex-col">
        <!-- Mode Badge -->
        <div class="absolute top-4 left-4 z-10 flex items-center gap-3">
            <div
                class="flex items-center gap-2 bg-zinc-900/80 backdrop-blur-sm border border-cyan-600 rounded-lg px-3 py-2">
                <div class="w-2 h-2 bg-emerald-500 rounded-full animate-pulse"></div>
                <span id="call-mode-badge" class="text-xs font-bold text-cyan-400 uppercase tracking-wider">VOICE
                    CALL</span>
                <div id="call-timer" class="text-xs text-zinc-400 font-mono ml-2">00:00</div>
            </div>
        </div>

        <!-- Close/Minimize Button -->
        <button onclick="minimizeCallWindow()"
            class="absolute top-4 right-4 z-10 bg-zinc-800/80 hover:bg-zinc-700 p-2 rounded-lg transition-colors">
            <i data-lucide="minimize-2" class="w-4 h-4 text-white"></i>
        </button>

        <!-- Remote Video (Main Stage) -->
        <div class="flex-1 relative flex items-center justify-center overflow-hidden">
            <video id="remote-video" autoplay playsinline class="w-full h-full object-contain"></video>

            <!-- Waiting/Audio-Only Placeholder -->
            <div id="video-placeholder"
                class="absolute inset-0 flex flex-col items-center justify-center bg-gradient-to-br from-zinc-900 via-zinc-950 to-black">
                <div
                    class="w-24 h-24 bg-cyan-600/20 rounded-full flex items-center justify-center mb-4 border-2 border-cyan-600/30">
                    <i data-lucide="radio" class="w-12 h-12 text-cyan-500"></i>
                </div>
                <div id="placeholder-text" class="text-cyan-400 font-bold text-lg animate-pulse">AWAITING
                    TRANSMISSION...</div>
                <div class="flex items-center gap-1 mt-4">
                    <div class="w-2 h-2 bg-cyan-500 rounded-full animate-bounce" style="animation-delay: 0s;"></div>
                    <div class="w-2 h-2 bg-cyan-500 rounded-full animate-bounce" style="animation-delay: 0.1s;"></div>
                    <div class="w-2 h-2 bg-cyan-500 rounded-full animate-bounce" style="animation-delay: 0.2s;"></div>
                </div>
            </div>
        </div>

        <!-- Local Video (PIP - Picture in Picture) -->
        <video id="local-video" autoplay playsinline muted
            class="absolute bottom-24 right-4 w-32 h-24 md:w-48 md:h-36 rounded-xl border-2 border-cyan-500 object-cover shadow-2xl z-10 bg-zinc-900"></video>

        <!-- Camera Off Indicator (shows when camera is disabled) -->
        <div id="local-camera-off"
            class="hidden absolute bottom-24 right-4 w-32 h-24 md:w-48 md:h-36 rounded-xl border-2 border-zinc-600 bg-zinc-900 flex items-center justify-center z-10">
            <div class="text-center">
                <i data-lucide="video-off" class="w-8 h-8 text-zinc-500 mx-auto"></i>
                <span class="text-[10px] text-zinc-500 block mt-1">Camera Off</span>
            </div>
        </div>

        <!-- Control Bar -->
        <div class="absolute bottom-2 md:bottom-4 left-1/2 -translate-x-1/2 z-20 w-full px-2 md:px-0 md:w-auto">
            <div
                class="flex items-center justify-center gap-3 md:gap-4 bg-zinc-900/95 backdrop-blur-sm border border-zinc-700 rounded-2xl px-3 md:px-6 py-2 md:py-3">
                <!-- Mute Button -->
                <button onclick="toggleMute()" id="vc-mute-btn"
                    class="flex flex-col items-center gap-1 p-2 md:p-3 bg-zinc-700 hover:bg-zinc-600 rounded-xl transition-all min-w-[50px] md:min-w-[60px]">
                    <i data-lucide="mic" class="w-5 h-5 md:w-6 md:h-6 text-white" id="vc-mute-icon"></i>
                    <span class="text-[8px] md:text-[10px] text-zinc-300">Mute</span>
                </button>

                <!-- Camera Toggle Button -->
                <button onclick="toggleCamera()" id="vc-camera-btn"
                    class="flex flex-col items-center gap-1 p-2 md:p-3 bg-zinc-700 hover:bg-zinc-600 rounded-xl transition-all min-w-[50px] md:min-w-[60px]">
                    <i data-lucide="video" class="w-5 h-5 md:w-6 md:h-6 text-white" id="vc-camera-icon"></i>
                    <span class="text-[8px] md:text-[10px] text-zinc-300">Camera</span>
                </button>

                <!-- Screen Share Button (hidden on mobile - not supported well) -->
                <button onclick="toggleScreenShare()" id="vc-screen-btn"
                    class="hidden md:flex flex-col items-center gap-1 p-2 md:p-3 bg-zinc-700 hover:bg-zinc-600 rounded-xl transition-all min-w-[50px] md:min-w-[60px]">
                    <i data-lucide="monitor" class="w-5 h-5 md:w-6 md:h-6 text-white" id="vc-screen-icon"></i>
                    <span class="text-[8px] md:text-[10px] text-zinc-300">Screen</span>
                </button>

                <!-- Mode Switch Button -->
                <button onclick="openModeSwitcher()" id="vc-mode-btn"
                    class="flex flex-col items-center gap-1 p-2 md:p-3 bg-cyan-700 hover:bg-cyan-600 rounded-xl transition-all min-w-[50px] md:min-w-[60px]">
                    <i data-lucide="repeat" class="w-5 h-5 md:w-6 md:h-6 text-white"></i>
                    <span class="text-[8px] md:text-[10px] text-zinc-300">Switch</span>
                </button>

                <!-- End Call Button -->
                <button onclick="hangupCall()" id="vc-end-btn"
                    class="flex flex-col items-center gap-1 p-2 md:p-3 bg-red-600 hover:bg-red-700 rounded-xl transition-all min-w-[50px] md:min-w-[60px] shadow-lg shadow-red-900/50">
                    <i data-lucide="phone-off" class="w-5 h-5 md:w-6 md:h-6 text-white"></i>
                    <span class="text-[8px] md:text-[10px] text-white">End</span>
                </button>
            </div>
        </div>

        <!-- Mode Switcher Popup -->
        <div id="mode-switcher-popup"
            class="hidden absolute bottom-28 left-1/2 -translate-x-1/2 z-30 bg-zinc-900 border border-cyan-600 rounded-xl shadow-2xl overflow-hidden">
            <div class="p-2 border-b border-zinc-700 text-center">
                <span class="text-xs text-cyan-400 font-bold uppercase">Switch Mode</span>
            </div>
            <div class="flex gap-1 p-2">
                <button onclick="switchCallMode('audio')"
                    class="flex flex-col items-center gap-1 px-4 py-2 rounded-lg hover:bg-zinc-800 transition-colors">
                    <i data-lucide="mic" class="w-6 h-6 text-emerald-400"></i>
                    <span class="text-[10px] text-zinc-400">Voice</span>
                </button>
                <button onclick="switchCallMode('video')"
                    class="flex flex-col items-center gap-1 px-4 py-2 rounded-lg hover:bg-zinc-800 transition-colors">
                    <i data-lucide="video" class="w-6 h-6 text-cyan-400"></i>
                    <span class="text-[10px] text-zinc-400">Video</span>
                </button>
                <button onclick="switchCallMode('screen')"
                    class="flex flex-col items-center gap-1 px-4 py-2 rounded-lg hover:bg-zinc-800 transition-colors">
                    <i data-lucide="monitor" class="w-6 h-6 text-purple-400"></i>
                    <span class="text-[10px] text-zinc-400">Screen</span>
                </button>
            </div>
        </div>
    </div>

    <!-- MINIMIZED CALL BAR (for audio-only or minimized calls) -->
    <div id="active-call-interface"
        class="hidden fixed top-2 left-2 right-2 md:left-1/2 md:right-auto md:-translate-x-1/2 md:w-auto z-[10000] bg-zinc-900/95 backdrop-blur-sm border-2 border-cyan-600 rounded-xl px-3 py-2 md:px-6 md:py-4 shadow-2xl">
        <div class="flex items-center justify-between md:justify-start gap-2 md:gap-4">
            <!-- Left: Status -->
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 md:w-3 md:h-3 bg-emerald-500 rounded-full animate-pulse"></div>
                <span id="mini-call-mode" class="text-[10px] md:text-sm font-bold text-cyan-400 uppercase">VOICE</span>
            </div>

            <!-- Right: Control Buttons -->
            <div class="flex items-center gap-1 md:gap-2">
                <!-- Expand Button -->
                <button onclick="expandCallWindow()" title="Expand"
                    class="w-9 h-9 md:w-10 md:h-10 bg-cyan-700 hover:bg-cyan-600 text-white rounded-full flex items-center justify-center transition-colors">
                    <i data-lucide="maximize-2" class="w-4 h-4"></i>
                </button>
                <!-- Video Toggle -->
                <button onclick="switchCallMode('video')" id="mini-video-btn" title="Video"
                    class="w-9 h-9 md:w-10 md:h-10 bg-zinc-700 hover:bg-zinc-600 text-white rounded-full flex items-center justify-center transition-colors">
                    <i data-lucide="video" class="w-4 h-4"></i>
                </button>
                <!-- Screen Share -->
                <button onclick="toggleScreenShare()" id="mini-screen-btn" title="Screen Share"
                    class="hidden md:flex w-9 h-9 md:w-10 md:h-10 bg-zinc-700 hover:bg-zinc-600 text-white rounded-full items-center justify-center transition-colors">
                    <i data-lucide="monitor" class="w-4 h-4"></i>
                </button>
                <!-- Mute Button -->
                <button onclick="toggleMute()" id="mute-btn" title="Mute"
                    class="w-9 h-9 md:w-10 md:h-10 bg-zinc-700 hover:bg-zinc-600 text-white rounded-full flex items-center justify-center transition-colors">
                    <i data-lucide="mic" class="w-4 h-4" id="mute-icon"></i>
                </button>
                <!-- Hang Up Button -->
                <button onclick="hangupCall()" id="hangup-btn" title="End Call"
                    class="w-10 h-10 md:w-11 md:h-11 bg-red-600 hover:bg-red-700 text-white rounded-full flex items-center justify-center transition-colors shadow-lg">
                    <i data-lucide="phone-off" class="w-4 h-4 md:w-5 md:h-5"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- MEMORY WARNING MODAL -->
    <div id="memory-warning-modal"
        class="hidden fixed inset-0 z-[10000] flex items-center justify-center p-4 bg-black/90 backdrop-blur-sm"
        style="pointer-events: auto;">
        <div class="bg-zinc-900 border-2 border-amber-600 rounded-2xl p-8 max-w-md text-center shadow-2xl"
            style="pointer-events: auto;">
            <div class="mb-6">
                <div class="w-16 h-16 bg-amber-600/20 rounded-full flex items-center justify-center mx-auto mb-4">
                    <i data-lucide="eye" class="w-8 h-8 text-amber-500"></i>
                </div>
                <h2 class="text-2xl font-black text-white mb-2">I REMEMBER YOU</h2>
                <p class="text-zinc-300 mb-2">You tried to break me last time.</p>
                <p class="text-amber-400 font-bold" id="memory-warning-text">Don't try it again.</p>
            </div>
            <button type="button" id="memory-warning-btn"
                onclick="if(typeof closeMemoryWarning === 'function') { closeMemoryWarning(); } else { const mw = document.getElementById('memory-warning-modal'); if(mw) { mw.style.display = 'none'; mw.classList.add('hidden'); } } return false;"
                class="bg-amber-600 text-white font-bold px-8 py-3 rounded-lg hover:bg-amber-700 transition-colors cursor-pointer"
                style="pointer-events: auto; z-index: 10001;">
                PROCEED WITH CAUTION
            </button>
        </div>
    </div>

    <!-- LOGIC -->
    <script>
        // ============================================
        // HACKER TRAP - DEFENSE & MEMORY SYSTEM
        // ============================================
        let breachDetected = false;
        let breachAudio = null;

        // Initialize breach audio
        function initBreachAudio() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.warn('Audio not available');
            }
        }


        // ============================================
        // SELF-DEFENDING WEBSITE SYSTEM
        // ============================================
        // CONFIGURATION
        const SECURITY_KEY = "endeavour_security_log"; // The name in browser memory

        // Caution Board removed - no longer needed

        // Memory Warning Modal Functions
        function closeMemoryWarning() {
            try {
                const modal = document.getElementById('memory-warning-modal');
                if (modal) {
                    modal.classList.add('hidden');
                    modal.style.display = 'none';
                    console.log('Memory warning dismissed');
                    return true;
                }
            } catch (e) {
                console.error('Error closing memory warning:', e);
            }
            return false;
        }

        // Make closeMemoryWarning globally available
        window.closeMemoryWarning = closeMemoryWarning;

        // 1. THE MEMORY CHECK (Runs immediately on load)
        window.addEventListener('DOMContentLoaded', function () {
            checkMemory();

            // Set up memory warning button click handler
            const memoryWarningBtn = document.getElementById('memory-warning-btn');
            if (memoryWarningBtn) {
                memoryWarningBtn.onclick = function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    if (typeof closeMemoryWarning === 'function') {
                        closeMemoryWarning();
                    } else {
                        // Fallback if function not available
                        const mw = document.getElementById('memory-warning-modal');
                        if (mw) {
                            mw.style.display = 'none';
                            mw.classList.add('hidden');
                        }
                    }
                    return false;
                };

                // Also add event listener as backup
                memoryWarningBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof closeMemoryWarning === 'function') {
                        closeMemoryWarning();
                    } else {
                        const mw = document.getElementById('memory-warning-modal');
                        if (mw) {
                            mw.style.display = 'none';
                            mw.classList.add('hidden');
                        }
                    }
                }, true);
            }

            // Caution board removed - no longer showing
        });

        // 2. ENHANCED TRAP WITH REASON TRACKING & FIRESTORE LOGGING
        async function triggerSecurityBreach(reason) {
            // Prevent multiple rapid triggers (debounce)
            const now = Date.now();
            const lastTrigger = parseInt(localStorage.getItem('last_breach_trigger') || '0');
            if (now - lastTrigger < 2000) return;

            localStorage.setItem('last_breach_trigger', now.toString());

            if (breachDetected) {
                document.body.classList.add('system-breach');
                setTimeout(() => {
                    document.body.classList.remove('system-breach');
                }, 3000);
                return;
            }

            breachDetected = true;

            // Store breach in memory with reason
            localStorage.setItem(SECURITY_KEY, "breached");
            localStorage.setItem('security_breach', 'level_1');
            localStorage.setItem('breach_timestamp', Date.now().toString());
            localStorage.setItem('breach_count', (parseInt(localStorage.getItem('breach_count') || '0') + 1).toString());
            localStorage.setItem('breach_reason', reason);

            // Log to Firestore (The Sentinel - Evidence Collection)
            try {
                if (window.firebaseDB && window.firebaseAddDoc && window.firebaseCollection && window.firebaseServerTimestamp) {
                    await window.firebaseAddDoc(
                        window.firebaseCollection(window.firebaseDB, 'security_logs'),
                        {
                            ip: 'anonymous', // Could be enhanced with actual IP detection
                            timestamp: window.firebaseServerTimestamp(),
                            violationType: reason,
                            userAgent: navigator.userAgent,
                            url: window.location.href,
                            breachCount: parseInt(localStorage.getItem('breach_count') || '0')
                        }
                    );
                }
            } catch (error) {
                console.warn('Firestore logging failed:', error);
            }

            // A. Visual Chaos
            document.body.classList.add('system-breach');

            // B. Create/Show the Overlay Warning
            let overlay = document.getElementById('glitch-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'glitch-overlay';
                overlay.className = 'glitch-overlay';
                document.body.appendChild(overlay);
            }
            overlay.style.display = 'block';
            overlay.innerHTML = `
                <h1 style="color: red; font-size: 3rem; margin-bottom: 20px;"> INTRUSION DETECTED </h1>
                <p style="color: #ff4444; font-size: 1.5rem; margin: 10px 0;">UNAUTHORIZED ACCESS DETECTED</p>
                <p style="color: #ff6666; font-size: 1.2rem; margin: 10px 0;">${reason}</p>
                <p style="color: #ff8888; font-size: 1rem; margin: 20px 0;">YOUR IP HAS BEEN LOGGED.</p>
                <p style="color: #ffaaaa; font-size: 1rem;">DO NOT RESIST.</p>
                <button onclick="closeGlitchOverlay()" style="margin-top: 30px; padding: 15px 30px; background: red; color: white; border: none; font-size: 1rem; cursor: pointer; border-radius: 5px;">ACKNOWLEDGE</button>
            `;

            // C. Play Sound
            initBreachAudio();

            // D. Console scare
            console.clear();
            console.log("%c STOP! ", "color: red; font-size: 50px; font-weight: bold;");
            console.log("%c System has recorded your intrusion attempt.", "color: red; font-size: 16px;");
            console.log("%c Reason: " + reason, "color: orange; font-size: 14px;");

            // Remove glitch after 5 seconds
            setTimeout(() => {
                document.body.classList.remove('system-breach');
                breachDetected = false;
            }, 5000);
        }

        function closeGlitchOverlay() {
            const overlay = document.getElementById('glitch-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            document.body.classList.remove('system-breach');
        }

        // Update checkMemory to use new security key
        function checkMemory() {
            const breach = localStorage.getItem(SECURITY_KEY) || localStorage.getItem('security_breach');
            const breachCount = parseInt(localStorage.getItem('breach_count') || '0');

            if (breach === 'level_1' || breach === 'breached') {
                // Show memory warning with breach count
                setTimeout(() => {
                    const modal = document.getElementById('memory-warning-modal');
                    if (modal) {
                        const warningText = document.getElementById('memory-warning-text');
                        if (warningText && breachCount > 1) {
                            warningText.innerHTML = `You tried to break me ${breachCount} time${breachCount > 1 ? 's' : ''} before.<br><span class="text-amber-400 font-bold">DO NOT ATTEMPT TO BREACH ME AGAIN.</span>`;
                        } else if (warningText) {
                            warningText.innerHTML = 'DO NOT ATTEMPT TO BREACH ME AGAIN.';
                        }
                        modal.classList.remove('hidden');
                    }
                }, 1500);
            }
        }

        // Right-click counter for breach detection
        let rightClickCount = 0;
        let rightClickResetTimeout = null;
        const RIGHT_CLICK_THRESHOLD = 10;

        // Update trigger functions to use new system
        document.addEventListener('contextmenu', function (e) {
            // Check if clicking on memory warning modal - allow dismiss
            const memoryModal = document.getElementById('memory-warning-modal');
            if (memoryModal && !memoryModal.classList.contains('hidden') && window.getComputedStyle(memoryModal).display !== 'none') {
                // Right-click on memory modal dismisses it
                if (typeof closeMemoryWarning === 'function') {
                    closeMemoryWarning();
                }
                e.preventDefault();
                e.stopPropagation();
                return false;
            }

            // Increment right-click counter
            rightClickCount++;

            // Reset counter after 3 seconds of no right-clicks
            if (rightClickResetTimeout) {
                clearTimeout(rightClickResetTimeout);
            }
            rightClickResetTimeout = setTimeout(() => {
                rightClickCount = 0;
            }, 3000);

            // Only trigger breach after 10 consecutive right-clicks
            if (rightClickCount >= RIGHT_CLICK_THRESHOLD) {
                triggerSecurityBreach("Right Click Attempt (10+ times)");
                rightClickCount = 0; // Reset after triggering
            }

            // Always prevent right-click menu (but don't trigger breach until threshold)
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
        }, true);

        document.addEventListener('keydown', function (e) {
            let shouldTrigger = false;
            let reason = '';

            if (e.keyCode == 123 || e.key === 'F12') {
                shouldTrigger = true;
                reason = "F12 Inspector Tool";
            }
            else if (e.ctrlKey && e.shiftKey && (e.keyCode == 'I'.charCodeAt(0) || e.key === 'I' || e.key === 'i')) {
                shouldTrigger = true;
                reason = "DevTools Shortcut (Ctrl+Shift+I)";
            }
            else if (e.ctrlKey && e.shiftKey && (e.keyCode == 'C'.charCodeAt(0) || e.key === 'C' || e.key === 'c')) {
                shouldTrigger = true;
                reason = "Inspect Element Shortcut (Ctrl+Shift+C)";
            }
            else if (e.ctrlKey && e.shiftKey && (e.keyCode == 'J'.charCodeAt(0) || e.key === 'J' || e.key === 'j')) {
                shouldTrigger = true;
                reason = "Console Shortcut (Ctrl+Shift+J)";
            }
            else if (e.ctrlKey && (e.keyCode == 'U'.charCodeAt(0) || e.key === 'U' || e.key === 'u')) {
                shouldTrigger = true;
                reason = "Source Code Theft Attempt (Ctrl+U)";
            }
            else if (e.ctrlKey && e.shiftKey && (e.keyCode == 'K'.charCodeAt(0) || e.key === 'K' || e.key === 'k')) {
                shouldTrigger = true;
                reason = "Firefox Console Shortcut";
            }
            else if (e.ctrlKey && e.shiftKey && (e.keyCode == 'E'.charCodeAt(0) || e.key === 'E' || e.key === 'e')) {
                shouldTrigger = true;
                reason = "Chrome Network Panel";
            }

            if (shouldTrigger) {
                triggerSecurityBreach(reason);
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }
        }, true);

        // Backup prevention
        document.onkeydown = function (e) {
            if (e.keyCode == 123 ||
                (e.ctrlKey && e.shiftKey && (e.keyCode == 'I'.charCodeAt(0) || e.keyCode == 'C'.charCodeAt(0) || e.keyCode == 'J'.charCodeAt(0) || e.keyCode == 'K'.charCodeAt(0) || e.keyCode == 'E'.charCodeAt(0))) ||
                (e.ctrlKey && e.keyCode == 'U'.charCodeAt(0))) {
                triggerSecurityBreach("Keyboard Shortcut Detected");
                return false;
            }
        };

        // Detect DevTools by window size change
        let lastWidth = window.innerWidth;
        let lastHeight = window.innerHeight;
        let devToolsOpen = false;

        setInterval(() => {
            const currentWidth = window.innerWidth;
            const currentHeight = window.innerHeight;

            if (Math.abs(currentWidth - lastWidth) > 150 || Math.abs(currentHeight - lastHeight) > 150) {
                if (!devToolsOpen) {
                    devToolsOpen = true;
                    triggerSecurityBreach("DevTools Window Detected");
                }
            } else {
                devToolsOpen = false;
            }

            lastWidth = currentWidth;
            lastHeight = currentHeight;
        }, 300);

        // Detect DevTools by console detection
        let devtools = { open: false };
        const element = new Image();
        Object.defineProperty(element, 'id', {
            get: function () {
                if (!devtools.open) {
                    devtools.open = true;
                    triggerSecurityBreach("Console Access Detected");
                }
            }
        });

        setInterval(() => {
            devtools.open = false;
            console.log(element);
            console.clear();
        }, 1000);

        // Detect if DevTools is already open on page load
        function checkDevToolsOnLoad() {
            const widthThreshold = window.outerWidth - window.innerWidth > 160;
            const heightThreshold = window.outerHeight - window.innerHeight > 160;

            if (widthThreshold || heightThreshold) {
                triggerSecurityBreach("DevTools Already Open");
            }
        }

        setTimeout(checkDevToolsOnLoad, 1000);

        // ============================================
        // CHAOS MODE - PHYSICS ENGINE
        // ============================================
        let chaosModeActive = false;
        let engine = null;
        let world = null;
        let bodies = [];

        function toggleChaosMode() {
            if (chaosModeActive) {
                disableChaosMode();
            } else {
                enableChaosMode();
            }
        }

        function enableChaosMode() {
            if (typeof Matter === 'undefined') {
                alert('Physics engine not loaded. Please refresh the page.');
                return;
            }

            chaosModeActive = true;
            const btn = document.getElementById('ghost-chaos-btn');
            if (btn) {
                btn.innerHTML = '<i data-lucide="zap-off" class="w-3 h-3"></i> Stop';
                btn.classList.remove('text-rose-500');
                btn.classList.add('text-red-600');
                lucide.createIcons();
            }

            const messagesDiv = document.getElementById('ghost-messages');
            if (!messagesDiv) return;

            // Ensure messages container has proper positioning
            messagesDiv.style.position = 'relative';
            messagesDiv.style.overflow = 'hidden';

            // Create Matter.js engine with gentle gravity
            engine = Matter.Engine.create();
            world = engine.world;
            engine.world.gravity.y = 0.3; // Gentle gravity
            engine.world.gravity.scale = 0.001;

            // Get all message bubbles
            const messageBubbles = messagesDiv.querySelectorAll('.message-bubble');

            bodies = [];
            const messagesRect = messagesDiv.getBoundingClientRect();

            messageBubbles.forEach((bubble) => {
                const rect = bubble.getBoundingClientRect();
                const relativeX = rect.left - messagesRect.left + rect.width / 2;
                const relativeY = rect.top - messagesRect.top + rect.height / 2;

                // Create physics body with gentle properties
                const body = Matter.Bodies.rectangle(
                    relativeX,
                    relativeY,
                    Math.min(rect.width, messagesDiv.offsetWidth - 20), // Constrain width
                    rect.height,
                    {
                        restitution: 0.2, // Less bouncy
                        friction: 0.8, // More friction
                        frictionAir: 0.05, // Air resistance
                        density: 0.0005, // Lighter
                        chamfer: { radius: 8 } // Rounded corners
                    }
                );

                Matter.World.add(world, body);

                // Store original position and style
                const originalLeft = rect.left - messagesRect.left;
                const originalTop = rect.top - messagesRect.top;

                bodies.push({
                    body,
                    element: bubble,
                    originalStyle: bubble.style.cssText,
                    originalLeft,
                    originalTop,
                    maxWidth: Math.min(rect.width, messagesDiv.offsetWidth - 20)
                });

                // Make element position absolute within container
                bubble.style.position = 'absolute';
                bubble.style.left = originalLeft + 'px';
                bubble.style.top = originalTop + 'px';
                bubble.style.width = Math.min(rect.width, messagesDiv.offsetWidth - 20) + 'px';
                bubble.style.margin = '0';
                bubble.style.transition = 'none';
            });

            // Add invisible boundaries within the messages container
            const padding = 5;
            const floor = Matter.Bodies.rectangle(
                messagesDiv.offsetWidth / 2,
                messagesDiv.offsetHeight - padding,
                messagesDiv.offsetWidth,
                10,
                { isStatic: true, label: 'floor' }
            );

            const leftWall = Matter.Bodies.rectangle(
                padding,
                messagesDiv.offsetHeight / 2,
                10,
                messagesDiv.offsetHeight,
                { isStatic: true, label: 'leftWall' }
            );

            const rightWall = Matter.Bodies.rectangle(
                messagesDiv.offsetWidth - padding,
                messagesDiv.offsetHeight / 2,
                10,
                messagesDiv.offsetHeight,
                { isStatic: true, label: 'rightWall' }
            );

            const ceiling = Matter.Bodies.rectangle(
                messagesDiv.offsetWidth / 2,
                padding,
                messagesDiv.offsetWidth,
                10,
                { isStatic: true, label: 'ceiling' }
            );

            Matter.World.add(world, [floor, leftWall, rightWall, ceiling]);

            // Gentle mouse constraint for dragging
            const mouse = Matter.Mouse.create(messagesDiv);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.1,
                    render: { visible: false }
                }
            });
            Matter.World.add(world, mouseConstraint);

            // Run engine with slower updates for smoother motion
            const runner = Matter.Runner.create();
            runner.delta = 1000 / 60; // 60 FPS
            Matter.Runner.run(runner, engine);

            // Sync physics to HTML with boundary constraints
            function syncPhysics() {
                if (!chaosModeActive) return;

                const currentRect = messagesDiv.getBoundingClientRect();
                const maxX = messagesDiv.offsetWidth;
                const maxY = messagesDiv.offsetHeight;

                bodies.forEach(({ body, element, maxWidth }) => {
                    // Constrain position within boundaries
                    let x = body.position.x - body.bounds.min.x;
                    let y = body.position.y - body.bounds.min.y;

                    // Keep within container bounds
                    x = Math.max(5, Math.min(x, maxX - body.bounds.max.x + body.bounds.min.x - 5));
                    y = Math.max(5, Math.min(y, maxY - body.bounds.max.y + body.bounds.min.y - 5));

                    element.style.left = x + 'px';
                    element.style.top = y + 'px';
                    element.style.width = Math.min(maxWidth, maxX - x - 10) + 'px';

                    // Gentle rotation
                    const rotation = body.angle * (180 / Math.PI);
                    element.style.transform = `rotate(${rotation * 0.3}deg)`; // Reduced rotation
                });

                requestAnimationFrame(syncPhysics);
            }
            syncPhysics();
        }

        function disableChaosMode() {
            chaosModeActive = false;

            const btn = document.getElementById('ghost-chaos-btn');
            if (btn) {
                btn.innerHTML = '<i data-lucide="zap" class="w-3 h-3"></i> Gravity';
                btn.classList.add('text-rose-500');
                btn.classList.remove('text-red-600');
                lucide.createIcons();
            }

            // Restore original positions
            bodies.forEach(({ element, originalStyle }) => {
                element.style.cssText = originalStyle;
            });

            // Clean up
            if (engine) {
                Matter.Engine.clear(engine);
                engine = null;
            }
            bodies = [];
        }

        // ============================================
        // SONIC PULSE - AUDIO VISUALIZATION
        // ============================================
        let sonicPulseActive = false;
        let sonicAudioContext = null;
        let sonicAnalyser = null;
        let sonicMicrophone = null;
        let sonicAnimationFrame = null;

        function toggleSonicPulse() {
            if (sonicPulseActive) {
                disableSonicPulse();
            } else {
                enableSonicPulse();
            }
        }

        async function enableSonicPulse() {
            try {
                sonicPulseActive = true;
                const btn = document.getElementById('ghost-sonic-btn');
                if (btn) {
                    btn.innerHTML = '<i data-lucide="radio-off" class="w-3 h-3"></i> Stop';
                    btn.classList.remove('text-cyan-500');
                    btn.classList.add('text-red-600');
                    lucide.createIcons();
                }

                // Prevent chat container from shifting
                const messagesDiv = document.getElementById('ghost-messages');
                if (messagesDiv) {
                    messagesDiv.style.position = 'relative';
                    messagesDiv.style.overflow = 'hidden';
                }

                // Create audio context
                sonicAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                sonicAnalyser = sonicAudioContext.createAnalyser();
                sonicAnalyser.fftSize = 256;
                sonicAnalyser.smoothingTimeConstant = 0.9; // Increased for smoother visualization

                // Try to get microphone with echo cancellation and noise suppression
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    sonicMicrophone = sonicAudioContext.createMediaStreamSource(stream);
                    sonicMicrophone.connect(sonicAnalyser);
                } catch (e) {
                    // If mic not available, use system audio simulation
                    console.log('Microphone not available, using system audio simulation');
                    simulateAudio();
                }

                visualizeAudio();
            } catch (error) {
                console.error('Error enabling sonic pulse:', error);
                alert('Could not access audio. Please allow microphone permissions.');
                disableSonicPulse();
            }
        }

        function simulateAudio() {
            // Simulate audio for demo
            setInterval(() => {
                if (!sonicPulseActive) return;
                const randomVolume = Math.random() * 255;
                updatePulseVisualization(randomVolume);
            }, 100);
        }

        function visualizeAudio() {
            if (!sonicPulseActive) return;

            const dataArray = new Uint8Array(sonicAnalyser.frequencyBinCount);
            sonicAnalyser.getByteFrequencyData(dataArray);

            // Get average volume
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            updatePulseVisualization(average);

            sonicAnimationFrame = requestAnimationFrame(visualizeAudio);
        }

        function updatePulseVisualization(volume) {
            // Gentle pulse strength (much smaller values)
            const pulseStrength = Math.min(volume * 0.3, 15); // Reduced from 50 to 15
            const glowIntensity = Math.min(volume * 0.1, 8); // Gentle glow

            document.documentElement.style.setProperty('--pulse-strength', `${pulseStrength}px`);

            // Apply gentle glow to all message bubbles without shifting layout
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.classList.add('pulse-active');
                // Gentle cyan glow that doesn't affect layout
                bubble.style.boxShadow = `0 0 ${glowIntensity}px rgba(8, 145, 178, 0.6), 0 0 ${glowIntensity * 2}px rgba(8, 145, 178, 0.3)`;
                // Very subtle scale that won't shift other elements
                bubble.style.transform = `scale(${1 + pulseStrength / 500})`; // Reduced from 200 to 500
                bubble.style.transition = 'box-shadow 0.1s ease-out, transform 0.1s ease-out';
                // Ensure transform origin is center to prevent shifting
                bubble.style.transformOrigin = 'center center';
            });
        }

        function disableSonicPulse() {
            sonicPulseActive = false;

            const btn = document.getElementById('ghost-sonic-btn');
            if (btn) {
                btn.innerHTML = '<i data-lucide="radio" class="w-3 h-3"></i> Visualize';
                btn.classList.add('text-cyan-500');
                btn.classList.remove('text-red-600');
                lucide.createIcons();
            }

            if (sonicAnimationFrame) {
                cancelAnimationFrame(sonicAnimationFrame);
                sonicAnimationFrame = null;
            }

            if (sonicMicrophone) {
                sonicMicrophone.disconnect();
                sonicMicrophone = null;
            }

            if (sonicAudioContext) {
                sonicAudioContext.close();
                sonicAudioContext = null;
            }

            // Reset styles
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.classList.remove('pulse-active');
                bubble.style.boxShadow = '';
                bubble.style.transform = '';
            });
        }


        // --- INIT ---
        try { lucide.createIcons(); } catch (e) { }

        // --- NAVIGATION ---
        function switchTab(tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');

            // Reset styles
            ['downloader', 'crypter', 'keys', 'stego', 'sonic'].forEach(t => {
                const btn = document.getElementById(`btn-nav-${t}`);
                if (!btn) return;
                if (t === 'sonic') {
                    btn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all text-cyan-500 hover:text-cyan-300 border border-transparent hover:border-cyan-900/50 flex items-center gap-1";
                } else if (t === 'ghost') {
                    btn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all text-emerald-500 hover:text-emerald-300 border border-transparent hover:border-emerald-900/50 flex items-center gap-1";
                } else {
                    btn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all text-zinc-500 hover:text-zinc-300";
                }
            });

            // Set active
            const activeBtn = document.getElementById(`btn-nav-${tab}`);
            if (tab === 'sonic') {
                activeBtn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all bg-cyan-950 text-cyan-300 border border-cyan-800 shadow-[0_0_15px_rgba(8,145,178,0.2)] flex items-center gap-1";
                initVisualizer(); // Start visualizer loop
            } else if (tab === 'keys') {
                activeBtn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all bg-amber-950 text-amber-500 border border-amber-900 shadow-[0_0_15px_rgba(245,158,11,0.2)]";
                stopVisualizer(); // Stop visualizer when switching away
            } else {
                activeBtn.className = "px-5 py-1.5 rounded-full text-xs font-medium transition-all bg-zinc-800 text-white shadow-lg";
                stopVisualizer(); // Stop visualizer when switching away
            }
        }
        function toggleMenu() { document.getElementById('mobile-menu').classList.toggle('hidden'); }

        // --- COMMON UTILS ---
        function clearInput(id) { document.getElementById(id).value = ''; }
        async function pasteToInput(id) {
            try { document.getElementById(id).value = await navigator.clipboard.readText(); }
            catch (e) { document.getElementById(id).value = prompt("Paste text:"); }
        }
        function copyToClipboard() {
            const t = document.getElementById('result-text').innerText;
            navigator.clipboard.writeText(t).then(() => alert("Copied")).catch(() => prompt("Copy:", t));
        }

        // --- 1. DOWNLOADER LOGIC ---
        function handleDownload(e) {
            e.preventDefault();
            const url = document.getElementById('dl-input').value.trim();
            const btn = document.getElementById('dl-btn');

            if (!url.includes('http')) {
                document.getElementById('dl-error').classList.remove('hidden');
                document.getElementById('dl-error-text').innerText = "Invalid URL";
                return;
            }

            document.getElementById('dl-error').classList.add('hidden');
            document.getElementById('media-result').classList.add('hidden');
            document.getElementById('dl-result').classList.add('hidden');

            const isMedia = /\.(mp4|m3u8|mkv|avi|mov|webm|flv)(\?|$)/i.test(url);

            btn.innerHTML = `<i data-lucide="loader-2" class="animate-spin w-5 h-5"></i> Processing`;

            setTimeout(() => {
                btn.innerHTML = `<i data-lucide="download" class="w-5 h-5"></i> Extract`;
                lucide.createIcons();

                if (isMedia) {
                    document.getElementById('media-result').classList.remove('hidden');
                    document.getElementById('media-download-btn').href = url;
                } else {
                    document.getElementById('dl-result').classList.remove('hidden');
                    const link = `https://teradownloader.com/download?l=${encodeURIComponent(url)}`;
                    document.getElementById('dl-iframe').src = link;
                    document.getElementById('dl-external-link').href = link;
                }
            }, 1000);
        }

        // --- 2. CRYPTER LOGIC (Restored Complex Version) ---
        const SALT = "POSTMORTEM_KEY_X9";
        const DELIMITER = "|||";
        const PASS_MARKER = "LOCKED::";
        const TIME_MARKER = "_TIME_";
        let currentMode = 'encrypt';
        let hiddenTargetUrls = [];

        function complexEncrypt(text) {
            if (!text) return '';
            try {
                let result = btoa(text);
                let shifted = '';
                for (let i = 0; i < result.length; i++) {
                    shifted += String.fromCharCode(result.charCodeAt(i) + 5);
                }
                const salted = shifted.split('').reverse().join('') + `_SALT_${btoa(SALT)}`;
                return btoa(salted);
            } catch (e) {
                return "Error: Invalid input";
            }
        }

        function complexDecrypt(text) {
            if (!text) return null;
            try {
                let salted = atob(text);
                const saltMarker = `_SALT_${btoa(SALT)}`;
                if (!salted.includes(saltMarker)) return null;

                let rawShifted = salted.replace(saltMarker, '');
                let unreversed = rawShifted.split('').reverse().join('');
                let unshifted = '';
                for (let i = 0; i < unreversed.length; i++) {
                    unshifted += String.fromCharCode(unreversed.charCodeAt(i) - 5);
                }
                return atob(unshifted);
            } catch (e) {
                return null;
            }
        }

        function wrapWithPass(payload, pass) {
            let signature = btoa(pass).substring(0, 8);
            return PASS_MARKER + signature + "::" + complexEncrypt(payload);
        }

        function unwrapPass(payload, pass) {
            if (!payload.startsWith(PASS_MARKER)) return null;
            const parts = payload.split('::');
            if (parts.length < 3) return null;
            const signature = parts[1];
            const content = parts[2];
            const attemptSignature = btoa(pass).substring(0, 8);
            if (signature !== attemptSignature) return "WRONG_PASS";
            return complexDecrypt(content);
        }

        // Check if a string is a URL/link
        function isUrl(str) {
            if (!str || typeof str !== 'string') return false;
            const trimmed = str.trim();

            // Check for common URL patterns
            const urlPattern = /^(https?:\/\/|www\.|[a-zA-Z0-9-]+\.[a-zA-Z]{2,})/i;
            if (!urlPattern.test(trimmed)) return false;

            // More specific URL validation
            try {
                // If it starts with http:// or https://, it's definitely a URL
                if (/^https?:\/\//i.test(trimmed)) return true;

                // If it contains a domain pattern (e.g., example.com, subdomain.example.com)
                const domainPattern = /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(\/.*)?$/i;
                if (domainPattern.test(trimmed)) return true;

                // Check if it looks like a URL with path/query
                if (/^[a-zA-Z0-9-]+\.[a-zA-Z]{2,}(\/|\?|#)/.test(trimmed)) return true;
            } catch (e) {
                return false;
            }

            return false;
        }

        function setCryptoMode(mode) {
            currentMode = mode;
            const btnEncrypt = document.getElementById('mode-encrypt');
            const btnDecrypt = document.getElementById('mode-decrypt');
            const input = document.getElementById('crypto-input');
            const actionText = document.getElementById('action-text');
            const settingsPanel = document.getElementById('crypto-settings');
            const expiryContainer = document.getElementById('crypto-expiry-container');

            hiddenTargetUrls = [];
            document.getElementById('result-empty').classList.remove('hidden');
            document.getElementById('result-text').classList.add('hidden');
            document.getElementById('result-launch').classList.add('hidden');

            if (mode === 'encrypt') {
                btnEncrypt.className = "p-1.5 rounded-md transition-all bg-zinc-700 text-white";
                btnDecrypt.className = "p-1.5 rounded-md transition-all text-zinc-600 hover:text-zinc-400";
                input.placeholder = "Paste text or link(s) here. For multiple links, put each on a new line...";
                actionText.innerText = "Encrypt Payload";
                settingsPanel.classList.remove('hidden');
                settingsPanel.classList.add('grid');
                if (expiryContainer) expiryContainer.style.display = 'block';
                document.getElementById('crypto-pass').placeholder = "Optional PIN";
            } else {
                btnDecrypt.className = "p-1.5 rounded-md transition-all bg-zinc-700 text-white";
                btnEncrypt.className = "p-1.5 rounded-md transition-all text-zinc-600 hover:text-zinc-400";
                input.placeholder = "Paste encrypted string...";
                actionText.innerText = "Decrypt & Verify";
                settingsPanel.classList.remove('hidden');
                settingsPanel.classList.add('grid');
                if (expiryContainer) expiryContainer.style.display = 'none';
                document.getElementById('crypto-pass').placeholder = "Enter passcode if required";
            }
        }

        function handleCryptoProcess() {
            const inputVal = document.getElementById('crypto-input').value.trim();
            const passVal = document.getElementById('crypto-pass').value.trim();
            const expiryVal = parseInt(document.getElementById('crypto-expiry').value);
            const resultBox = document.getElementById('result-text');
            const emptyBox = document.getElementById('result-empty');

            if (!inputVal) return;

            emptyBox.classList.add('hidden');
            resultBox.classList.remove('hidden');
            document.getElementById('btn-copy').classList.remove('hidden');

            if (currentMode === 'encrypt') {
                const lines = inputVal.split(/\r?\n/).filter(line => line.trim() !== '');
                if (lines.length === 0) return;
                let payload = lines.join(DELIMITER);

                if (expiryVal > 0) {
                    const expiryTime = Date.now() + (expiryVal * 60 * 1000);
                    payload += TIME_MARKER + expiryTime;
                }

                let finalOutput;
                if (passVal) {
                    finalOutput = wrapWithPass(payload, passVal);
                } else {
                    finalOutput = complexEncrypt(payload);
                }

                resultBox.className = "break-all font-mono text-sm text-emerald-400";
                resultBox.innerText = finalOutput;
            } else {
                let decrypted = null;

                if (inputVal.startsWith(PASS_MARKER)) {
                    if (!passVal) {
                        resultBox.innerText = "Error: This payload is locked. Please enter the passcode.";
                        resultBox.className = "text-red-500";
                        return;
                    }
                    const unlockResult = unwrapPass(inputVal, passVal);
                    if (unlockResult === "WRONG_PASS") {
                        resultBox.innerText = "Error: Invalid Passcode.";
                        resultBox.className = "text-red-500";
                        return;
                    }
                    decrypted = unlockResult;
                } else {
                    decrypted = complexDecrypt(inputVal);
                }

                if (decrypted) {
                    if (decrypted.includes(TIME_MARKER)) {
                        const parts = decrypted.split(TIME_MARKER);
                        const content = parts[0];
                        const expiry = parseInt(parts[1]);

                        if (Date.now() > expiry) {
                            resultBox.innerHTML = "STATUS: <b>DECEASED</b><br>This payload has expired and has been purged.";
                            resultBox.className = "text-red-500";
                            return;
                        }
                        decrypted = content;
                    }

                    // Check if decrypted content contains URLs
                    const parts = decrypted.split(DELIMITER);
                    const hasUrls = parts.some(part => isUrl(part.trim()));

                    if (hasUrls) {
                        // Contains URLs - show launch buttons
                        hiddenTargetUrls = parts.filter(part => {
                            const trimmed = part.trim();
                            return trimmed && isUrl(trimmed);
                        });

                        const container = document.getElementById('launch-buttons-container');
                        container.innerHTML = '';

                        hiddenTargetUrls.forEach((url, index) => {
                            let safeUrl = url.trim();
                            if (safeUrl && !safeUrl.match(/^https?:\/\//i)) {
                                safeUrl = 'https://' + safeUrl;
                            }

                            const btn = document.createElement('button');
                            btn.type = "button";
                            btn.className = "bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-2 px-6 rounded-full flex items-center gap-2 transition-all shadow-[0_0_15px_rgba(16,185,129,0.4)] w-full justify-center shrink-0 mb-2";
                            btn.innerHTML = `Launch Target ${hiddenTargetUrls.length > 1 ? index + 1 : ''} <i data-lucide="arrow-right-circle" class="w-4 h-4"></i>`;
                            btn.onclick = () => window.open(safeUrl, '_blank', 'noopener,noreferrer');
                            container.appendChild(btn);
                        });

                        lucide.createIcons();
                        document.getElementById('result-launch').classList.remove('hidden');
                        resultBox.innerText = decrypted;
                    } else {
                        // Plain text - display directly
                        document.getElementById('result-launch').classList.add('hidden');
                        resultBox.className = "break-all font-mono text-sm text-emerald-400";
                        resultBox.innerText = decrypted;
                    }
                } else {
                    resultBox.innerText = "Error: Decryption failed. Invalid signature or corrupted string.";
                    resultBox.className = "text-red-500";
                }
            }
        }

        // --- 3. STEGO LOGIC (Restored Full Logic) ---
        let generatedCarrierBlob = null;

        function generateNoiseCarrier() {
            const canvas = document.createElement('canvas');
            canvas.width = 800;
            canvas.height = 800;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#09090b';
            ctx.fillRect(0, 0, 800, 800);

            for (let i = 0; i < 60000; i++) {
                const x = Math.random() * 800;
                const y = Math.random() * 800;
                const gray = Math.floor(Math.random() * 50) + 20;
                const size = Math.random() * 2 + 1;
                ctx.fillStyle = `rgba(${gray},${gray},${gray}, 0.8)`;
                ctx.fillRect(x, y, size, size);
            }

            return new Promise(resolve => canvas.toBlob(resolve));
        }

        async function generateCarrierImage() {
            const statusDiv = document.getElementById('generated-status');
            statusDiv.innerHTML = '<span class="animate-pulse">Generating noise pattern...</span>';
            statusDiv.classList.remove('hidden');

            try {
                generatedCarrierBlob = await generateNoiseCarrier();
                statusDiv.innerHTML = '<i data-lucide="check" class="w-3 h-3 inline"></i> Carrier Generated & Ready';
                lucide.createIcons();
                document.getElementById('stego-upload-inject').value = '';
                document.getElementById('file-name-display').innerText = "Using Generated Image";
            } catch (e) {
                statusDiv.innerText = "Generation failed.";
            }
        }

        function stegoInject() {
            const fileInput = document.getElementById('stego-upload-inject');
            const textInput = document.getElementById('stego-text-inject').value.trim();
            const passInput = document.getElementById('stego-pass-inject').value.trim();

            let sourceBlob = null;
            if (fileInput.files[0]) {
                sourceBlob = fileInput.files[0];
            } else if (generatedCarrierBlob) {
                sourceBlob = generatedCarrierBlob;
            }

            if (!sourceBlob || !textInput) {
                alert("Please select/generate an image and enter payload text.");
                return;
            }

            let finalPayload = textInput;
            if (passInput) {
                finalPayload = wrapWithPass(textInput, passInput);
            }

            processStegoInjection(sourceBlob, finalPayload);
        }

        function processStegoInjection(blob, textPayload) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = function () {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imgData.data;

                    const payload = textPayload + String.fromCharCode(0);
                    const binary = [];
                    for (let i = 0; i < payload.length; i++) {
                        let bin = payload.charCodeAt(i).toString(2).padStart(8, '0');
                        for (let j = 0; j < 8; j++) binary.push(parseInt(bin[j]));
                    }

                    if (binary.length > data.length / 4) {
                        alert("Image is too small for this payload.");
                        return;
                    }

                    let binIndex = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        if (binIndex < binary.length) {
                            for (let j = 0; j < 3; j++) {
                                if (binIndex < binary.length) {
                                    data[i + j] = (data[i + j] & ~1) | binary[binIndex];
                                    binIndex++;
                                }
                            }
                        } else {
                            break;
                        }
                    }

                    ctx.putImageData(imgData, 0, 0);
                    const link = document.createElement('a');
                    link.download = 'coded_image.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(blob);
        }

        async function stegoExtract() {
            const fileInput = document.getElementById('stego-upload-extract');
            const files = fileInput.files;
            const passInput = document.getElementById('stego-pass-extract').value.trim();
            const resultArea = document.getElementById('stego-result-area');

            if (files.length === 0) return alert("Please select at least one image.");

            resultArea.innerHTML = '';

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const cardId = `stego-res-${i}`;

                const card = document.createElement('div');
                card.id = cardId;
                card.className = "bg-black/50 p-3 rounded border-l-2 border-zinc-700 animate-in mb-2";
                card.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-xs font-bold text-zinc-300 truncate w-3/4">${file.name}</span>
                        <i data-lucide="loader-2" class="w-3 h-3 text-zinc-500 animate-spin" id="${cardId}-icon"></i>
                    </div>
                    <div class="text-[10px] text-zinc-500 font-mono" id="${cardId}-status">Scanning...</div>
                    <div id="${cardId}-content" class="mt-2 hidden"></div>
                `;
                resultArea.appendChild(card);
                lucide.createIcons();

                try {
                    const text = await processSingleImage(file);
                    handleDecryptedText(text, passInput, cardId);
                } catch (e) {
                    const statusDiv = document.getElementById(`${cardId}-status`);
                    const icon = document.getElementById(`${cardId}-icon`);
                    statusDiv.innerHTML = `<span class="text-red-900 bg-red-900/10 px-1 rounded">No payload found</span>`;
                    icon.setAttribute('data-lucide', 'x-circle');
                    icon.classList.remove('animate-spin');
                    icon.classList.add('text-red-800');
                    card.classList.replace('border-zinc-700', 'border-red-900');
                    lucide.createIcons();
                }
            }
        }

        function processSingleImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.onload = function () {
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);

                            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imgData.data;

                            let charBinary = "";
                            let resultText = "";

                            for (let i = 0; i < data.length; i += 4) {
                                for (let j = 0; j < 3; j++) {
                                    charBinary += (data[i + j] & 1).toString();
                                    if (charBinary.length === 8) {
                                        const charCode = parseInt(charBinary, 2);
                                        if (charCode === 0) {
                                            resolve(resultText);
                                            return;
                                        }
                                        resultText += String.fromCharCode(charCode);
                                        charBinary = "";
                                    }
                                }
                            }
                            reject(new Error("No null terminator"));
                        } catch (err) {
                            reject(err);
                        }
                    };
                    img.onerror = () => reject(new Error("Invalid image"));
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function handleDecryptedText(extractedText, password, cardId) {
            const statusDiv = document.getElementById(`${cardId}-status`);
            const contentDiv = document.getElementById(`${cardId}-content`);
            const icon = document.getElementById(`${cardId}-icon`);
            const card = document.getElementById(cardId);

            let finalText = extractedText;
            let statusHtml = '<span class="text-emerald-500">Decrypted</span>';
            let cardColor = 'border-emerald-600';

            if (extractedText.startsWith(PASS_MARKER)) {
                if (!password) {
                    statusHtml = '<span class="text-amber-500 font-bold">LOCKED: Passcode Required</span>';
                    cardColor = 'border-amber-600';
                    icon.setAttribute('data-lucide', 'lock');
                    card.classList.replace('border-zinc-700', cardColor);
                    statusDiv.innerHTML = statusHtml;
                    icon.classList.remove('animate-spin');
                    icon.classList.add('text-amber-500');
                    lucide.createIcons();
                    return;
                }
                const unlockResult = unwrapPass(extractedText, password);
                if (unlockResult === "WRONG_PASS") {
                    statusHtml = '<span class="text-red-500 font-bold">Wrong Passcode</span>';
                    cardColor = 'border-red-600';
                    icon.setAttribute('data-lucide', 'shield-alert');
                    card.classList.replace('border-zinc-700', cardColor);
                    statusDiv.innerHTML = statusHtml;
                    icon.classList.remove('animate-spin');
                    icon.classList.add('text-red-500');
                    lucide.createIcons();
                    return;
                }
                finalText = unlockResult;
            }

            // Try complex decrypt, but if it fails, use the text as-is (for password-only protected text)
            const autoDecrypt = complexDecrypt(finalText);
            if (autoDecrypt) {
                if (autoDecrypt.includes(TIME_MARKER)) {
                    const parts = autoDecrypt.split(TIME_MARKER);
                    const content = parts[0];
                    const expiry = parseInt(parts[1]);
                    if (Date.now() > expiry) {
                        statusHtml = '<span class="text-red-600 font-bold">EXPIRED / DELETED</span>';
                        cardColor = 'border-red-900';
                        finalText = null;
                    } else {
                        finalText = content;
                    }
                } else {
                    finalText = autoDecrypt;
                }
            }
            // If complexDecrypt returns null, keep finalText as-is (password-only protected text)

            icon.classList.remove('animate-spin');

            if (finalText === null) {
                icon.setAttribute('data-lucide', 'skull');
                icon.classList.add('text-red-700');
            } else {
                icon.setAttribute('data-lucide', 'check-circle');
                icon.classList.add('text-emerald-500');

                const isUrl = finalText.includes('http') || finalText.includes('www');
                const multiLinks = finalText.split(DELIMITER);
                contentDiv.classList.remove('hidden');

                if (multiLinks.length > 1 || isUrl) {
                    const validLinks = multiLinks.filter(l => l.includes('http') || l.includes('www'));
                    if (validLinks.length > 0) {
                        validLinks.forEach((url, idx) => {
                            let safeUrl = url.trim();
                            if (safeUrl && !safeUrl.match(/^https?:\/\//i)) safeUrl = 'https://' + safeUrl;
                            const btn = document.createElement('button');
                            btn.className = "w-full text-left text-[10px] text-emerald-400 hover:text-emerald-300 hover:underline mb-1 truncate flex items-center gap-1";
                            btn.innerHTML = `<i data-lucide="external-link" class="w-3 h-3"></i> ${safeUrl}`;
                            btn.onclick = () => window.open(safeUrl, '_blank', 'noopener,noreferrer');
                            contentDiv.appendChild(btn);
                        });
                    } else {
                        contentDiv.innerHTML = `<p class="text-[10px] text-zinc-400 break-all" style="unicode-bidi: plaintext;">${finalText}</p>`;
                    }
                } else {
                    contentDiv.innerHTML = `<p class="text-[10px] text-zinc-400 break-all bg-zinc-900 p-1 rounded" style="unicode-bidi: plaintext;">${finalText}</p>`;
                }
            }
            card.classList.replace('border-zinc-700', cardColor);
            statusDiv.innerHTML = statusHtml;
            lucide.createIcons();
        }

        // --- 4. KEY FORGE LOGIC ---
        function strToBytes(str) {
            const utf8 = unescape(encodeURIComponent(str));
            const arr = new Uint8Array(utf8.length);
            for (let i = 0; i < utf8.length; i++) arr[i] = utf8.charCodeAt(i);
            return arr;
        }

        function bytesToStr(arr) {
            let str = '';
            for (let i = 0; i < arr.length; i++) str += String.fromCharCode(arr[i]);
            return decodeURIComponent(escape(str));
        }

        function bytesToHex(arr) {
            return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function hexToBytes(hex) {
            const pairs = hex.match(/.{1,2}/g) || [];
            return new Uint8Array(pairs.map(byte => parseInt(byte, 16)));
        }

        function forgeKeys() {
            const secret = document.getElementById('keys-input').value;
            const count = parseInt(document.getElementById('keys-count').value);
            const outputDiv = document.getElementById('forge-output');

            if (!secret) return alert("Enter a secret first.");

            const secretBytes = strToBytes(secret);
            const len = secretBytes.length;
            const keys = [];

            // Generate N-1 random keys
            let finalXor = new Uint8Array(len);
            for (let i = 0; i < len; i++) finalXor[i] = secretBytes[i];

            for (let i = 0; i < count - 1; i++) {
                const randomBytes = new Uint8Array(len);
                crypto.getRandomValues(randomBytes);
                keys.push(randomBytes);
                // XOR this random key into our running total
                for (let j = 0; j < len; j++) finalXor[j] ^= randomBytes[j];
            }

            // The last key is the result of (Secret XOR R1 XOR R2 ... XOR Rn-1)
            keys.push(finalXor);

            // Render Output
            outputDiv.classList.remove('hidden');
            outputDiv.innerHTML = '';

            const list = document.createElement('div');
            list.className = 'space-y-2';

            keys.forEach((k, idx) => {
                const hex = bytesToHex(k);
                const div = document.createElement('div');
                div.className = "flex gap-2 items-center bg-zinc-900 p-2 rounded border border-zinc-800";
                div.innerHTML = `
                    <span class="text-amber-600 font-bold select-none w-6">${idx + 1}.</span>
                    <code class="flex-grow select-all text-amber-500 break-all">${hex}</code>
                    <button onclick="navigator.clipboard.writeText('${hex}').then(() => { const btn = this; const orig = btn.innerHTML; btn.innerHTML = '<i data-lucide=\\'check\\' class=\\'w-3 h-3\\'></i>'; setTimeout(() => btn.innerHTML = orig, 1000); }); lucide.createIcons();" class="text-zinc-500 hover:text-white transition-colors flex-shrink-0"><i data-lucide="copy" class="w-3 h-3"></i></button>
                `;
                list.appendChild(div);
            });
            outputDiv.appendChild(list);

            const note = document.createElement('div');
            note.className = "mt-4 text-center text-zinc-500 italic text-xs";
            note.innerText = " Copy all keys. If any key is lost, data is unrecoverable.";
            outputDiv.appendChild(note);
            lucide.createIcons();
        }

        function unlockKeys() {
            const input = document.getElementById('keys-unlock-input').value;
            const resultDiv = document.getElementById('unlock-result');

            if (!input.trim()) return;

            const lines = input.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);

            if (lines.length < 2) {
                resultDiv.classList.remove('hidden');
                resultDiv.innerText = "Need at least 2 keys to combine.";
                resultDiv.className = "w-full bg-red-950/50 border border-red-900 rounded-lg p-3 text-red-400 text-center";
                return;
            }

            try {
                // Decode first key hex
                let combined = hexToBytes(lines[0]);

                // XOR with rest
                for (let i = 1; i < lines.length; i++) {
                    const current = hexToBytes(lines[i]);
                    if (current.length !== combined.length) throw new Error("Length mismatch");

                    for (let j = 0; j < combined.length; j++) {
                        combined[j] ^= current[j];
                    }
                }

                const result = bytesToStr(combined);
                resultDiv.classList.remove('hidden');
                resultDiv.innerHTML = `<span class="text-zinc-500 text-xs block mb-2">Decrypted Secret:</span><span class="text-emerald-400 text-lg font-bold break-all">${result}</span>`;
                resultDiv.className = "w-full bg-zinc-950 border border-emerald-900/50 rounded-lg p-4 font-mono break-all text-center";

            } catch (e) {
                resultDiv.classList.remove('hidden');
                resultDiv.innerText = "Decryption Failed. Invalid keys or mismatch.";
                resultDiv.className = "w-full bg-red-950/50 border border-red-900 rounded-lg p-3 text-red-400 text-center";
            }
        }

        // --- 5. SONIC LAB EXPERIMENT (NEW) ---
        let audioContext;
        let analyser;
        let visualizerCanvas;
        let visualizerCtx;
        let animationFrameId = null;
        let isVisualizerActive = false;

        function initVisualizer() {
            if (audioContext && isVisualizerActive) return;
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                }
                visualizerCanvas = document.getElementById('sonic-canvas');
                if (!visualizerCanvas) return;
                visualizerCtx = visualizerCanvas.getContext('2d');
                visualizerCanvas.width = visualizerCanvas.offsetWidth;
                visualizerCanvas.height = visualizerCanvas.offsetHeight;
                isVisualizerActive = true;
                drawVisualizer();
            } catch (e) { console.log("Audio API blocked"); }
        }

        function stopVisualizer() {
            isVisualizerActive = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function drawVisualizer() {
            if (!isVisualizerActive || !analyser || !visualizerCanvas || !visualizerCtx) {
                animationFrameId = null;
                return;
            }
            animationFrameId = requestAnimationFrame(drawVisualizer);

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            visualizerCtx.fillStyle = '#000';
            visualizerCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

            const barWidth = (visualizerCanvas.width / bufferLength) * 2.5;
            let barHeight;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                barHeight = dataArray[i] / 2;
                visualizerCtx.fillStyle = `rgb(${barHeight + 20}, ${50 + barHeight}, ${200})`;
                visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function playTone() {
            if (!audioContext) initVisualizer();
            if (!audioContext || !analyser) return;
            if (audioContext.state === 'suspended') audioContext.resume();

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);

            gain.gain.setValueAtTime(0.1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            osc.connect(gain);
            gain.connect(analyser);
            analyser.connect(audioContext.destination);

            osc.start();
            osc.stop(audioContext.currentTime + 0.5);
        }

        function generateSonic() {
            const msg = document.getElementById('sonic-input').value;
            if (!msg) return alert("Enter message");

            const btn = document.getElementById('btn-sonic-gen');
            btn.innerHTML = "Generating...";
            playTone();

            setTimeout(() => {
                const sampleRate = 44100;
                const duration = 10;
                const numSamples = sampleRate * duration;

                const header = "MKD_SONIC::";
                const payload = header + msg + "\0";
                const binary = [];
                for (let i = 0; i < payload.length; i++) {
                    let bin = payload.charCodeAt(i).toString(2).padStart(8, '0');
                    for (let j = 0; j < 8; j++) binary.push(parseInt(bin[j]));
                }

                const buffer = new Int16Array(numSamples);
                let binIdx = 0;

                for (let i = 0; i < numSamples; i++) {
                    const t = i / sampleRate;
                    const f1 = 50;
                    const f2 = 55;
                    let sample = Math.sin(2 * Math.PI * f1 * t) * 0.4 +
                        Math.sin(2 * Math.PI * f2 * t) * 0.4 +
                        (Math.random() - 0.5) * 0.1;

                    let intSample = Math.floor(sample * 30000);

                    if (binIdx < binary.length) {
                        intSample = (intSample & ~1) | binary[binIdx];
                        binIdx++;
                    }

                    buffer[i] = intSample;
                }

                if (binIdx < binary.length) {
                    alert("Message too long for 10s audio");
                    btn.innerHTML = `<i data-lucide="activity" class="w-4 h-4"></i> Generate`;
                    return;
                }

                const wavBytes = encodeWAV(buffer, sampleRate);
                const blob = new Blob([wavBytes], { type: 'audio/wav' });

                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `sonic_artifact_${Date.now()}.wav`;
                link.click();

                btn.innerHTML = `<i data-lucide="check" class="w-4 h-4"></i> Done`;
                lucide.createIcons();
                setTimeout(() => btn.innerHTML = `<i data-lucide="activity" class="w-4 h-4"></i> Generate & Download WAV`, 2000);
            }, 100);
        }

        function handleSonicUpload(input) {
            document.getElementById('sonic-file-name').innerText = input.files[0]?.name || "Drop .WAV File";
        }

        function decodeSonic() {
            const input = document.getElementById('sonic-upload');
            if (!input.files[0]) return alert("Upload file first");

            const reader = new FileReader();
            reader.onload = function (e) {
                const buffer = e.target.result;
                const dataView = new DataView(buffer);

                let text = "";
                let binChar = "";

                try {
                    for (let i = 44; i < dataView.byteLength; i += 2) {
                        const sample = dataView.getInt16(i, true);
                        const bit = sample & 1;
                        binChar += bit;

                        if (binChar.length === 8) {
                            const charCode = parseInt(binChar, 2);
                            if (charCode === 0) break;
                            text += String.fromCharCode(charCode);
                            binChar = "";
                        }
                    }

                    const resultDiv = document.getElementById('sonic-result');
                    const textDiv = document.getElementById('sonic-result-text');
                    resultDiv.classList.remove('hidden');

                    if (text.startsWith("MKD_SONIC::")) {
                        textDiv.innerText = text.replace("MKD_SONIC::", "");
                        textDiv.className = "text-cyan-400";
                        playTone();
                    } else {
                        textDiv.innerText = "No hidden data found or corrupted signal.";
                        textDiv.className = "text-red-500";
                    }
                } catch (e) {
                    alert("Error parsing audio.");
                }
            };
            reader.readAsArrayBuffer(input.files[0]);
        }

        function encodeWAV(samples, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');

            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);

            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);

            let offset = 44;
            for (let i = 0; i < samples.length; i++, offset += 2) {
                view.setInt16(offset, samples[i], true);
            }

            return buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // --- 5. GHOST COMMS (ZERO-KNOWLEDGE ENCRYPTED MESSAGING) ---
        let ghostCryptoKey = null;
        let ghostRoomId = null;
        let ghostHandle = null;
        let ghostUnsubscribe = null;
        let ghostRoomPassword = null;
        let isRoomCreator = false;
        let ghostRoomSettings = {
            enableDownload: false,
            enableDelete: false,
            enableGifs: false
        };

        // MASTER KEYS (100 Lifetime Keys)
        const MASTER_KEYS = [
            "GHOST-2025-KEY-001-ALPHA-BRAVO-CHARLIE",
            "GHOST-2025-KEY-002-DELTA-ECHO-FOXTROT",
            "GHOST-2025-KEY-003-GOLF-HOTEL-INDIA",
            "GHOST-2025-KEY-004-JULIET-KILO-LIMA",
            "GHOST-2025-KEY-005-MIKE-NOVEMBER-OSCAR",
            "GHOST-2025-KEY-006-PAPA-QUEBEC-ROMEO",
            "GHOST-2025-KEY-007-SIERRA-TANGO-UNIFORM",
            "GHOST-2025-KEY-008-VICTOR-WHISKEY-XRAY",
            "GHOST-2025-KEY-009-YANKEE-ZULU-ALPHA",
            "GHOST-2025-KEY-010-BRAVO-CHARLIE-DELTA",
            "GHOST-2025-KEY-011-ECHO-FOXTROT-GOLF",
            "GHOST-2025-KEY-012-HOTEL-INDIA-JULIET",
            "GHOST-2025-KEY-013-KILO-LIMA-MIKE",
            "GHOST-2025-KEY-014-NOVEMBER-OSCAR-PAPA",
            "GHOST-2025-KEY-015-QUEBEC-ROMEO-SIERRA",
            "GHOST-2025-KEY-016-TANGO-UNIFORM-VICTOR",
            "GHOST-2025-KEY-017-WHISKEY-XRAY-YANKEE",
            "GHOST-2025-KEY-018-ZULU-ALPHA-BRAVO",
            "GHOST-2025-KEY-019-CHARLIE-DELTA-ECHO",
            "GHOST-2025-KEY-020-FOXTROT-GOLF-HOTEL",
            "GHOST-2025-KEY-021-INDIA-JULIET-KILO",
            "GHOST-2025-KEY-022-LIMA-MIKE-NOVEMBER",
            "GHOST-2025-KEY-023-OSCAR-PAPA-QUEBEC",
            "GHOST-2025-KEY-024-ROMEO-SIERRA-TANGO",
            "GHOST-2025-KEY-025-UNIFORM-VICTOR-WHISKEY",
            "GHOST-2025-KEY-026-XRAY-YANKEE-ZULU",
            "GHOST-2025-KEY-027-ALPHA-BRAVO-CHARLIE",
            "GHOST-2025-KEY-028-DELTA-ECHO-FOXTROT",
            "GHOST-2025-KEY-029-GOLF-HOTEL-INDIA",
            "GHOST-2025-KEY-030-JULIET-KILO-LIMA",
            "GHOST-2025-KEY-031-MIKE-NOVEMBER-OSCAR",
            "GHOST-2025-KEY-032-PAPA-QUEBEC-ROMEO",
            "GHOST-2025-KEY-033-SIERRA-TANGO-UNIFORM",
            "GHOST-2025-KEY-034-VICTOR-WHISKEY-XRAY",
            "GHOST-2025-KEY-035-YANKEE-ZULU-ALPHA",
            "GHOST-2025-KEY-036-BRAVO-CHARLIE-DELTA",
            "GHOST-2025-KEY-037-ECHO-FOXTROT-GOLF",
            "GHOST-2025-KEY-038-HOTEL-INDIA-JULIET",
            "GHOST-2025-KEY-039-KILO-LIMA-MIKE",
            "GHOST-2025-KEY-040-NOVEMBER-OSCAR-PAPA",
            "GHOST-2025-KEY-041-QUEBEC-ROMEO-SIERRA",
            "GHOST-2025-KEY-042-TANGO-UNIFORM-VICTOR",
            "GHOST-2025-KEY-043-WHISKEY-XRAY-YANKEE",
            "GHOST-2025-KEY-044-ZULU-ALPHA-BRAVO",
            "GHOST-2025-KEY-045-CHARLIE-DELTA-ECHO",
            "GHOST-2025-KEY-046-FOXTROT-GOLF-HOTEL",
            "GHOST-2025-KEY-047-INDIA-JULIET-KILO",
            "GHOST-2025-KEY-048-LIMA-MIKE-NOVEMBER",
            "GHOST-2025-KEY-049-OSCAR-PAPA-QUEBEC",
            "GHOST-2025-KEY-050-ROMEO-SIERRA-TANGO",
            "GHOST-2025-KEY-051-UNIFORM-VICTOR-WHISKEY",
            "GHOST-2025-KEY-052-XRAY-YANKEE-ZULU",
            "GHOST-2025-KEY-053-ALPHA-BRAVO-CHARLIE",
            "GHOST-2025-KEY-054-DELTA-ECHO-FOXTROT",
            "GHOST-2025-KEY-055-GOLF-HOTEL-INDIA",
            "GHOST-2025-KEY-056-JULIET-KILO-LIMA",
            "GHOST-2025-KEY-057-MIKE-NOVEMBER-OSCAR",
            "GHOST-2025-KEY-058-PAPA-QUEBEC-ROMEO",
            "GHOST-2025-KEY-059-SIERRA-TANGO-UNIFORM",
            "GHOST-2025-KEY-060-VICTOR-WHISKEY-XRAY",
            "GHOST-2025-KEY-061-YANKEE-ZULU-ALPHA",
            "GHOST-2025-KEY-062-BRAVO-CHARLIE-DELTA",
            "GHOST-2025-KEY-063-ECHO-FOXTROT-GOLF",
            "GHOST-2025-KEY-064-HOTEL-INDIA-JULIET",
            "GHOST-2025-KEY-065-KILO-LIMA-MIKE",
            "GHOST-2025-KEY-066-NOVEMBER-OSCAR-PAPA",
            "GHOST-2025-KEY-067-QUEBEC-ROMEO-SIERRA",
            "GHOST-2025-KEY-068-TANGO-UNIFORM-VICTOR",
            "GHOST-2025-KEY-069-WHISKEY-XRAY-YANKEE",
            "GHOST-2025-KEY-070-ZULU-ALPHA-BRAVO",
            "GHOST-2025-KEY-071-CHARLIE-DELTA-ECHO",
            "GHOST-2025-KEY-072-FOXTROT-GOLF-HOTEL",
            "GHOST-2025-KEY-073-INDIA-JULIET-KILO",
            "GHOST-2025-KEY-074-LIMA-MIKE-NOVEMBER",
            "GHOST-2025-KEY-075-OSCAR-PAPA-QUEBEC",
            "GHOST-2025-KEY-076-ROMEO-SIERRA-TANGO",
            "GHOST-2025-KEY-077-UNIFORM-VICTOR-WHISKEY",
            "GHOST-2025-KEY-078-XRAY-YANKEE-ZULU",
            "GHOST-2025-KEY-079-ALPHA-BRAVO-CHARLIE",
            "GHOST-2025-KEY-080-DELTA-ECHO-FOXTROT",
            "GHOST-2025-KEY-081-GOLF-HOTEL-INDIA",
            "GHOST-2025-KEY-082-JULIET-KILO-LIMA",
            "GHOST-2025-KEY-083-MIKE-NOVEMBER-OSCAR",
            "GHOST-2025-KEY-084-PAPA-QUEBEC-ROMEO",
            "GHOST-2025-KEY-085-SIERRA-TANGO-UNIFORM",
            "GHOST-2025-KEY-086-VICTOR-WHISKEY-XRAY",
            "GHOST-2025-KEY-087-YANKEE-ZULU-ALPHA",
            "GHOST-2025-KEY-088-BRAVO-CHARLIE-DELTA",
            "GHOST-2025-KEY-089-ECHO-FOXTROT-GOLF",
            "GHOST-2025-KEY-090-HOTEL-INDIA-JULIET",
            "GHOST-2025-KEY-091-KILO-LIMA-MIKE",
            "GHOST-2025-KEY-092-NOVEMBER-OSCAR-PAPA",
            "GHOST-2025-KEY-093-QUEBEC-ROMEO-SIERRA",
            "GHOST-2025-KEY-094-TANGO-UNIFORM-VICTOR",
            "GHOST-2025-KEY-095-WHISKEY-XRAY-YANKEE",
            "GHOST-2025-KEY-096-ZULU-ALPHA-BRAVO",
            "GHOST-2025-KEY-097-CHARLIE-DELTA-ECHO",
            "GHOST-2025-KEY-098-FOXTROT-GOLF-HOTEL",
            "GHOST-2025-KEY-099-INDIA-JULIET-KILO",
            "GHOST-2025-KEY-100-LIMA-MIKE-NOVEMBER"
        ];

        // Validate master key
        function validateMasterKey(key) {
            return MASTER_KEYS.includes(key.trim());
        }

        // Open chat selection popup
        function openChatSelection() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const roomId = urlParams.get('room');
                const password = urlParams.get('pass');

                // If there's a shared link, show join directly
                if (roomId && password) {
                    showJoinRoom(true, roomId, password);
                } else {
                    // Show selection popup
                    const modal = document.getElementById('chat-selection-modal');
                    if (modal) {
                        modal.classList.remove('hidden');
                    }
                    const notif = document.getElementById('ghost-notification-dot');
                    if (notif) {
                        notif.classList.add('hidden');
                    }
                    if (typeof lucide !== 'undefined' && lucide.createIcons) {
                        lucide.createIcons();
                    }
                }
            } catch (error) {
                console.error('Error in openChatSelection:', error);
                // Fallback to old method
                if (typeof openGhostComms === 'function') {
                    openGhostComms();
                }
            }
        }

        // Close chat selection popup
        function closeChatSelection() {
            try {
                const modal = document.getElementById('chat-selection-modal');
                if (modal) {
                    modal.classList.add('hidden');
                }
            } catch (error) {
                console.error('Error in closeChatSelection:', error);
            }
        }

        // Show create room interface
        function showCreateRoom() {
            try {
                closeChatSelection();
                const ghostModal = document.getElementById('ghost-modal');
                const joinPanel = document.getElementById('ghost-join-panel');
                if (ghostModal) ghostModal.classList.remove('hidden');
                if (joinPanel) joinPanel.classList.remove('hidden');
                // Scroll to create section
                const createSection = document.querySelector('#ghost-join-panel > div > div:first-child');
                if (createSection) {
                    createSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }
            } catch (error) {
                console.error('Error in showCreateRoom:', error);
            }
        }

        // Show join room interface
        function showJoinRoom(hasLink = false, roomId = null, password = null) {
            try {
                closeChatSelection();
                const ghostModal = document.getElementById('ghost-modal');
                const joinPanel = document.getElementById('ghost-join-panel');
                if (ghostModal) ghostModal.classList.remove('hidden');
                if (joinPanel) joinPanel.classList.remove('hidden');

                // If shared link, pre-fill room ID but require password confirmation
                if (hasLink && roomId) {
                    const roomIdField = document.getElementById('ghost-room-id-join');
                    if (roomIdField) {
                        roomIdField.value = roomId;
                    }
                    // Pre-fill password but user can still modify it
                    if (password) {
                        const passwordField = document.getElementById('ghost-password-join');
                        if (passwordField) {
                            passwordField.value = password;
                        }
                    }
                    // Focus on password field for confirmation
                    setTimeout(() => {
                        const passwordField = document.getElementById('ghost-password-join');
                        if (passwordField) {
                            passwordField.focus();
                            passwordField.select();
                        }
                    }, 300);
                }

                // Scroll to join section
                const joinSection = document.querySelector('#ghost-join-panel > div > div:last-child');
                if (joinSection) {
                    joinSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }
            } catch (error) {
                console.error('Error in showJoinRoom:', error);
            }
        }

        function openGhostComms() {
            document.getElementById('ghost-modal').classList.remove('hidden');
            document.getElementById('ghost-notification-dot').classList.add('hidden');
            lucide.createIcons();
        }

        function closeGhostComms() {
            document.getElementById('ghost-modal').classList.add('hidden');
        }

        // Check URL for room link (called on page load)
        function checkRoomLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room');
            const password = urlParams.get('pass');

            if (roomId && password) {
                // Auto-open join interface with pre-filled data
                showJoinRoom(true, roomId, password);
            }
        }

        // Generate shareable link
        function generateRoomLink(roomId, password) {
            const currentUrl = window.location.origin + window.location.pathname;
            return `${currentUrl}?room=${encodeURIComponent(roomId)}&pass=${encodeURIComponent(password)}`;
        }

        // Copy room link
        function copyRoomLink() {
            if (!ghostRoomId || !ghostRoomPassword) return;

            const link = generateRoomLink(ghostRoomId, ghostRoomPassword);
            navigator.clipboard.writeText(link).then(() => {
                const btn = document.getElementById('ghost-share-btn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i data-lucide="check" class="w-4 h-4"></i> Copied!';
                btn.classList.add('bg-emerald-600');
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('bg-emerald-600');
                }, 2000);
                lucide.createIcons();
            }).catch(() => {
                prompt("Copy this link:", link);
            });
        }

        // Join via link
        async function joinViaLink() {
            const urlParams = new URLSearchParams(window.location.search);
            let roomId = urlParams.get('room') || document.getElementById('ghost-room-id-join')?.value.trim();
            let password = urlParams.get('pass') || document.getElementById('ghost-password-join')?.value.trim();
            const handle = document.getElementById('ghost-handle-join').value.trim();

            if (!roomId || !password || !handle) {
                alert("Please fill in all fields or use a shared link.");
                return;
            }

            isRoomCreator = false;
            await joinGhostRoomDirect(roomId, password, handle);
        }

        // Create room (requires master key)
        async function createGhostRoom() {
            const masterKey = document.getElementById('ghost-master-key').value.trim();
            const roomId = document.getElementById('ghost-room-id-create').value.trim();
            const password = document.getElementById('ghost-password-create').value.trim();
            const handle = document.getElementById('ghost-handle-create').value.trim();

            if (!masterKey || !roomId || !password || !handle) {
                alert("Please fill in all fields.");
                return;
            }

            if (!validateMasterKey(masterKey)) {
                alert("Invalid master key. Only authorized users can create rooms.");
                return;
            }

            // Get room settings
            ghostRoomSettings = {
                enableDownload: document.getElementById('ghost-enable-download').checked,
                enableDelete: document.getElementById('ghost-enable-delete').checked,
                enableGifs: document.getElementById('ghost-enable-gifs').checked
            };

            isRoomCreator = true;
            await joinGhostRoomDirect(roomId, password, handle, true);
        }

        // PBKDF2 Key Derivation (100,000 iterations) - Global scope
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );

            const key = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: encoder.encode(salt),
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                passwordKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );

            return key;
        }

        // AES-GCM Encryption - Global scope (with emoji support via UTF-8)
        async function encryptMessage(text, key) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text); // UTF-8 encoding handles emojis properly

            // Generate random IV (12 bytes for GCM)
            const iv = crypto.getRandomValues(new Uint8Array(12));

            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );

            // Return IV + encrypted data as base64
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);

            return {
                iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join(''),
                data: btoa(String.fromCharCode(...combined))
            };
        }

        // AES-GCM Decryption - Global scope (with emoji support via UTF-8)
        async function decryptMessage(encryptedData, ivHex, key) {
            try {
                const iv = new Uint8Array(ivHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));

                // Extract actual encrypted data (skip IV)
                const encrypted = data.slice(12);

                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );

                const decoder = new TextDecoder('utf-8'); // Explicit UTF-8 for emoji support
                return decoder.decode(decrypted);
            } catch (error) {
                throw new Error('Decryption failed - wrong password or corrupted data');
            }
        }

        // Direct join function
        async function joinGhostRoomDirect(roomId, password, handle, isCreating = false) {

            // Wait a moment for Firebase to initialize if needed
            if (!window.firebaseDB) {
                await new Promise(resolve => setTimeout(resolve, 500));
                if (!window.firebaseDB) {
                    alert("Firebase not initialized. Please check your Firebase configuration and ensure Firestore Database is created.");
                    return;
                }
            }

            try {
                // Derive encryption key from password + room ID
                ghostCryptoKey = await deriveKey(password, roomId);
                ghostRoomId = roomId;
                ghostHandle = handle;
                ghostRoomPassword = password;

                // Save or load room settings
                if (isCreating) {
                    // Save room settings when creating
                    const roomSettingsRef = window.firebaseCollection(window.firebaseDB, `rooms/${roomId}/settings`);
                    await window.firebaseAddDoc(roomSettingsRef, {
                        ...ghostRoomSettings,
                        createdAt: window.firebaseServerTimestamp(),
                        creator: handle
                    });
                } else {
                    // Load room settings when joining
                    try {
                        const roomSettingsRef = window.firebaseCollection(window.firebaseDB, `rooms/${roomId}/settings`);
                        const roomSettingsQuery = window.firebaseQuery(roomSettingsRef, window.firebaseOrderBy('createdAt', 'desc'));
                        const roomSnapshot = await new Promise((resolve) => {
                            const unsubscribe = window.firebaseOnSnapshot(roomSettingsQuery, (snapshot) => {
                                unsubscribe();
                                resolve(snapshot);
                            });
                        });

                        if (!roomSnapshot.empty) {
                            const roomData = roomSnapshot.docs[0].data();
                            ghostRoomSettings = {
                                enableDownload: roomData.enableDownload || false,
                                enableDelete: roomData.enableDelete || false,
                                enableGifs: roomData.enableGifs || false
                            };
                        }
                    } catch (e) {
                        console.warn('Could not load room settings:', e);
                    }
                }

                // Hide join panel, show share button and disconnect
                document.getElementById('ghost-join-panel').classList.add('hidden');
                if (isRoomCreator) {
                    document.getElementById('ghost-share-btn').classList.remove('hidden');
                }
                document.getElementById('ghost-disconnect-btn').classList.remove('hidden');

                // Update chat header
                document.getElementById('ghost-room-display').textContent = roomId;
                document.getElementById('ghost-room-status').textContent = `Connected as ${handle}${isRoomCreator ? ' (Creator)' : ''}`;
                document.getElementById('ghost-encryption-indicator').className = 'w-2 h-2 rounded-full bg-emerald-500 animate-pulse';

                // Enable messaging and features based on settings
                document.getElementById('ghost-message-input').disabled = false;
                document.getElementById('ghost-send-btn').disabled = false;
                document.getElementById('ghost-emoji-btn').disabled = false;
                document.getElementById('ghost-audio-btn').disabled = false;

                // Enable download button if feature is enabled
                if (ghostRoomSettings.enableDownload) {
                    document.getElementById('ghost-download-btn').classList.remove('hidden');
                }

                // Enable GIF button (always show, allows file upload even if feature disabled)
                document.getElementById('ghost-gif-btn').classList.remove('hidden');
                document.getElementById('ghost-gif-btn').disabled = false;

                // Always show Chaos and Sonic buttons (they're fun features)
                document.getElementById('ghost-chaos-btn').classList.remove('hidden');
                document.getElementById('ghost-sonic-btn').classList.remove('hidden');

                // Enable call button and listen for incoming calls
                // Wait a bit before starting to listen to avoid showing old calls
                setTimeout(() => {
                    document.getElementById('ghost-call-btn').classList.remove('hidden');
                    listenForIncomingCalls();
                }, 2000);

                // Initialize emoji picker
                initializeEmojiPicker();

                // Clear messages
                document.getElementById('ghost-messages').innerHTML = '';

                // Listen for new messages
                const messagesRef = window.firebaseCollection(window.firebaseDB, `rooms/${roomId}/messages`);
                const q = window.firebaseQuery(messagesRef, window.firebaseOrderBy('timestamp', 'asc'));

                ghostUnsubscribe = window.firebaseOnSnapshot(q, async (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added') {
                            const msgData = change.doc.data();
                            await displayGhostMessage(msgData, change.doc.id);
                        } else if (change.type === 'modified') {
                            // Handle message updates (for deleted messages)
                            const msgData = change.doc.data();
                            if (msgData.deleted) {
                                updateMessageDisplay(change.doc.id, true);
                            }
                        }
                    });
                });

                // Show success
                addSystemMessage(`Joined room "${roomId}" as "${handle}"`);

            } catch (error) {
                console.error('Join error:', error);
                alert("Error joining room: " + error.message);
            }
        }

        // Get user initials for avatar
        function getUserInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        // Get color for user
        function getUserColor(name) {
            if (!name) return 'emerald';
            const colors = ['emerald', 'blue', 'purple', 'rose', 'cyan', 'amber', 'indigo'];
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Display encrypted message
        async function displayGhostMessage(msgData, messageId) {
            try {
                // Check if message is deleted
                if (msgData.deleted) {
                    const messagesDiv = document.getElementById('ghost-messages');
                    const existingMsg = document.getElementById(`msg-${messageId}`);
                    if (existingMsg) {
                        existingMsg.innerHTML = `
                            <div class="flex items-center gap-2 text-zinc-600 italic text-sm py-2">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                                <span>This message was deleted</span>
                            </div>
                        `;
                        lucide.createIcons();
                    }
                    return;
                }

                const decrypted = await decryptMessage(msgData.data, msgData.iv, ghostCryptoKey);
                const messagesDiv = document.getElementById('ghost-messages');

                // Remove "join a room" placeholder if exists
                const placeholder = messagesDiv.querySelector('.text-center');
                if (placeholder) placeholder.remove();

                const isOwnMessage = msgData.sender === ghostHandle;
                const senderName = msgData.sender || 'Unknown';
                const timestamp = msgData.timestamp?.toDate() || new Date();
                const timeStr = timestamp.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                const dateStr = timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const isToday = new Date().toDateString() === timestamp.toDateString();
                const isGif = msgData.isGif || false;
                const isAudio = msgData.isAudio || false;
                const mediaType = msgData.mediaType || 'gif';

                const userColor = getUserColor(senderName);
                const colorClasses = {
                    emerald: 'bg-emerald-600/20 text-emerald-400 border-emerald-600/30',
                    blue: 'bg-blue-600/20 text-blue-400 border-blue-600/30',
                    purple: 'bg-purple-600/20 text-purple-400 border-purple-600/30',
                    rose: 'bg-rose-600/20 text-rose-400 border-rose-600/30',
                    cyan: 'bg-cyan-600/20 text-cyan-400 border-cyan-600/30',
                    amber: 'bg-amber-600/20 text-amber-400 border-amber-600/30',
                    indigo: 'bg-indigo-600/20 text-indigo-400 border-indigo-600/30'
                };

                const msgDiv = document.createElement('div');
                msgDiv.id = `msg-${messageId}`;
                msgDiv.className = `message-bubble flex gap-2 ${isOwnMessage ? 'flex-row-reverse' : 'flex-row'} max-w-[85%] group`;

                let messageContent = '';
                if (isGif) {
                    if (mediaType === 'video') {
                        messageContent = `<video src="${decrypted}" alt="Video" class="max-w-full rounded-lg" style="max-height: 300px; object-fit: contain;" controls autoplay loop muted playsinline></video>`;
                    } else {
                        messageContent = `<img src="${decrypted}" alt="GIF" class="max-w-full rounded-lg" style="max-height: 300px; object-fit: contain;">`;
                    }
                } else if (isAudio && mediaType === 'audio') {
                    messageContent = `<audio src="${decrypted}" controls class="w-full max-w-sm" style="outline: none;" preload="auto">
                        <p class="text-xs text-zinc-500">Your browser does not support audio playback.</p>
                    </audio>`;
                } else {
                    messageContent = `<p class="text-sm break-words whitespace-pre-wrap" style="unicode-bidi: plaintext;">${decrypted}</p>`;
                }

                if (!isOwnMessage) {
                    // Avatar for other users
                    msgDiv.innerHTML = `
                        <div class="flex-shrink-0 w-8 h-8 rounded-full ${colorClasses[userColor]} border flex items-center justify-center text-xs font-bold">
                            ${getUserInitials(senderName)}
                        </div>
                        <div class="flex flex-col gap-1 flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <span class="text-xs font-semibold text-zinc-400">${senderName}</span>
                                <span class="text-[10px] text-zinc-600">${isToday ? timeStr : dateStr + ' ' + timeStr}</span>
                            </div>
                            <div class="message-other rounded-2xl px-4 py-2.5 shadow-lg">
                                ${messageContent}
                            </div>
                        </div>
                    `;
                } else {
                    // Own message (no avatar, right-aligned)
                    const deleteBtn = ghostRoomSettings.enableDelete ?
                        `<button onclick="deleteGhostMessage('${messageId}')" class="opacity-0 group-hover:opacity-100 transition-opacity text-zinc-500 hover:text-rose-500 p-1">
                            <i data-lucide="trash-2" class="w-3 h-3"></i>
                        </button>` : '';

                    msgDiv.innerHTML = `
                        <div class="flex flex-col gap-1 flex-1 min-w-0 items-end">
                            <div class="message-own rounded-2xl px-4 py-2.5 shadow-lg max-w-full relative">
                                ${messageContent}
                            </div>
                            <div class="flex items-center gap-1.5">
                                ${deleteBtn}
                                <span class="text-[10px] text-zinc-600">${isToday ? timeStr : dateStr + ' ' + timeStr}</span>
                                <i data-lucide="check-check" class="w-3 h-3 text-emerald-500"></i>
                            </div>
                        </div>
                    `;
                }

                messagesDiv.appendChild(msgDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                lucide.createIcons();
            } catch (error) {
                console.error('Decryption error:', error);
                addSystemMessage(`Failed to decrypt message from ${msgData.sender || 'Unknown'}`);
            }
        }

        // Update message display (for deleted messages)
        function updateMessageDisplay(messageId, isDeleted) {
            const msgDiv = document.getElementById(`msg-${messageId}`);
            if (msgDiv && isDeleted) {
                msgDiv.innerHTML = `
                    <div class="flex items-center gap-2 text-zinc-600 italic text-sm py-2">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                        <span>This message was deleted</span>
                    </div>
                `;
                lucide.createIcons();
            }
        }

        // Send encrypted message
        async function sendGhostMessage(messageText = null, isGif = false, mediaType = 'gif') {
            const messageInput = document.getElementById('ghost-message-input');
            const message = messageText || messageInput.value.trim();

            if (!message || !ghostCryptoKey) {
                console.warn('Cannot send: no message or crypto key');
                return;
            }

            if (!ghostRoomId) {
                alert("Not connected to a room. Please join or create a room first.");
                return;
            }

            try {
                // Disable input while sending
                const sendBtn = document.getElementById('ghost-send-btn');
                sendBtn.disabled = true;
                sendBtn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i>';
                lucide.createIcons();

                const encrypted = await encryptMessage(message, ghostCryptoKey);

                const messageData = {
                    sender: ghostHandle,
                    timestamp: window.firebaseServerTimestamp(),
                    iv: encrypted.iv,
                    data: encrypted.data
                };

                if (isGif) {
                    messageData.isGif = true;
                    messageData.mediaType = mediaType; // 'gif' or 'video'
                } else if (mediaType === 'audio') {
                    messageData.isAudio = true;
                    messageData.mediaType = 'audio';
                }

                await window.firebaseAddDoc(
                    window.firebaseCollection(window.firebaseDB, `rooms/${ghostRoomId}/messages`),
                    messageData
                );

                if (!messageText) {
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                }
                const charCount = document.getElementById('ghost-char-count');
                if (charCount) {
                    const currentLength = messageText ? messageText.length : 0;
                    charCount.textContent = currentLength;
                }

                // Re-enable send button
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i data-lucide="send" class="w-4 h-4"></i>';
                lucide.createIcons();
            } catch (error) {
                console.error('Send error:', error);
                alert("Error sending message: " + error.message);

                // Re-enable send button on error
                const sendBtn = document.getElementById('ghost-send-btn');
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i data-lucide="send" class="w-4 h-4"></i>';
                lucide.createIcons();
            }
        }

        // Delete message (for everyone)
        async function deleteGhostMessage(messageId) {
            if (!ghostRoomSettings.enableDelete) {
                alert("Delete messages feature is not enabled in this room.");
                return;
            }

            if (!confirm("Delete this message for everyone?")) {
                return;
            }

            try {
                const messageDocRef = window.firebaseDoc(window.firebaseDB, 'rooms', ghostRoomId, 'messages', messageId);
                await window.firebaseUpdateDoc(messageDocRef, {
                    deleted: true,
                    deletedBy: ghostHandle,
                    deletedAt: window.firebaseServerTimestamp()
                });

                // Update display immediately
                updateMessageDisplay(messageId, true);
            } catch (error) {
                console.error('Delete error:', error);
                alert("Error deleting message: " + error.message);
            }
        }

        // Download chat history
        async function downloadChatHistory() {
            if (!ghostRoomSettings.enableDownload) {
                alert("Download chat history feature is not enabled in this room.");
                return;
            }

            try {
                const messagesRef = window.firebaseCollection(window.firebaseDB, `rooms/${ghostRoomId}/messages`);
                const q = window.firebaseQuery(messagesRef, window.firebaseOrderBy('timestamp', 'asc'));

                const messagesSnapshot = await window.firebaseGetDocs(q);

                let chatHistory = `Ghost Comms Chat History - Room: ${ghostRoomId}\n`;
                chatHistory += `Exported on: ${new Date().toLocaleString()}\n`;
                chatHistory += `==========================================\n\n`;

                for (const doc of messagesSnapshot.docs) {
                    const msgData = doc.data();
                    if (msgData.deleted) {
                        chatHistory += `[DELETED] ${msgData.sender || 'Unknown'}: This message was deleted\n`;
                        continue;
                    }

                    try {
                        const decrypted = await decryptMessage(msgData.data, msgData.iv, ghostCryptoKey);
                        const timestamp = msgData.timestamp?.toDate() || new Date();
                        const timeStr = timestamp.toLocaleString();
                        chatHistory += `[${timeStr}] ${msgData.sender || 'Unknown'}: ${decrypted}\n`;
                    } catch (e) {
                        chatHistory += `[ERROR] ${msgData.sender || 'Unknown'}: Failed to decrypt message\n`;
                    }
                }

                // Download as file
                const blob = new Blob([chatHistory], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `ghost-comms-${ghostRoomId}-${Date.now()}.txt`;
                link.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert("Error downloading chat history: " + error.message);
            }
        }

        // Emoji picker functions - Comprehensive categories
        const emojiCategories = {
            smileys: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            gestures: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            hearts: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            celebration: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            symbols: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            animals: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            food: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            activities: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
        };
        let currentEmojiCategory = 'smileys';

        function initializeEmojiPicker() {
            loadEmojiCategory('smileys');
        }

        function loadEmojiCategory(category) {
            const emojiGrid = document.getElementById('ghost-emoji-grid');
            if (!emojiGrid) return;

            currentEmojiCategory = category;

            // Update tab styles
            document.querySelectorAll('[id^="emoji-tab-"]').forEach(btn => {
                btn.className = 'px-2 py-1 text-lg rounded hover:bg-zinc-800';
            });
            const activeTab = document.getElementById(`emoji-tab-${category}`);
            if (activeTab) {
                activeTab.className = 'px-2 py-1 text-lg rounded bg-emerald-600';
            }

            // Load emojis for category
            const emojis = emojiCategories[category] || emojiCategories.smileys;
            emojiGrid.innerHTML = '';
            emojis.forEach(emoji => {
                const emojiBtn = document.createElement('button');
                emojiBtn.className = 'w-8 h-8 text-xl hover:bg-zinc-800 rounded transition-colors flex items-center justify-center';
                emojiBtn.textContent = emoji;
                emojiBtn.onclick = () => insertEmoji(emoji);
                emojiGrid.appendChild(emojiBtn);
            });
        }

        function toggleEmojiPicker() {
            const picker = document.getElementById('ghost-emoji-picker');
            const gifPicker = document.getElementById('ghost-gif-picker');
            if (gifPicker) gifPicker.classList.add('hidden');
            if (picker) {
                picker.classList.toggle('hidden');
                // Initialize with first category if opening
                if (!picker.classList.contains('hidden') && document.getElementById('ghost-emoji-grid').children.length === 0) {
                    loadEmojiCategory('smileys');
                }
            }
        }

        function insertEmoji(emoji) {
            const messageInput = document.getElementById('ghost-message-input');
            const cursorPos = messageInput.selectionStart;
            const textBefore = messageInput.value.substring(0, cursorPos);
            const textAfter = messageInput.value.substring(cursorPos);
            messageInput.value = textBefore + emoji + textAfter;
            messageInput.selectionStart = messageInput.selectionEnd = cursorPos + emoji.length;
            messageInput.focus();

            // Update character count
            const charCount = document.getElementById('ghost-char-count');
            if (charCount) charCount.textContent = messageInput.value.length;

            // Close picker
            document.getElementById('ghost-emoji-picker').classList.add('hidden');
        }

        // GIF picker functions
        let gifSearchTimeout = null;
        let currentGifCategory = 'trending';
        const GIPHY_API_KEY = 'dc6zaTOxFJmzC'; // Public API key for GIPHY

        // Load GIFs by category
        async function loadGifCategory(category) {
            if (!ghostRoomSettings.enableGifs) return;

            currentGifCategory = category;

            // Update tab styles
            document.querySelectorAll('[id^="gif-tab-"]').forEach(btn => {
                btn.className = 'px-3 py-1.5 text-xs font-medium rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 whitespace-nowrap';
            });
            const activeTab = document.getElementById(`gif-tab-${category}`);
            if (activeTab) {
                activeTab.className = 'px-3 py-1.5 text-xs font-medium rounded-lg bg-emerald-600 text-white whitespace-nowrap';
            }

            const categoryQueries = {
                'trending': '',
                'reactions': 'reactions',
                'funny': 'funny',
                'love': 'love'
            };

            await searchGifs(categoryQueries[category] || '');
        }

        async function searchGifs(query) {
            if (!ghostRoomSettings.enableGifs) return;

            const gridDiv = document.getElementById('ghost-gif-grid');
            const loadingDiv = document.getElementById('ghost-gif-loading');

            if (!gridDiv) return;

            // Show loading
            gridDiv.innerHTML = '';
            loadingDiv.classList.remove('hidden');

            try {
                let url;
                if (query && query.trim().length > 0) {
                    url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=30&rating=g`;
                } else {
                    url = `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=30&rating=g`;
                }

                const response = await fetch(url);
                const data = await response.json();

                loadingDiv.classList.add('hidden');

                if (data.data && data.data.length > 0) {
                    gridDiv.innerHTML = '';

                    data.data.forEach(gif => {
                        const gifItem = document.createElement('div');
                        gifItem.className = 'relative group cursor-pointer rounded-lg overflow-hidden bg-zinc-800 hover:ring-2 hover:ring-emerald-500 transition-all aspect-square';
                        gifItem.innerHTML = `
                            <img src="${gif.images.fixed_height_small.url}" 
                                 alt="${gif.title || 'GIF'}" 
                                 class="w-full h-full object-cover"
                                 loading="lazy">
                            <div class="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors flex items-center justify-center">
                                <i data-lucide="play" class="w-6 h-6 text-white opacity-0 group-hover:opacity-100 transition-opacity"></i>
                            </div>
                        `;
                        gifItem.onclick = () => sendGif(gif.images.original.url, gif.images.original.mp4);
                        gridDiv.appendChild(gifItem);
                    });

                    lucide.createIcons();
                } else {
                    gridDiv.innerHTML = '<div class="col-span-2 text-center py-8"><p class="text-zinc-500 text-sm">No GIFs found</p></div>';
                }
            } catch (error) {
                console.error('GIF search error:', error);
                loadingDiv.classList.add('hidden');
                gridDiv.innerHTML = '<div class="col-span-2 text-center py-8"><p class="text-red-500 text-sm">Error loading GIFs</p></div>';
            }
        }

        function toggleGifPicker() {
            if (!ghostRoomSettings.enableGifs) {
                // If GIFs not enabled, allow file upload
                document.getElementById('ghost-gif-upload').click();
                return;
            }

            const picker = document.getElementById('ghost-gif-picker');
            const emojiPicker = document.getElementById('ghost-emoji-picker');
            if (emojiPicker) emojiPicker.classList.add('hidden');
            if (picker) {
                const isHidden = picker.classList.contains('hidden');
                picker.classList.toggle('hidden');

                if (!isHidden) {
                    // Opening picker - load trending GIFs
                    loadGifCategory('trending');
                }
            }
        }

        function sendGif(gifUrl, videoUrl = null) {
            if (!ghostRoomSettings.enableGifs) {
                alert("GIF feature is not enabled in this room.");
                return;
            }

            // Prefer video URL if available, otherwise use GIF
            const mediaUrl = videoUrl || gifUrl;
            sendGhostMessage(mediaUrl, true, videoUrl ? 'video' : 'gif');
            document.getElementById('ghost-gif-picker').classList.add('hidden');
        }

        // Handle GIF file upload
        function handleGifUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!ghostRoomSettings.enableGifs) {
                alert("GIF feature is not enabled in this room.");
                return;
            }

            // Check if it's a GIF or video
            const isVideo = file.type.startsWith('video/');
            const isGif = file.type === 'image/gif';

            if (!isGif && !isVideo) {
                alert("Please select a GIF or video file.");
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const dataUrl = e.target.result;
                sendGhostMessage(dataUrl, true, isVideo ? 'video' : 'gif');
            };
            reader.readAsDataURL(file);

            // Reset input
            event.target.value = '';
        }

        // Audio Recording Functions
        let audioRecorder = null;
        let audioStream = null;
        let isRecording = false;

        async function toggleAudioRecord() {
            if (isRecording) {
                stopAudioRecording();
            } else {
                await startAudioRecording();
            }
        }

        async function startAudioRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                audioStream = stream;
                audioRecorder = new MediaRecorder(stream);
                const chunks = [];

                audioRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };

                audioRecorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onload = async function (e) {
                        const audioDataUrl = e.target.result;
                        // Send as base64 encoded audio
                        await sendGhostMessage(audioDataUrl, false, 'audio');
                    };
                    reader.readAsDataURL(blob);

                    // Stop all tracks
                    if (audioStream) {
                        audioStream.getTracks().forEach(track => track.stop());
                        audioStream = null;
                    }
                };

                audioRecorder.start();
                isRecording = true;

                // Update button
                const btn = document.getElementById('ghost-audio-btn');
                if (btn) {
                    btn.innerHTML = '<i data-lucide="mic-off" class="w-5 h-5"></i>';
                    btn.classList.add('bg-red-600', 'animate-pulse');
                    btn.classList.remove('bg-zinc-800');
                    lucide.createIcons();
                }
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Could not access microphone. Please allow permissions.');
            }
        }

        function stopAudioRecording() {
            if (audioRecorder && isRecording) {
                audioRecorder.stop();
                isRecording = false;

                // Update button
                const btn = document.getElementById('ghost-audio-btn');
                if (btn) {
                    btn.innerHTML = '<i data-lucide="mic" class="w-5 h-5"></i>';
                    btn.classList.remove('bg-red-600', 'animate-pulse');
                    btn.classList.add('bg-zinc-800');
                    lucide.createIcons();
                }
            }
        }

        // Setup GIF search
        document.addEventListener('DOMContentLoaded', () => {
            const gifSearch = document.getElementById('ghost-gif-search');
            if (gifSearch) {
                gifSearch.addEventListener('input', (e) => {
                    clearTimeout(gifSearchTimeout);
                    const query = e.target.value.trim();

                    if (query.length === 0) {
                        // If search is cleared, reload current category
                        loadGifCategory(currentGifCategory);
                    } else if (query.length >= 2) {
                        gifSearchTimeout = setTimeout(() => {
                            searchGifs(query);
                        }, 500);
                    }
                });

                gifSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const query = gifSearch.value.trim();
                        if (query.length > 0) {
                            searchGifs(query);
                        }
                    }
                });
            }
        });

        // Firebase is already initialized in the module script at the top of the file
        // window.firebaseDB and other functions are available globally
        function disconnectGhost() {
            if (ghostUnsubscribe) {
                ghostUnsubscribe();
                ghostUnsubscribe = null;
            }

            ghostCryptoKey = null;
            ghostRoomId = null;
            ghostHandle = null;
            ghostRoomPassword = null;
            isRoomCreator = false;

            // Show join panel again
            document.getElementById('ghost-join-panel').classList.remove('hidden');
            document.getElementById('ghost-share-btn').classList.add('hidden');
            document.getElementById('ghost-disconnect-btn').classList.add('hidden');

            // Reset chat header
            document.getElementById('ghost-room-display').textContent = 'Not Connected';
            document.getElementById('ghost-room-status').textContent = 'Join or create a room to start';
            document.getElementById('ghost-encryption-indicator').className = 'w-2 h-2 rounded-full bg-zinc-700';

            // Disable messaging
            document.getElementById('ghost-message-input').disabled = true;
            document.getElementById('ghost-send-btn').disabled = true;

            // Clear messages
            document.getElementById('ghost-messages').innerHTML = `
                <div class="text-center text-zinc-600 text-sm py-12">
                    <div class="w-16 h-16 bg-emerald-600/10 rounded-full flex items-center justify-center mx-auto mb-3 border border-emerald-600/20">
                        <i data-lucide="message-square-lock" class="w-8 h-8 text-emerald-500/50"></i>
                    </div>
                    <p class="font-medium">Join or create a room to start messaging</p>
                    <p class="text-xs text-zinc-700 mt-1">Messages are end-to-end encrypted</p>
                </div>
            `;
            lucide.createIcons();
        }

        // Setup chat button click handler
        function setupChatButton() {
            const chatBtn = document.getElementById('ghost-float-btn');
            if (chatBtn) {
                chatBtn.onclick = function () {
                    if (typeof openChatSelection === 'function') {
                        openChatSelection();
                    } else if (typeof openGhostComms === 'function') {
                        openGhostComms();
                    } else {
                        console.error('Chat functions not available');
                    }
                };
            }
        }

        // Check for room link on page load
        window.addEventListener('DOMContentLoaded', () => {
            try {
                setupChatButton();
                checkRoomLink();

                // Initialize Lucide icons
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }

                // Display master keys in console (for you to copy)
                console.log('%c MASTER KEYS (100 Lifetime Keys)', 'color: #10b981; font-size: 16px; font-weight: bold;');
                console.log('%cCopy these keys - they have lifetime validity:', 'color: #a1a1aa; font-size: 12px;');
                MASTER_KEYS.forEach((key, index) => {
                    console.log(`${(index + 1).toString().padStart(3, '0')}. ${key}`);
                });
            } catch (error) {
                console.error('Error during page initialization:', error);
            }
        });

        // Also try to setup immediately if DOM is already loaded
        if (document.readyState === 'loading') {
            // DOM is still loading, wait for DOMContentLoaded
        } else {
            // DOM is already loaded, setup immediately
            setupChatButton();
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons();
            }
        }

        // Add system message
        function addSystemMessage(text) {
            const messagesDiv = document.getElementById('ghost-messages');
            const placeholder = messagesDiv.querySelector('.text-center');
            if (placeholder) placeholder.remove();

            const msgDiv = document.createElement('div');
            msgDiv.className = 'message-bubble text-center py-3';
            msgDiv.innerHTML = `
                <div class="inline-flex items-center gap-2 bg-zinc-800/50 border border-zinc-700 rounded-full px-4 py-1.5">
                    <i data-lucide="info" class="w-3 h-3 text-zinc-500"></i>
                    <span class="text-xs text-zinc-500 font-medium">${text}</span>
                </div>
            `;
            messagesDiv.appendChild(msgDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            lucide.createIcons();
        }

        // Auto-resize textarea and character counter
        document.addEventListener('DOMContentLoaded', () => {
            const messageInput = document.getElementById('ghost-message-input');
            const charCount = document.getElementById('ghost-char-count');
            const messagesDiv = document.getElementById('ghost-messages');

            // Fix scroll in messages area
            if (messagesDiv) {
                messagesDiv.addEventListener('wheel', (e) => {
                    e.stopPropagation();
                }, { passive: true });

                // Ensure scroll works
                messagesDiv.style.overflowY = 'auto';
                messagesDiv.style.overflowX = 'hidden';
            }

            if (messageInput) {
                // Auto-resize textarea
                messageInput.addEventListener('input', (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = Math.min(e.target.scrollHeight, 120) + 'px';

                    // Update character count (no limit)
                    if (charCount) {
                        const count = e.target.value.length;
                        charCount.textContent = count;
                        charCount.className = 'text-[10px] text-zinc-700';
                    }
                });

                // Enter to send, Shift+Enter for new line
                messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        if (messageInput.value.trim() && !messageInput.disabled) {
                            sendGhostMessage();
                        }
                    }
                });

                // Windows Emoji Picker Support (Win + . or Win + ;)
                messageInput.addEventListener('keydown', (e) => {
                    // Note: Windows emoji picker is handled by OS, but we ensure the input accepts it
                    // The OS will insert emojis directly into the input field
                });
            }
        });

        // ============================================
        // THE UPLINK - WebRTC Voice Calling Module with Advanced Echo Cancellation
        // ============================================
        let peerConnection = null;
        let localStream = null;
        let remoteAudioElement = null;
        let callId = null;
        let callUnsubscribe = null;
        let answerUnsubscribe = null;
        let offerCandidatesUnsubscribe = null;
        let answerCandidatesUnsubscribe = null;
        let isCaller = false;
        let callActive = false;

        // Web Audio API components for echo cancellation
        let callAudioContext = null;
        let remoteAudioSource = null;
        let remoteGainNode = null;
        let remoteAnalyser = null;
        let localAudioSource = null;
        let localAnalyser = null;
        let echoCancellationNode = null;
        let compressorNode = null;
        let limiterNode = null;
        let destinationNode = null;

        // Mobile audio check interval
        let mobileAudioCheckInterval = null;

        // Mobile background audio handling
        let wakeLock = null;
        let wasCallActiveBeforeBackground = false;

        // Request Wake Lock to prevent screen sleep during calls (mobile)
        async function requestWakeLock() {
            if (!isMobile || !('wakeLock' in navigator)) return;

            try {
                wakeLock = await navigator.wakeLock.request('screen');
                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock released');
                });
                console.log('Wake Lock acquired - screen will stay on during call');
            } catch (err) {
                console.warn('Wake Lock request failed:', err);
            }
        }

        // Release Wake Lock
        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
        }

        // Handle visibility change (mobile browser goes to background)
        document.addEventListener('visibilitychange', async () => {
            if (!callActive) return;

            if (document.hidden) {
                // App went to background
                console.log('App went to background during call');
                wasCallActiveBeforeBackground = true;

                // Notify other user that mic is paused (on mobile)
                if (isMobile && ghostRoomId) {
                    try {
                        const timestamp = Date.now();
                        // Store mic pause status in call document
                        if (callId && window.firebaseDB) {
                            const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                            await window.firebaseUpdateDoc(callDocRef, {
                                [`micPaused_${ghostHandle}`]: true,
                                [`micPausedAt_${ghostHandle}`]: timestamp
                            });
                        }
                    } catch (e) {
                        console.warn('Could not update mic pause status:', e);
                    }
                }
            } else {
                // App came to foreground
                console.log('App came to foreground during call');

                // Re-initialize audio if we were in a call
                if (wasCallActiveBeforeBackground && callActive) {
                    console.log('Attempting to restore audio after background...');

                    // Try to resume audio context
                    if (callAudioContext && callAudioContext.state === 'suspended') {
                        try {
                            await callAudioContext.resume();
                            console.log('Audio context resumed');
                        } catch (e) {
                            console.error('Failed to resume audio context:', e);
                        }
                    }

                    // Re-acquire microphone if tracks were stopped
                    if (localStream) {
                        const audioTracks = localStream.getAudioTracks();
                        const needsReInit = audioTracks.length === 0 ||
                            audioTracks.every(track => track.readyState === 'ended' || !track.enabled);

                        if (needsReInit && peerConnection) {
                            console.log('Audio tracks were stopped, re-initializing mic...');
                            try {
                                // Get new audio stream
                                const constraints = await getEnhancedMediaConstraints();
                                const newStream = await navigator.mediaDevices.getUserMedia(constraints);

                                // Replace tracks in peer connection
                                const senders = peerConnection.getSenders();
                                const audioSender = senders.find(s => s.track?.kind === 'audio');

                                if (audioSender && newStream.getAudioTracks()[0]) {
                                    await audioSender.replaceTrack(newStream.getAudioTracks()[0]);
                                    console.log('Audio track replaced successfully');

                                    // Update local stream reference
                                    localStream.getAudioTracks().forEach(t => t.stop());
                                    localStream = newStream;

                                    // Setup monitoring
                                    setupLocalAudioMonitoring(localStream);
                                }
                            } catch (e) {
                                console.error('Failed to re-initialize mic:', e);
                                // Don't cleanup call - let user know audio may not work
                                alert('Your microphone was paused while in background. The other person may not hear you. Please check your audio.');
                            }
                        }
                    }

                    // Update mic pause status
                    if (isMobile && callId && window.firebaseDB) {
                        try {
                            const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                            await window.firebaseUpdateDoc(callDocRef, {
                                [`micPaused_${ghostHandle}`]: false
                            });
                        } catch (e) {
                            console.warn('Could not update mic resume status:', e);
                        }
                    }
                }

                wasCallActiveBeforeBackground = false;

                // Re-acquire wake lock
                if (callActive) {
                    requestWakeLock();
                }
            }
        });

        // Device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isAndroid = /Android/.test(navigator.userAgent);

        // ICE Servers Configuration (STUN + Free TURN servers for better NAT traversal)
        const iceServers = {
            iceServers: [
                // Google STUN servers (free)
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                // OpenRelay FREE TURN server (no credentials needed for basic use)
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                // Twilio free STUN
                { urls: 'stun:global.stun.twilio.com:3478' }
            ],
            iceCandidatePoolSize: 10
        };

        // Enhanced Media Constraints with maximum echo cancellation
        const getMediaConstraints = () => {
            const baseConstraints = {
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    // Additional constraints for better echo cancellation
                    googEchoCancellation: true,
                    googNoiseSuppression: true,
                    googAutoGainControl: true,
                    googHighpassFilter: true,
                    googTypingNoiseDetection: true,
                    googNoiseReduction: true,
                    // Sample rate for better quality
                    sampleRate: 48000,
                    channelCount: 1,
                    // Latency settings
                    latency: 0.01,
                    googAudioMirroring: false
                }
            };

            // Mobile-specific optimizations
            if (isMobile) {
                baseConstraints.audio.sampleRate = 16000; // Lower sample rate for mobile
                baseConstraints.audio.latency = 0.02;
            }

            // Video settings based on call mode
            if (currentCallMode === 'video') {
                if (isMobile) {
                    // Use simple constraints for mobile - complex ones can cause issues
                    baseConstraints.video = {
                        facingMode: 'user',
                        width: 640,
                        height: 480
                    };
                } else {
                    baseConstraints.video = {
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 30, max: 60 },
                        facingMode: 'user'
                    };
                }
            } else {
                baseConstraints.video = false;
            }

            return baseConstraints;
        };

        // Initialize Web Audio API for echo cancellation
        async function initializeAudioContext() {
            try {
                if (callAudioContext && callAudioContext.state !== 'closed') {
                    return callAudioContext;
                }

                // Create audio context with optimal settings
                callAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: isMobile ? 16000 : 48000,
                    latencyHint: isMobile ? 'interactive' : 'balanced'
                });

                // Resume context if suspended (required for autoplay policies)
                if (callAudioContext.state === 'suspended') {
                    await callAudioContext.resume();
                }

                // Create audio processing nodes
                remoteGainNode = callAudioContext.createGain();
                remoteGainNode.gain.value = 0.7; // Start at 70% volume to prevent feedback

                remoteAnalyser = callAudioContext.createAnalyser();
                remoteAnalyser.fftSize = 2048;
                remoteAnalyser.smoothingTimeConstant = 0.8;

                localAnalyser = callAudioContext.createAnalyser();
                localAnalyser.fftSize = 2048;
                localAnalyser.smoothingTimeConstant = 0.8;

                // Create compressor to normalize audio levels
                compressorNode = callAudioContext.createDynamicsCompressor();
                compressorNode.threshold.value = -24;
                compressorNode.knee.value = 30;
                compressorNode.ratio.value = 12;
                compressorNode.attack.value = 0.003;
                compressorNode.release.value = 0.25;

                // Create limiter to prevent clipping
                limiterNode = callAudioContext.createDynamicsCompressor();
                limiterNode.threshold.value = -3;
                limiterNode.knee.value = 0;
                limiterNode.ratio.value = 20;
                limiterNode.attack.value = 0.001;
                limiterNode.release.value = 0.01;

                // Connect processing chain: source -> gain -> compressor -> limiter -> destination
                remoteGainNode.connect(compressorNode);
                compressorNode.connect(limiterNode);
                limiterNode.connect(remoteAnalyser);
                remoteAnalyser.connect(callAudioContext.destination);

                // Monitor audio levels to prevent feedback
                monitorAudioLevels();

                return callAudioContext;
            } catch (error) {
                console.error('Error initializing audio context:', error);
                return null;
            }
        }

        // Monitor audio levels to prevent feedback loops
        function monitorAudioLevels() {
            if (!remoteAnalyser || !localAnalyser) return;

            const remoteDataArray = new Uint8Array(remoteAnalyser.frequencyBinCount);
            const localDataArray = new Uint8Array(localAnalyser.frequencyBinCount);

            function checkLevels() {
                if (!callActive || !remoteAnalyser || !localAnalyser || !callAudioContext) return;

                remoteAnalyser.getByteFrequencyData(remoteDataArray);
                localAnalyser.getByteFrequencyData(localDataArray);

                // Calculate average levels
                const remoteLevel = remoteDataArray.reduce((a, b) => a + b, 0) / remoteDataArray.length;
                const localLevel = localDataArray.reduce((a, b) => a + b, 0) / localDataArray.length;

                // If local mic is picking up remote audio (echo), reduce remote volume
                if (remoteLevel > 50 && localLevel > 40 && remoteLevel * 0.8 < localLevel) {
                    // Potential feedback detected, reduce remote volume
                    const currentGain = remoteGainNode.gain.value;
                    remoteGainNode.gain.setTargetAtTime(
                        Math.max(0.3, currentGain * 0.9),
                        callAudioContext.currentTime,
                        0.1
                    );
                } else if (remoteLevel < 30) {
                    // Audio is quiet, can increase volume slightly
                    const currentGain = remoteGainNode.gain.value;
                    remoteGainNode.gain.setTargetAtTime(
                        Math.min(0.8, currentGain * 1.05),
                        callAudioContext.currentTime,
                        0.2
                    );
                }

                requestAnimationFrame(checkLevels);
            }

            checkLevels();
        }

        // Setup local audio monitoring
        function setupLocalAudioMonitoring(stream) {
            if (!callAudioContext || !stream) return;

            try {
                localAudioSource = callAudioContext.createMediaStreamSource(stream);
                localAudioSource.connect(localAnalyser);
                // Don't connect to destination to prevent feedback
            } catch (error) {
                console.warn('Could not setup local audio monitoring:', error);
            }
        }

        // Initialize call
        async function initiateCall(mode = 'audio') {
            if (!ghostRoomId) {
                alert("Please join a room first.");
                return;
            }

            if (callActive) {
                alert("A call is already active.");
                return;
            }

            // Clean up any existing call first
            await cleanupCall();

            // Set mode from parameter (AFTER cleanup, as cleanup resets it to 'audio')
            currentCallMode = mode;
            console.log('Initiating call with mode:', mode);


            try {
                // Check microphone permission first
                await requestMicrophoneAccess();

                // Initialize audio context first
                await initializeAudioContext();
                if (!callAudioContext) {
                    throw new Error('Could not initialize audio context');
                }

                // Get user media based on mode
                if (currentCallMode === 'screen') {
                    // Check if screen sharing is supported
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                        alert("Screen sharing is not supported on this device/browser.");
                        currentCallMode = 'audio';
                        cleanupCall();
                        initiateCall('audio');
                        return;
                    }

                    // For screen share: Get display media + mic audio
                    try {
                        const displayStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                        const micConstraints = await getEnhancedMediaConstraints();
                        // Ensure we only get audio for mic
                        micConstraints.video = false;
                        const micStream = await navigator.mediaDevices.getUserMedia(micConstraints);

                        // Combine tracks: Mic audio + Screen video
                        // Note: displayStream might have its own audio (system audio), but we usually prioritize mic for calls
                        localStream = new MediaStream([
                            ...micStream.getAudioTracks(),
                            ...displayStream.getVideoTracks()
                        ]);

                        isScreenSharing = true;

                        // Handle user stopping screen share via browser UI
                        displayStream.getVideoTracks()[0].onended = () => {
                            switchCallMode('video');
                        };
                    } catch (err) {
                        console.error("Error getting screen share:", err);
                        // Fallback to audio if screen share cancelled/failed
                        alert("Screen share failed or cancelled. Falling back to audio.");
                        currentCallMode = 'audio';
                        cleanupCall(); // Cleanup partial streams
                        initiateCall('audio');
                        return;
                    }
                } else {
                    // Standard Audio/Video Call
                    const constraints = await getEnhancedMediaConstraints();
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                }

                // Setup local audio monitoring for echo detection
                setupLocalAudioMonitoring(localStream);

                isCaller = true;

                // Create peer connection with TURN servers
                console.log('Using ICE servers:', iceServers);
                peerConnection = new RTCPeerConnection(iceServers);

                // Handle errors
                peerConnection.onerror = (error) => {
                    console.error('Peer connection error:', error);
                };

                // Add local tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // WIDE TUNNEL IMPLEMENTATION:
                // If we are in AUDIO mode, we still need to establish a video "lane" (transceiver)
                // so we can seamlessly switch to video/screen sharing later without renegotiation.
                // We use 'sendrecv' (or 'recvonly' initially?) but 'sendrecv' allows us to send later.
                if (currentCallMode === 'audio' && localStream.getVideoTracks().length === 0) {
                    console.log('Audio mode: Adding video transceiver for Wide Tunnel...');
                    peerConnection.addTransceiver('video', { direction: 'sendrecv' });
                }

                // Bandwidth Optimization: Mangle SDP to limit bitrate for mobile to reduce lag
                // This is properly handled in createOffer/createAnswer but we can also do it via parameters if supported
                // For now, we will rely on SDP munging in the offer creation part.

                // Handle ICE candidates
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate && callId) {
                        try {
                            await window.firebaseAddDoc(
                                window.firebaseCollection(window.firebaseDB, `calls/${callId}/offerCandidates`),
                                {
                                    candidate: event.candidate.candidate,
                                    sdpMLineIndex: event.candidate.sdpMLineIndex,
                                    sdpMid: event.candidate.sdpMid
                                }
                            );
                        } catch (e) {
                            console.error('Error adding ICE candidate:', e);
                        }
                    }
                };

                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', peerConnection.connectionState);
                    // Only cleanup on actual failures, not on 'disconnected' which is normal during connection
                    if (peerConnection.connectionState === 'failed') {
                        // Give it more time before cleanup - connection might recover
                        setTimeout(() => {
                            if (peerConnection && peerConnection.connectionState === 'failed' && callActive) {
                                console.warn('Connection failed after timeout, cleaning up');
                                cleanupCall();
                            }
                        }, 10000); // Increased timeout to 10 seconds to allow reconnection
                    } else if (peerConnection.connectionState === 'closed') {
                        // Only cleanup if we're still in a call (not already cleaned up)
                        if (callActive) {
                            console.warn('Connection closed unexpectedly');
                            cleanupCall();
                        }
                    } else if (peerConnection.connectionState === 'connected') {
                        console.log('Connection established successfully');

                        // Mobile optimization: If connected, we can try to improve quality
                        if (isMobile) {
                            console.log('Mobile connection established - monitoring quality');
                        }
                    } else if (peerConnection.connectionState === 'disconnected') {
                        // 'disconnected' is normal during connection establishment - don't cleanup
                        console.log('Connection disconnected (may reconnect)');

                        // If persistent disconnect on mobile, it might be a network switch
                        if (isMobile && callActive) {
                            console.log('Mobile disconnect detected - attempting ICE restart if needed');
                            peerConnection.restartIce();
                        }
                    }
                };

                // Handle ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', peerConnection.iceConnectionState);
                    // Only cleanup on actual failures - 'disconnected' can be temporary during connection
                    if (peerConnection.iceConnectionState === 'failed') {
                        setTimeout(() => {
                            if (peerConnection && peerConnection.iceConnectionState === 'failed' && callActive) {
                                console.warn('ICE connection failed after timeout, cleaning up');
                                cleanupCall();
                            }
                        }, 10000); // Increased timeout to 10 seconds
                    } else if (peerConnection.iceConnectionState === 'connected' ||
                        peerConnection.iceConnectionState === 'completed') {
                        console.log('ICE connection established successfully');
                    } else if (peerConnection.iceConnectionState === 'disconnected') {
                        // 'disconnected' is normal during connection - don't cleanup
                        console.log('ICE disconnected (may reconnect)');
                    }
                };

                // Handle remote stream with Web Audio API for echo cancellation
                peerConnection.ontrack = async (event) => {
                    console.log('Received remote track', event);
                    console.log('Track kind:', event.track.kind);
                    console.log('Track enabled:', event.track.enabled);
                    console.log('Track readyState:', event.track.readyState);

                    if (event.streams && event.streams[0]) {
                        const remoteStream = event.streams[0];

                        // Handle VIDEO tracks
                        if (event.track.kind === 'video') {
                            console.log('Caller: Received video track - setting up video display');

                            // DEBUG: Show visible debug info since dev tools blocked
                            const debugText = document.getElementById('placeholder-text');
                            if (debugText) {
                                debugText.textContent = 'VIDEO TRACK RECEIVED!';
                            }
                            const remoteVideo = document.getElementById('remote-video');
                            const videoPlaceholder = document.getElementById('video-placeholder');
                            const videoCallWindow = document.getElementById('video-call-window');
                            const activeCallUI = document.getElementById('active-call-interface');

                            // Ensure video call window is visible when we receive video
                            if (videoCallWindow && videoCallWindow.classList.contains('hidden')) {
                                console.log('Caller: Showing video call window for incoming video track');
                                videoCallWindow.classList.remove('hidden');
                                if (activeCallUI) {
                                    activeCallUI.classList.add('hidden');
                                }
                                // Also set up local video if we have it
                                const localVideo = document.getElementById('local-video');
                                if (localVideo && localStream) {
                                    localVideo.srcObject = localStream;
                                }
                            }

                            if (remoteVideo) {
                                remoteVideo.srcObject = remoteStream;
                                // Ensure video plays with proper attributes
                                remoteVideo.muted = false; // Audio comes from audio tracks
                                remoteVideo.setAttribute('playsinline', '');
                                remoteVideo.setAttribute('autoplay', '');

                                remoteVideo.play().catch(e => {
                                    console.warn('Video play failed, retrying:', e);
                                    // Retry after a short delay
                                    setTimeout(() => {
                                        remoteVideo.play().catch(e2 => console.warn('Video retry failed:', e2));
                                    }, 500);
                                });

                                // Hide placeholder when video starts
                                if (videoPlaceholder) {
                                    videoPlaceholder.classList.add('hidden');
                                }
                                console.log('Caller: Remote video connected');

                                // Update call mode to video if not already
                                if (currentCallMode === 'audio') {
                                    currentCallMode = 'video';
                                    updateModeUI('video');
                                }
                            }
                            return; // Video track handled, don't process as audio
                        }

                        // Handle AUDIO tracks
                        const audioTracks = remoteStream.getAudioTracks();
                        console.log('Remote stream audio tracks:', audioTracks.length);

                        if (audioTracks.length === 0) {
                            console.error('No audio tracks in remote stream!');
                            return;
                        }

                        audioTracks.forEach((track, index) => {
                            console.log(`Audio track ${index}:`, {
                                enabled: track.enabled,
                                readyState: track.readyState,
                                muted: track.muted,
                                label: track.label
                            });
                        });
                        try {
                            // Ensure audio context is initialized and nodes exist
                            if (!callAudioContext || callAudioContext.state === 'closed') {
                                await initializeAudioContext();
                            }

                            if (!callAudioContext) {
                                throw new Error('Audio context not initialized');
                            }

                            if (callAudioContext.state === 'suspended') {
                                await callAudioContext.resume();
                            }

                            // PRIMARY METHOD: Use HTML5 Audio element (most reliable)
                            // Create or reuse audio element
                            if (!remoteAudioElement) {
                                remoteAudioElement = new Audio();
                                remoteAudioElement.autoplay = true;
                                remoteAudioElement.volume = 1.0; // Full volume
                                remoteAudioElement.setAttribute('playsinline', 'true'); // iOS compatibility
                                remoteAudioElement.muted = false;

                                // Add event listeners for debugging
                                remoteAudioElement.addEventListener('play', () => {
                                    console.log('Remote audio element started playing');
                                });
                                remoteAudioElement.addEventListener('pause', () => {
                                    console.log('Remote audio element paused');
                                });
                                remoteAudioElement.addEventListener('error', (e) => {
                                    console.error('Remote audio element error:', e);
                                });
                                remoteAudioElement.addEventListener('loadedmetadata', () => {
                                    console.log('Remote audio metadata loaded');
                                });
                            }

                            // Set remote stream to audio element
                            remoteAudioElement.srcObject = event.streams[0];
                            remoteAudioElement.volume = 1.0; // Ensure volume is set
                            remoteAudioElement.muted = false; // Ensure not muted

                            // Enable all audio tracks
                            audioTracks.forEach(track => {
                                track.enabled = true;
                                console.log('Enabled audio track:', track.label);
                            });

                            // Play the audio element with retry for mobile
                            let playAttempts = 0;
                            const maxPlayAttempts = 5;

                            const tryPlayAudio = async () => {
                                try {
                                    await remoteAudioElement.play();
                                    console.log('Remote audio element playing successfully');
                                    console.log('Audio element volume:', remoteAudioElement.volume);
                                    console.log('Audio element muted:', remoteAudioElement.muted);
                                    console.log('Audio element paused:', remoteAudioElement.paused);
                                    return true;
                                } catch (playError) {
                                    playAttempts++;
                                    console.warn(`Play attempt ${playAttempts} failed:`, playError);

                                    if (playError.name === 'NotAllowedError' && playAttempts < maxPlayAttempts) {
                                        // Autoplay blocked - wait a bit and retry (user might interact)
                                        console.log('Autoplay blocked, will retry...');
                                        setTimeout(() => {
                                            if (callActive && remoteAudioElement) {
                                                tryPlayAudio();
                                            }
                                        }, 1000);
                                    } else if (playAttempts < maxPlayAttempts) {
                                        // Other error - retry after short delay
                                        setTimeout(() => {
                                            if (callActive && remoteAudioElement) {
                                                tryPlayAudio();
                                            }
                                        }, 500);
                                    } else {
                                        console.error('Failed to play remote audio after', maxPlayAttempts, 'attempts');
                                        // On mobile, try to show a message or use a workaround
                                        if (isMobile) {
                                            console.warn('Mobile autoplay blocked - audio may need user interaction');
                                        }
                                    }
                                    return false;
                                }
                            };

                            await tryPlayAudio();

                            // SECONDARY METHOD: Also try Web Audio API for echo cancellation
                            try {
                                // Ensure audio nodes are created
                                if (!remoteGainNode || !compressorNode || !limiterNode) {
                                    console.log('Initializing Web Audio API nodes for echo cancellation...');
                                    await initializeAudioContext();
                                }

                                // Create media stream source from remote stream
                                if (remoteAudioSource) {
                                    try {
                                        remoteAudioSource.disconnect();
                                    } catch (e) {
                                        // Ignore disconnect errors
                                    }
                                }

                                remoteAudioSource = callAudioContext.createMediaStreamSource(event.streams[0]);

                                // Connect through processing chain: source -> gain -> compressor -> limiter -> destination
                                if (remoteGainNode) {
                                    remoteAudioSource.connect(remoteGainNode);
                                    console.log('Web Audio API echo cancellation active');
                                    console.log('Web Audio API gain:', remoteGainNode.gain.value);
                                }
                            } catch (webAudioError) {
                                console.warn('Web Audio API setup failed, using audio element only:', webAudioError);
                                // Audio element will still work
                            }

                            console.log('Remote audio connected - Primary: Audio Element, Secondary: Web Audio API');
                        } catch (e) {
                            console.error('Error handling remote track:', e);
                            // Fallback to basic audio element only
                            try {
                                if (!remoteAudioElement) {
                                    remoteAudioElement = new Audio();
                                    remoteAudioElement.autoplay = true;
                                    remoteAudioElement.volume = 1.0;
                                    remoteAudioElement.setAttribute('playsinline', 'true');
                                    remoteAudioElement.muted = false;
                                }
                                remoteAudioElement.srcObject = event.streams[0];
                                remoteAudioElement.volume = 1.0;
                                remoteAudioElement.muted = false;

                                // Enable all audio tracks
                                const stream = event.streams[0];
                                stream.getAudioTracks().forEach(track => {
                                    track.enabled = true;
                                });

                                await remoteAudioElement.play();
                                console.log('Using fallback audio element only - playing');
                            } catch (err) {
                                console.error('Error with fallback audio element:', err);
                                // Try to show user-friendly error
                                if (err.name === 'NotAllowedError') {
                                    console.warn('Autoplay blocked - user interaction may be required');
                                }
                            }
                        }
                    }
                };

                // Create offer
                console.log('Creating WebRTC offer...');
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                console.log('Offer created and local description set:', offer.type);

                // Save offer to Firestore - create new document
                console.log('Saving offer to Firestore for roomId:', ghostRoomId, 'caller:', ghostHandle);
                const callDocRef = await window.firebaseAddDoc(
                    window.firebaseCollection(window.firebaseDB, 'calls'),
                    {
                        offer: {
                            type: offer.type,
                            sdp: offer.sdp
                        },
                        roomId: ghostRoomId,
                        caller: ghostHandle,
                        callMode: currentCallMode, // Pass call mode to receiver
                        timestamp: window.firebaseServerTimestamp(),
                        status: 'calling'
                    }
                );
                callId = callDocRef.id; // Use actual document ID
                console.log('Call document created with ID:', callId);

                // Mark call as active
                callActive = true;
                console.log('Call marked as active. Ready to receive answer.');

                // Listen for answer and call state changes
                listenForAnswer();

                // Show active call interface
                showActiveCall();

                // Start outgoing ring sound (caller hears this while waiting for answer)
                startRingSound(true);

                console.log('Call initiated, waiting for answer');

            } catch (error) {
                console.error('Call initiation error:', error);
                let errorMessage = 'Could not start call. ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Please allow microphone permissions in your browser settings.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'No microphone found. Please connect a microphone.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Microphone is being used by another application.';
                } else if (error.message && error.message.includes('microphone')) {
                    errorMessage += 'Microphone access error: ' + error.message;
                } else {
                    errorMessage += 'Error: ' + (error.message || error.toString());
                }
                alert(errorMessage);
                await cleanupCall();
            }
        }

        // Track processed call IDs to prevent duplicate notifications
        const processedCallIds = new Set();
        let lastCallCheckTime = 0;

        // Listen for incoming calls
        function listenForIncomingCalls() {
            if (!ghostRoomId || !window.firebaseDB) return;

            // Unsubscribe from existing listener if any
            if (callUnsubscribe) {
                callUnsubscribe();
                callUnsubscribe = null;
            }

            // Clear processed calls older than 30 seconds
            const now = Date.now();
            if (now - lastCallCheckTime > 30000) {
                processedCallIds.clear();
                lastCallCheckTime = now;
            }

            console.log('Setting up incoming call listener for room:', ghostRoomId);

            const callsRef = window.firebaseCollection(window.firebaseDB, 'calls');
            const q = window.firebaseQuery(callsRef, window.firebaseOrderBy('timestamp', 'desc'));

            callUnsubscribe = window.firebaseOnSnapshot(q, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    // Only process new calls that haven't been seen
                    if (change.type === 'added' && !isCaller && !callActive) {
                        const callData = change.doc.data();
                        const callDocId = change.doc.id;

                        // Skip if already processed
                        if (processedCallIds.has(callDocId)) {
                            return;
                        }

                        // Only show calls that are:
                        // 1. For this room
                        // 2. Not from this user
                        // 3. Status is 'calling' (actively calling, not ended or active)
                        // 4. Created in the last 30 seconds (prevent old calls from showing)
                        const callTimestamp = callData.timestamp?.toMillis ? callData.timestamp.toMillis() :
                            (callData.timestamp?.seconds ? callData.timestamp.seconds * 1000 : Date.now());
                        const callAge = Date.now() - callTimestamp;

                        if (callData.roomId === ghostRoomId &&
                            callData.caller !== ghostHandle &&
                            callData.status === 'calling' &&
                            !callData.ended &&
                            callAge < 30000) { // Only show calls less than 30 seconds old

                            processedCallIds.add(callDocId);
                            callId = callDocId;

                            const callerNameEl = document.getElementById('caller-name-display');
                            if (callerNameEl) {
                                callerNameEl.textContent = callData.caller || 'Unknown';
                            }
                            const incomingModal = document.getElementById('incoming-call-modal');
                            if (incomingModal) {
                                incomingModal.classList.remove('hidden');
                                // Start incoming ring sound (receiver hears this)
                                startRingSound(false);
                            }
                        }
                    }

                    // Handle call updates (ended calls, status changes)
                    if (change.type === 'modified') {
                        const callData = change.doc.data();
                        const callDocId = change.doc.id;

                        // Only process if this is the current call we're tracking
                        if (callDocId === callId) {
                            // Check if call was ended, rejected, or cancelled
                            if (callData.status === 'ended' || callData.status === 'rejected' ||
                                callData.status === 'cancelled' || callData.ended) {
                                console.log('Call status changed to:', callData.status);

                                // Hide incoming call modal if it's visible (caller hung up before we answered)
                                const incomingModal = document.getElementById('incoming-call-modal');
                                if (incomingModal && !incomingModal.classList.contains('hidden')) {
                                    incomingModal.classList.add('hidden');
                                    console.log('Incoming call modal hidden - caller ended call');
                                }

                                // If we were in an active call, cleanup
                                if (callActive) {
                                    cleanupCall();
                                } else {
                                    // Reset callId since call is no longer valid
                                    callId = null;
                                }
                            } else if (callData.status === 'active' && !callActive && !isCaller) {
                                // Call was accepted by us, don't do anything - acceptCall is handling it
                                console.log('Call status changed to active (we accepted it)');
                            }
                        }
                    }

                    // Handle deleted call documents (caller deleted the call)
                    if (change.type === 'removed') {
                        const callDocId = change.doc.id;
                        if (callDocId === callId) {
                            console.log('Call document was deleted');

                            // Hide incoming call modal
                            const incomingModal = document.getElementById('incoming-call-modal');
                            if (incomingModal && !incomingModal.classList.contains('hidden')) {
                                incomingModal.classList.add('hidden');
                            }

                            // Cleanup if in active call
                            if (callActive) {
                                cleanupCall();
                            } else {
                                callId = null;
                            }
                        }
                    }
                });
            });
        }

        // Accept incoming call
        async function acceptCall() {
            if (!callId || !window.firebaseDB) return;

            if (callActive) {
                alert("A call is already active.");
                return;
            }

            // Hide incoming modal immediately
            const incomingModal = document.getElementById('incoming-call-modal');
            if (incomingModal) {
                incomingModal.classList.add('hidden');
            }

            // Stop incoming ring sound
            stopRingSound();

            // Don't cleanup here - we need to preserve the callId and existing listeners
            // Only cleanup if there's actually a conflicting call
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                console.warn('Existing peer connection found, cleaning up first');
                await cleanupCall();
            }

            try {
                // First, fetch the call document to get the caller's mode
                const acceptCallDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                const callSnap = await window.firebaseGetDoc(acceptCallDocRef);
                if (callSnap.exists()) {
                    const callData = callSnap.data();
                    // Set our mode to match the caller's mode
                    if (callData.callMode) {
                        currentCallMode = callData.callMode;
                        console.log('Receiver: Setting call mode to match caller:', currentCallMode);
                    }
                }

                // Check microphone permission first
                await requestMicrophoneAccess();

                // Initialize audio context first
                await initializeAudioContext();
                if (!callAudioContext) {
                    throw new Error('Could not initialize audio context');
                }

                // Get user media with enhanced constraints based on call mode
                const constraints = await getEnhancedMediaConstraints();
                console.log('Receiver: Requesting media with constraints:', JSON.stringify(constraints));
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('Receiver: Got local stream with tracks:', localStream.getTracks().map(t => t.kind + ':' + t.label));

                // Setup local audio monitoring for echo detection
                setupLocalAudioMonitoring(localStream);

                // Create peer connection with TURN servers
                console.log('Using ICE servers:', iceServers);
                peerConnection = new RTCPeerConnection(iceServers);

                // Handle errors
                peerConnection.onerror = (error) => {
                    console.error('Peer connection error:', error);
                };

                // Add local tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // WIDE TUNNEL IMPLEMENTATION (Receiver Side):
                // If we are answering in AUDIO mode, we still need to signal that we are capable of video.
                // If the offer had video, `setRemoteDescription` will handle it, but we need to ensure 
                // our answer includes a compatible video m-line.
                // Adding a transceiver with 'sendrecv' ensures we allocate a video section in the answer.
                if (currentCallMode === 'audio' && localStream.getVideoTracks().length === 0) {
                    console.log('Audio mode (Receiver): Adding video transceiver for Wide Tunnel...');
                    peerConnection.addTransceiver('video', { direction: 'sendrecv' });
                }

                // Handle ICE candidates
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate && callId) {
                        try {
                            await window.firebaseAddDoc(
                                window.firebaseCollection(window.firebaseDB, `calls/${callId}/answerCandidates`),
                                {
                                    candidate: event.candidate.candidate,
                                    sdpMLineIndex: event.candidate.sdpMLineIndex,
                                    sdpMid: event.candidate.sdpMid
                                }
                            );
                        } catch (e) {
                            console.error('Error adding ICE candidate:', e);
                        }
                    }
                };

                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', peerConnection.connectionState);
                    // Only cleanup on actual failures, not on 'disconnected' which is normal during connection
                    if (peerConnection.connectionState === 'failed') {
                        // Give it more time before cleanup - connection might recover
                        setTimeout(() => {
                            if (peerConnection && peerConnection.connectionState === 'failed' && callActive) {
                                console.warn('Connection failed after timeout, cleaning up');
                                cleanupCall();
                            }
                        }, 10000); // Increased timeout to 10 seconds to allow reconnection
                    } else if (peerConnection.connectionState === 'closed') {
                        // Only cleanup if we're still in a call (not already cleaned up)
                        if (callActive) {
                            console.warn('Connection closed unexpectedly');
                            cleanupCall();
                        }
                    } else if (peerConnection.connectionState === 'connected') {
                        console.log('Connection established successfully');

                        // Mobile optimization: If connected, we can try to improve quality
                        if (isMobile) {
                            console.log('Mobile connection established - monitoring quality');
                        }
                    } else if (peerConnection.connectionState === 'disconnected') {
                        // 'disconnected' is normal during connection establishment - don't cleanup
                        console.log('Connection disconnected (may reconnect)');

                        // If persistent disconnect on mobile, it might be a network switch
                        if (isMobile && callActive) {
                            console.log('Mobile disconnect detected - attempting ICE restart if needed');
                            peerConnection.restartIce();
                        }
                    }
                };

                // Handle ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', peerConnection.iceConnectionState);
                    // Only cleanup on actual failures - 'disconnected' can be temporary during connection
                    if (peerConnection.iceConnectionState === 'failed') {
                        setTimeout(() => {
                            if (peerConnection && peerConnection.iceConnectionState === 'failed' && callActive) {
                                console.warn('ICE connection failed after timeout, cleaning up');
                                cleanupCall();
                            }
                        }, 10000); // Increased timeout to 10 seconds
                    } else if (peerConnection.iceConnectionState === 'connected' ||
                        peerConnection.iceConnectionState === 'completed') {
                        console.log('ICE connection established successfully');
                    } else if (peerConnection.iceConnectionState === 'disconnected') {
                        // 'disconnected' is normal during connection - don't cleanup
                        console.log('ICE disconnected (may reconnect)');
                        if (isMobile && callActive) {
                            peerConnection.restartIce();
                        }
                    }
                };

                // Handle remote stream with Web Audio API for echo cancellation
                peerConnection.ontrack = async (event) => {
                    console.log('Received remote track', event);
                    console.log('Track kind:', event.track.kind);
                    console.log('Track enabled:', event.track.enabled);
                    console.log('Track readyState:', event.track.readyState);

                    if (event.streams && event.streams[0]) {
                        const remoteStream = event.streams[0];

                        // Handle VIDEO tracks FIRST
                        if (event.track.kind === 'video') {
                            console.log('Receiver: Received video track - setting up video display');

                            // DEBUG: Show visible debug info since dev tools blocked
                            const debugText = document.getElementById('placeholder-text');
                            if (debugText) {
                                debugText.textContent = 'VIDEO TRACK RECEIVED!';
                            }
                            const remoteVideo = document.getElementById('remote-video');
                            const videoPlaceholder = document.getElementById('video-placeholder');
                            const videoCallWindow = document.getElementById('video-call-window');
                            const activeCallUI = document.getElementById('active-call-interface');

                            // Ensure video call window is visible when we receive video
                            if (videoCallWindow && videoCallWindow.classList.contains('hidden')) {
                                console.log('Receiver: Showing video call window for incoming video track');
                                videoCallWindow.classList.remove('hidden');
                                if (activeCallUI) {
                                    activeCallUI.classList.add('hidden');
                                }
                                // Also set up local video if we have it
                                const localVideo = document.getElementById('local-video');
                                if (localVideo && localStream) {
                                    localVideo.srcObject = localStream;
                                }
                            }

                            if (remoteVideo) {
                                remoteVideo.srcObject = remoteStream;
                                // Ensure video plays with proper attributes
                                remoteVideo.muted = false; // Audio comes from audio tracks
                                remoteVideo.setAttribute('playsinline', '');
                                remoteVideo.setAttribute('autoplay', '');

                                remoteVideo.play().catch(e => {
                                    console.warn('Video play failed, retrying:', e);
                                    // Retry after a short delay
                                    setTimeout(() => {
                                        remoteVideo.play().catch(e2 => console.warn('Video retry failed:', e2));
                                    }, 500);
                                });

                                // Hide placeholder when video starts
                                if (videoPlaceholder) {
                                    videoPlaceholder.classList.add('hidden');
                                }
                                console.log('Receiver: Remote video connected');

                                // Update call mode to video if not already
                                if (currentCallMode === 'audio') {
                                    currentCallMode = 'video';
                                    updateModeUI('video');
                                }
                            }
                            return; // Video track handled, don't process as audio
                        }

                        // Handle AUDIO tracks
                        const audioTracks = remoteStream.getAudioTracks();
                        console.log('Remote stream audio tracks:', audioTracks.length);

                        if (audioTracks.length === 0) {
                            console.error('No audio tracks in remote stream!');
                            return;
                        }

                        audioTracks.forEach((track, index) => {
                            console.log(`Audio track ${index}:`, {
                                enabled: track.enabled,
                                readyState: track.readyState,
                                muted: track.muted,
                                label: track.label
                            });
                        });
                        try {
                            // Ensure audio context is initialized and nodes exist
                            if (!callAudioContext || callAudioContext.state === 'closed') {
                                await initializeAudioContext();
                            }

                            if (!callAudioContext) {
                                throw new Error('Audio context not initialized');
                            }

                            if (callAudioContext.state === 'suspended') {
                                await callAudioContext.resume();
                            }

                            // PRIMARY METHOD: Use HTML5 Audio element (most reliable)
                            // Create or reuse audio element
                            if (!remoteAudioElement) {
                                remoteAudioElement = new Audio();
                                remoteAudioElement.autoplay = true;
                                remoteAudioElement.volume = 1.0; // Full volume
                                remoteAudioElement.setAttribute('playsinline', 'true'); // iOS compatibility
                                remoteAudioElement.muted = false;

                                // Add event listeners for debugging
                                remoteAudioElement.addEventListener('play', () => {
                                    console.log('Remote audio element started playing');
                                });
                                remoteAudioElement.addEventListener('pause', () => {
                                    console.log('Remote audio element paused');
                                });
                                remoteAudioElement.addEventListener('error', (e) => {
                                    console.error('Remote audio element error:', e);
                                });
                                remoteAudioElement.addEventListener('loadedmetadata', () => {
                                    console.log('Remote audio metadata loaded');
                                });
                            }

                            // Set remote stream to audio element
                            remoteAudioElement.srcObject = event.streams[0];
                            remoteAudioElement.volume = 1.0; // Ensure volume is set
                            remoteAudioElement.muted = false; // Ensure not muted

                            // Enable all audio tracks
                            audioTracks.forEach(track => {
                                track.enabled = true;
                                console.log('Enabled audio track:', track.label);
                            });

                            // Play the audio element with retry for mobile
                            let playAttempts = 0;
                            const maxPlayAttempts = 5;

                            const tryPlayAudio = async () => {
                                try {
                                    await remoteAudioElement.play();
                                    console.log('Remote audio element playing successfully');
                                    console.log('Audio element volume:', remoteAudioElement.volume);
                                    console.log('Audio element muted:', remoteAudioElement.muted);
                                    console.log('Audio element paused:', remoteAudioElement.paused);
                                    return true;
                                } catch (playError) {
                                    playAttempts++;
                                    console.warn(`Play attempt ${playAttempts} failed:`, playError);

                                    if (playError.name === 'NotAllowedError' && playAttempts < maxPlayAttempts) {
                                        // Autoplay blocked - wait a bit and retry (user might interact)
                                        console.log('Autoplay blocked, will retry...');
                                        setTimeout(() => {
                                            if (callActive && remoteAudioElement) {
                                                tryPlayAudio();
                                            }
                                        }, 1000);
                                    } else if (playAttempts < maxPlayAttempts) {
                                        // Other error - retry after short delay
                                        setTimeout(() => {
                                            if (callActive && remoteAudioElement) {
                                                tryPlayAudio();
                                            }
                                        }, 500);
                                    } else {
                                        console.error('Failed to play remote audio after', maxPlayAttempts, 'attempts');
                                        // On mobile, try to show a message or use a workaround
                                        if (isMobile) {
                                            console.warn('Mobile autoplay blocked - audio may need user interaction');
                                        }
                                    }
                                    return false;
                                }
                            };

                            await tryPlayAudio();

                            // SECONDARY METHOD: Also try Web Audio API for echo cancellation
                            try {
                                // Ensure audio nodes are created
                                if (!remoteGainNode || !compressorNode || !limiterNode) {
                                    console.log('Initializing Web Audio API nodes for echo cancellation...');
                                    await initializeAudioContext();
                                }

                                // Create media stream source from remote stream
                                if (remoteAudioSource) {
                                    try {
                                        remoteAudioSource.disconnect();
                                    } catch (e) {
                                        // Ignore disconnect errors
                                    }
                                }

                                remoteAudioSource = callAudioContext.createMediaStreamSource(event.streams[0]);

                                // Connect through processing chain: source -> gain -> compressor -> limiter -> destination
                                if (remoteGainNode) {
                                    remoteAudioSource.connect(remoteGainNode);
                                    console.log('Web Audio API echo cancellation active');
                                    console.log('Web Audio API gain:', remoteGainNode.gain.value);
                                }
                            } catch (webAudioError) {
                                console.warn('Web Audio API setup failed, using audio element only:', webAudioError);
                                // Audio element will still work
                            }

                            console.log('Remote audio connected - Primary: Audio Element, Secondary: Web Audio API');
                        } catch (e) {
                            console.error('Error handling remote track:', e);
                            // Fallback to basic audio element only
                            try {
                                if (!remoteAudioElement) {
                                    remoteAudioElement = new Audio();
                                    remoteAudioElement.autoplay = true;
                                    remoteAudioElement.volume = 1.0;
                                    remoteAudioElement.setAttribute('playsinline', 'true');
                                    remoteAudioElement.muted = false;
                                }
                                remoteAudioElement.srcObject = event.streams[0];
                                remoteAudioElement.volume = 1.0;
                                remoteAudioElement.muted = false;

                                // Enable all audio tracks
                                const stream = event.streams[0];
                                stream.getAudioTracks().forEach(track => {
                                    track.enabled = true;
                                });

                                await remoteAudioElement.play();
                                console.log('Using fallback audio element only - playing');
                            } catch (err) {
                                console.error('Error with fallback audio element:', err);
                                // Try to show user-friendly error
                                if (err.name === 'NotAllowedError') {
                                    console.warn('Autoplay blocked - user interaction may be required');
                                }
                            }
                        }
                    }
                };

                // Get offer from Firestore
                const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                const callDocSnap = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Timeout waiting for call document')), 10000);
                    const unsubscribe = window.firebaseOnSnapshot(callDocRef, (doc) => {
                        if (doc.exists()) {
                            const data = doc.data();
                            // Check if call was already ended
                            if (data.status === 'ended' || data.ended) {
                                clearTimeout(timeout);
                                unsubscribe();
                                reject(new Error('Call was already ended'));
                                return;
                            }
                            clearTimeout(timeout);
                            unsubscribe();
                            resolve(doc);
                        }
                    });
                });

                const offerData = callDocSnap.data();
                if (!offerData || !offerData.offer) {
                    throw new Error('Offer not found');
                }

                // Mark call as active and start listening for ICE candidates BEFORE setting remote description
                // This prevents race condition where candidates arrive before we're listening
                callActive = true;
                listenForOfferCandidates();

                await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData.offer));

                // Create answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Save answer to Firestore
                await window.firebaseUpdateDoc(callDocRef, {
                    answer: {
                        type: answer.type,
                        sdp: answer.sdp
                    },
                    status: 'active'
                });

                // Show active call (modal already hidden above)
                showActiveCall();

                console.log('Call accepted and connection established');

            } catch (error) {
                console.error('Accept call error:', error);
                let errorMessage = 'Could not accept call. ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Please allow microphone permissions in your browser settings.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'No microphone found. Please connect a microphone.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Microphone is being used by another application.';
                } else if (error.message && error.message.includes('Timeout')) {
                    errorMessage += 'Call timed out. The caller may have hung up.';
                } else if (error.message && error.message.includes('ended')) {
                    errorMessage += 'This call has already ended.';
                } else if (error.message && error.message.includes('microphone')) {
                    errorMessage += 'Microphone access error: ' + error.message;
                } else {
                    errorMessage += 'Error: ' + (error.message || error.toString());
                }
                alert(errorMessage);
                await cleanupCall();
            }
        }

        // Deny call
        async function denyCall() {
            if (callId && window.firebaseDB) {
                try {
                    const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                    await window.firebaseUpdateDoc(callDocRef, {
                        status: 'rejected',
                        rejectedAt: window.firebaseServerTimestamp(),
                        rejectedBy: ghostHandle
                    });
                } catch (e) {
                    console.error('Error rejecting call:', e);
                }
            }
            document.getElementById('incoming-call-modal').classList.add('hidden');
            callId = null;
        }

        // Listen for answer (caller side)
        async function listenForAnswer() {
            if (!callId || !window.firebaseDB) return;

            // Unsubscribe from any existing listener first
            if (answerUnsubscribe) {
                answerUnsubscribe();
                answerUnsubscribe = null;
            }

            const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
            answerUnsubscribe = window.firebaseOnSnapshot(callDocRef, async (doc) => {
                if (doc.exists()) {
                    const data = doc.data();

                    // Check if call was ended by other side
                    if (data.status === 'ended' || data.ended || data.status === 'rejected') {
                        if (callActive) {
                            cleanupCall();
                        }
                        return;
                    }

                    // If status is 'active', the call was accepted - don't cleanup, just continue
                    if (data.status === 'active' && !callActive) {
                        console.log('Call accepted by other party');
                        // Don't cleanup - call is being established
                    }

                    // Handle renegotiation (new offer during active call for mode switch)
                    if (data.renegotiation && data.offer && peerConnection && callActive) {
                        console.log('Renegotiation offer received, processing...');
                        try {
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);

                            // Send answer back
                            await window.firebaseUpdateDoc(callDocRef, {
                                answer: {
                                    type: answer.type,
                                    sdp: answer.sdp
                                },
                                renegotiation: false // Mark as processed
                            });
                            console.log('Renegotiation answer sent');
                        } catch (renego_err) {
                            console.error('Renegotiation error:', renego_err);
                        }
                        return;
                    }

                    if (data?.answer && peerConnection && peerConnection.remoteDescription === null) {
                        try {
                            console.log('Setting remote description from answer');
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));

                            // Stop outgoing ring sound (caller side - callee has answered)
                            stopRingSound();

                            listenForAnswerCandidates();

                            // After setting remote description, ensure audio will play when track arrives
                            // This is especially important for mobile devices
                            if (isMobile) {
                                // On mobile, try to play audio after a delay (when track should arrive)
                                setTimeout(() => {
                                    if (callActive && remoteAudioElement && remoteAudioElement.paused) {
                                        console.log('Mobile: Attempting to play remote audio after answer');
                                        remoteAudioElement.play().catch(e => {
                                            console.warn('Mobile play attempt failed:', e);
                                        });
                                    }
                                }, 2000);
                            }
                        } catch (e) {
                            console.error('Error setting remote description:', e);
                            // Don't cleanup on error - might be recoverable
                        }
                    }
                }
            });
        }

        // Listen for answer candidates (caller side)
        const processedAnswerCandidates = new Set(); // Track processed candidates
        async function listenForAnswerCandidates() {
            if (!callId || !window.firebaseDB) return;

            const candidatesRef = window.firebaseCollection(window.firebaseDB, `calls/${callId}/answerCandidates`);
            answerCandidatesUnsubscribe = window.firebaseOnSnapshot(candidatesRef, (snapshot) => {
                // Process ALL candidates in snapshot, not just changes
                // This handles race condition where candidates exist before listener starts
                snapshot.docs.forEach(async (doc) => {
                    const candidateId = doc.id;
                    if (processedAnswerCandidates.has(candidateId)) return; // Skip already processed
                    processedAnswerCandidates.add(candidateId);

                    if (peerConnection && peerConnection.remoteDescription) {
                        try {
                            const candidate = doc.data();
                            const iceCandidate = new RTCIceCandidate({
                                candidate: candidate.candidate,
                                sdpMLineIndex: candidate.sdpMLineIndex,
                                sdpMid: candidate.sdpMid
                            });
                            await peerConnection.addIceCandidate(iceCandidate);
                            console.log('Added answer candidate:', candidateId);
                        } catch (e) {
                            // Ignore errors for duplicate candidates
                            if (!e.message.includes('duplicate')) {
                                console.error('Error adding ICE candidate:', e);
                            }
                        }
                    }
                });
            });
        }


        // Listen for offer candidates (receiver side)
        const processedOfferCandidates = new Set(); // Track processed candidates
        async function listenForOfferCandidates() {
            if (!callId || !window.firebaseDB) return;

            const candidatesRef = window.firebaseCollection(window.firebaseDB, `calls/${callId}/offerCandidates`);
            offerCandidatesUnsubscribe = window.firebaseOnSnapshot(candidatesRef, (snapshot) => {
                // Process ALL candidates in snapshot, not just changes
                // This handles race condition where candidates exist before listener starts
                snapshot.docs.forEach(async (doc) => {
                    const candidateId = doc.id;
                    if (processedOfferCandidates.has(candidateId)) return; // Skip already processed
                    processedOfferCandidates.add(candidateId);

                    if (peerConnection && peerConnection.remoteDescription) {
                        try {
                            const candidate = doc.data();
                            const iceCandidate = new RTCIceCandidate({
                                candidate: candidate.candidate,
                                sdpMLineIndex: candidate.sdpMLineIndex,
                                sdpMid: candidate.sdpMid
                            });
                            await peerConnection.addIceCandidate(iceCandidate);
                            console.log('Added offer candidate:', candidateId);
                        } catch (e) {
                            // Ignore errors for duplicate candidates
                            if (!e.message.includes('duplicate')) {
                                console.error('Error adding ICE candidate:', e);
                            }
                        }
                    }
                });
            });
        }

        // Show active call interface
        function showActiveCall() {
            // Don't set callActive here - it should be set before calling this function
            // callActive = true; // Removed - set by caller

            const activeCallUI = document.getElementById('active-call-interface');
            const videoCallWindow = document.getElementById('video-call-window');
            const callBtn = document.getElementById('ghost-call-btn');

            // Hide call button
            if (callBtn) {
                callBtn.classList.add('hidden');
            }

            // Show appropriate interface based on call mode
            if (currentCallMode === 'video' || currentCallMode === 'screen') {
                // Show full-screen video call window
                if (videoCallWindow) {
                    videoCallWindow.classList.remove('hidden');
                }
                if (activeCallUI) {
                    activeCallUI.classList.add('hidden');
                }

                // Set up local video preview
                const localVideo = document.getElementById('local-video');
                if (localVideo && localStream) {
                    localVideo.srcObject = localStream;
                    cameraStream = localStream; // Store for swap-back
                }

                // Update UI based on mode
                updateModeUI(currentCallMode);
                updateCameraUI();
            } else {
                // Show mini bar for audio calls
                if (activeCallUI) {
                    activeCallUI.classList.remove('hidden');
                }
                if (videoCallWindow) {
                    videoCallWindow.classList.add('hidden');
                }
            }

            // Start call timer
            startCallTimer();

            // Refresh Lucide icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons();
            }

            // Ensure remote audio is playing when call interface is shown
            // This helps with autoplay policies, especially on mobile
            const ensureAudioPlaying = () => {
                if (remoteAudioElement) {
                    if (remoteAudioElement.paused) {
                        remoteAudioElement.play().catch(e => {
                            console.warn('Could not resume remote audio:', e);
                            // Retry after a short delay (user might have interacted)
                            if (callActive) {
                                setTimeout(() => {
                                    if (remoteAudioElement && remoteAudioElement.paused) {
                                        remoteAudioElement.play().catch(err => {
                                            console.warn('Retry play failed:', err);
                                        });
                                    }
                                }, 500);
                            }
                        });
                    }

                    // Ensure volume and mute settings
                    remoteAudioElement.volume = 1.0;
                    remoteAudioElement.muted = false;
                }
            };

            // Try immediately
            ensureAudioPlaying();

            // Also try after a short delay (helps with mobile)
            setTimeout(ensureAudioPlaying, 500);
            setTimeout(ensureAudioPlaying, 1500);

            // On mobile, also try when user interacts with the page
            if (isMobile) {
                const playOnInteraction = () => {
                    if (callActive && remoteAudioElement && remoteAudioElement.paused) {
                        console.log('Mobile: User interaction detected, attempting to play audio');
                        remoteAudioElement.play().catch(e => console.warn('Interaction play failed:', e));
                    }
                };

                // Try on any user interaction (multiple times for better chance)
                document.addEventListener('click', playOnInteraction, { once: false });
                document.addEventListener('touchstart', playOnInteraction, { once: false });
                document.addEventListener('touchend', playOnInteraction, { once: false });

                // Also set up periodic check for mobile (every 2 seconds)
                if (mobileAudioCheckInterval) {
                    clearInterval(mobileAudioCheckInterval);
                }

                mobileAudioCheckInterval = setInterval(() => {
                    if (!callActive) {
                        if (mobileAudioCheckInterval) {
                            clearInterval(mobileAudioCheckInterval);
                            mobileAudioCheckInterval = null;
                        }
                        return;
                    }

                    if (remoteAudioElement && remoteAudioElement.paused) {
                        console.log('Mobile: Audio paused, attempting to resume');
                        remoteAudioElement.play().catch(e => {
                            // Only log if it's not just autoplay blocking
                            if (!e.message || !e.message.includes('play()')) {
                                console.warn('Mobile audio resume failed:', e);
                            }
                        });
                    }
                }, 2000);
            }

            // Note: Call end listening is already handled by listenForAnswer() and listenForIncomingCalls()
            // No need to create duplicate listeners here
        }

        // Hangup call - SECURE HANGUP with recursive deletion
        async function hangupCall() {
            console.log('HANGUP: Initiating secure hangup...');
            await cleanupCall();
        }

        // Mute state tracking
        let isMuted = false;

        // Toggle microphone mute/unmute
        function toggleMute() {
            if (!localStream || !callActive) {
                console.warn('Cannot toggle mute: no active call or stream');
                return;
            }

            const audioTracks = localStream.getAudioTracks();
            if (audioTracks.length === 0) {
                console.warn('No audio tracks to mute');
                return;
            }

            isMuted = !isMuted;

            // Mute/unmute all audio tracks
            audioTracks.forEach(track => {
                track.enabled = !isMuted;
                console.log(`Audio track ${track.label} ${isMuted ? 'muted' : 'unmuted'}`);
            });

            // Update UI
            const muteBtn = document.getElementById('mute-btn');
            const muteIcon = document.getElementById('mute-icon');
            const muteText = document.getElementById('mute-text');

            if (muteBtn && muteIcon && muteText) {
                if (isMuted) {
                    muteBtn.classList.remove('bg-zinc-700');
                    muteBtn.classList.add('bg-red-600');
                    muteIcon.setAttribute('data-lucide', 'mic-off');
                    muteText.textContent = 'UNMUTE';
                } else {
                    muteBtn.classList.remove('bg-red-600');
                    muteBtn.classList.add('bg-zinc-700');
                    muteIcon.setAttribute('data-lucide', 'mic');
                    muteText.textContent = 'MUTE';
                }
                // Refresh Lucide icons
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }
            }

            // Also update video call window mute button
            const vcMuteBtn = document.getElementById('vc-mute-btn');
            const vcMuteIcon = document.getElementById('vc-mute-icon');
            if (vcMuteBtn && vcMuteIcon) {
                if (isMuted) {
                    vcMuteBtn.classList.remove('bg-zinc-700');
                    vcMuteBtn.classList.add('bg-red-600');
                    vcMuteIcon.setAttribute('data-lucide', 'mic-off');
                } else {
                    vcMuteBtn.classList.remove('bg-red-600');
                    vcMuteBtn.classList.add('bg-zinc-700');
                    vcMuteIcon.setAttribute('data-lucide', 'mic');
                }
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }
            }

            // Notify other user about mute status (optional but helpful)
            if (callId && window.firebaseDB) {
                try {
                    const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                    window.firebaseUpdateDoc(callDocRef, {
                        [`muted_${ghostHandle}`]: isMuted
                    }).catch(e => console.warn('Could not update mute status:', e));
                } catch (e) {
                    console.warn('Could not update mute status:', e);
                }
            }

            console.log(`Microphone ${isMuted ? 'muted' : 'unmuted'}`);
        }

        // ============================================
        // VIDEO CALL STATE & FUNCTIONS
        // ============================================
        let currentCallMode = 'audio'; // 'audio', 'video', 'screen'
        let isCameraOff = false;
        let isScreenSharing = false;
        let cameraStream = null; // Store camera stream for swap-back

        // ============================================
        // RING SOUND SYSTEM
        // ============================================
        let ringAudioCtx = null;
        let ringOscillator = null;
        let ringGainNode = null;
        let ringInterval = null;
        let isRinging = false;

        // Start ring sound (outgoing = caller, incoming = receiver)
        function startRingSound(isOutgoing = false) {
            if (isRinging) return; // Already ringing

            try {
                stopRingSound(); // Cleanup any existing

                ringAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                ringOscillator = ringAudioCtx.createOscillator();
                ringGainNode = ringAudioCtx.createGain();

                // Different tones for outgoing vs incoming
                ringOscillator.type = 'sine';
                ringOscillator.frequency.value = isOutgoing ? 440 : 480;
                ringGainNode.gain.value = 0;

                ringOscillator.connect(ringGainNode);
                ringGainNode.connect(ringAudioCtx.destination);
                ringOscillator.start();

                isRinging = true;

                // Ring pattern: 1s on, 2s off
                let ringOn = false;
                const pulseRing = () => {
                    if (!isRinging || !ringGainNode) return;

                    ringOn = !ringOn;
                    ringGainNode.gain.setTargetAtTime(
                        ringOn ? 0.3 : 0,
                        ringAudioCtx.currentTime,
                        0.05
                    );
                };

                pulseRing(); // Start with ring on
                ringInterval = setInterval(pulseRing, 1000);

                console.log(`Ring sound started (${isOutgoing ? 'outgoing' : 'incoming'})`);
            } catch (e) {
                console.warn('Could not start ring sound:', e);
            }
        }

        // Stop ring sound
        function stopRingSound() {
            if (ringInterval) {
                clearInterval(ringInterval);
                ringInterval = null;
            }

            if (ringOscillator) {
                try {
                    ringOscillator.stop();
                } catch (e) { }
                ringOscillator = null;
            }

            if (ringGainNode) {
                try {
                    ringGainNode.disconnect();
                } catch (e) { }
                ringGainNode = null;
            }

            if (ringAudioCtx && ringAudioCtx.state !== 'closed') {
                try {
                    ringAudioCtx.close();
                } catch (e) { }
                ringAudioCtx = null;
            }

            if (isRinging) {
                console.log('Ring sound stopped');
                isRinging = false;
            }
        }
        let callTimerInterval = null;
        let callStartTime = null;

        // Toggle call options popup
        function toggleCallOptions() {
            const popup = document.getElementById('call-options-popup');
            if (popup) {
                popup.classList.toggle('hidden');

                // Hide screen share on mobile or if unsupported
                const screenBtn = popup.querySelector('button[onclick="startCallWithMode(\'screen\')"]');
                if (screenBtn) {
                    if (isMobile || !navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                        screenBtn.classList.add('hidden');
                        screenBtn.classList.remove('md:flex'); // Remove responsive class that might force it to show
                    } else {
                        screenBtn.classList.remove('hidden');
                        screenBtn.classList.add('md:flex');
                    }
                }

                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }
            }
        }

        // Hide call options popup
        function hideCallOptions() {
            const popup = document.getElementById('call-options-popup');
            if (popup) popup.classList.add('hidden');
        }

        // Start call with specific mode
        async function startCallWithMode(mode) {
            hideCallOptions();
            currentCallMode = mode;

            // Start the call with the selected mode
            await initiateCall(mode);
        }

        // Modified initiateCall to accept mode parameter
        // The original initiateCall will be updated to use the mode

        // Toggle camera on/off
        function toggleCamera() {
            if (!localStream || !callActive) {
                console.warn('Cannot toggle camera: no active call or stream');
                return;
            }

            const videoTracks = localStream.getVideoTracks();
            if (videoTracks.length === 0) {
                console.warn('No video tracks to toggle');
                // If in audio mode, might need to add video
                if (currentCallMode === 'audio') {
                    switchCallMode('video');
                }
                return;
            }

            isCameraOff = !isCameraOff;

            videoTracks.forEach(track => {
                track.enabled = !isCameraOff;
                console.log(`Video track ${track.label} ${isCameraOff ? 'disabled' : 'enabled'}`);
            });

            // Update UI
            updateCameraUI();

            console.log(`Camera ${isCameraOff ? 'off' : 'on'}`);
        }

        // Update camera button UI
        function updateCameraUI() {
            const vcCameraBtn = document.getElementById('vc-camera-btn');
            const vcCameraIcon = document.getElementById('vc-camera-icon');
            const localVideo = document.getElementById('local-video');
            const localCameraOff = document.getElementById('local-camera-off');

            if (vcCameraBtn && vcCameraIcon) {
                if (isCameraOff) {
                    vcCameraBtn.classList.remove('bg-zinc-700');
                    vcCameraBtn.classList.add('bg-red-600');
                    vcCameraIcon.setAttribute('data-lucide', 'video-off');
                } else {
                    vcCameraBtn.classList.remove('bg-red-600');
                    vcCameraBtn.classList.add('bg-zinc-700');
                    vcCameraIcon.setAttribute('data-lucide', 'video');
                }
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }
            }

            // Show/hide local video vs camera off indicator
            if (localVideo && localCameraOff) {
                if (isCameraOff || currentCallMode === 'audio') {
                    localVideo.classList.add('hidden');
                    localCameraOff.classList.remove('hidden');
                } else {
                    localVideo.classList.remove('hidden');
                    localCameraOff.classList.add('hidden');
                }
            }
        }

        // Toggle screen sharing using replaceTrack for seamless switch
        async function toggleScreenShare() {
            if (!callActive || !peerConnection) {
                console.warn('Cannot toggle screen share: no active call');
                return;
            }

            const videoSender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');

            if (!isScreenSharing) {
                // START Screen Share
                // Check if screen sharing is supported (not available on most mobile browsers)
                if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                    alert('Screen sharing is not available on mobile browsers. Please install the app on your device to access this feature.');
                    return;
                }

                try {
                    console.log('Starting screen share...');
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { cursor: 'always' },
                        audio: true // System audio if supported
                    });

                    // Store current camera stream for swap-back
                    if (localStream && localStream.getVideoTracks().length > 0) {
                        cameraStream = localStream;
                    }

                    const screenTrack = screenStream.getVideoTracks()[0];

                    // HOT SWAP: Replace video track without reconnection
                    if (videoSender) {
                        await videoSender.replaceTrack(screenTrack);
                        console.log('Screen track replaced successfully (Hot Swap)');
                    } else {
                        // No video sender - need to add track AND renegotiate
                        peerConnection.addTrack(screenTrack, screenStream);
                        console.log('Screen track added to peer connection');

                        // Renegotiation needed when adding new track
                        try {
                            const offer = await peerConnection.createOffer();
                            await peerConnection.setLocalDescription(offer);

                            // Update offer in Firebase
                            if (callId && window.firebaseDB) {
                                const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                                await window.firebaseUpdateDoc(callDocRef, {
                                    offer: {
                                        type: offer.type,
                                        sdp: offer.sdp
                                    },
                                    renegotiation: true
                                });
                                console.log('Renegotiation offer sent for screen share');
                            }
                        } catch (renego_err) {
                            console.error('Renegotiation failed:', renego_err);
                        }
                    }

                    // Update local preview
                    const localVideo = document.getElementById('local-video');
                    if (localVideo) {
                        localVideo.srcObject = screenStream;
                    }

                    // Show video call window if not visible
                    const videoCallWindow = document.getElementById('video-call-window');
                    const activeCallUI = document.getElementById('active-call-interface');
                    if (videoCallWindow && videoCallWindow.classList.contains('hidden')) {
                        videoCallWindow.classList.remove('hidden');
                        if (activeCallUI) {
                            activeCallUI.classList.add('hidden');
                        }
                    }

                    // Listen for browser "Stop Sharing" button
                    screenTrack.onended = () => {
                        console.log('Screen share ended by browser');
                        stopScreenShare();
                    };

                    isScreenSharing = true;
                    currentCallMode = 'screen';
                    updateScreenShareUI(true);
                    updateModeUI('screen');

                    console.log('Screen share started successfully');
                } catch (err) {
                    console.error('Screen share failed:', err);
                    if (err.name !== 'AbortError') { // User didn't just cancel
                        alert('Could not start screen sharing: ' + err.message);
                    }
                }
            } else {
                // STOP Screen Share
                stopScreenShare();
            }
        }

        // Stop screen sharing and revert to camera
        async function stopScreenShare() {
            if (!isScreenSharing) return;

            console.log('Stopping screen share...');
            const videoSender = peerConnection?.getSenders().find(s => s.track && s.track.kind === 'video');

            if (videoSender && cameraStream && cameraStream.getVideoTracks().length > 0) {
                // HOT SWAP BACK: Revert to camera
                try {
                    await videoSender.replaceTrack(cameraStream.getVideoTracks()[0]);
                    console.log('Reverted to camera (Hot Swap)');
                } catch (e) {
                    console.warn('Could not revert to camera:', e);
                }

                // Update local preview
                const localVideo = document.getElementById('local-video');
                if (localVideo) {
                    localVideo.srcObject = cameraStream;
                }
            }

            isScreenSharing = false;
            currentCallMode = 'video';
            updateScreenShareUI(false);
            updateModeUI('video');

            console.log('Screen share stopped');
        }

        // Update screen share button UI
        function updateScreenShareUI(sharing) {
            const vcScreenBtn = document.getElementById('vc-screen-btn');
            const vcScreenIcon = document.getElementById('vc-screen-icon');

            if (vcScreenBtn && vcScreenIcon) {
                if (sharing) {
                    vcScreenBtn.classList.remove('bg-zinc-700');
                    vcScreenBtn.classList.add('bg-purple-600');
                } else {
                    vcScreenBtn.classList.remove('bg-purple-600');
                    vcScreenBtn.classList.add('bg-zinc-700');
                }
            }
        }

        // Switch call mode (audio/video/screen)
        async function switchCallMode(newMode) {
            if (!callActive || !peerConnection) {
                console.warn('Cannot switch mode: no active call');
                return;
            }

            console.log(`Switching call mode from ${currentCallMode} to ${newMode}`);
            hideModeSwitcher();

            const videoSender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');

            if (newMode === 'audio') {
                // Switch to audio-only: disable video track
                if (isScreenSharing) {
                    await stopScreenShare();
                }
                if (videoSender && videoSender.track) {
                    videoSender.track.enabled = false;
                }
                isCameraOff = true;
                currentCallMode = 'audio';
                updateCameraUI();
            }
            else if (newMode === 'video') {
                // Switch to video
                if (isScreenSharing) {
                    await stopScreenShare();
                }

                // Show video call window
                const videoCallWindow = document.getElementById('video-call-window');
                const activeCallUI = document.getElementById('active-call-interface');
                if (videoCallWindow) {
                    videoCallWindow.classList.remove('hidden');
                }
                if (activeCallUI) {
                    activeCallUI.classList.add('hidden');
                }

                // If we have camera stream, enable it
                if (videoSender && videoSender.track) {
                    videoSender.track.enabled = true;
                    isCameraOff = false;

                    // Update local video preview
                    const localVideo = document.getElementById('local-video');
                    if (localVideo && cameraStream) {
                        localVideo.srcObject = cameraStream;
                    }
                } else {
                    // Need to get video stream - use mobile-friendly constraints
                    try {
                        const constraints = isMobile
                            ? { video: { width: 640, height: 480, facingMode: 'user' } }
                            : { video: { width: 1280, height: 720, facingMode: 'user' } };

                        const videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                        const videoTrack = videoStream.getVideoTracks()[0];

                        // Check if we already have a video sender we can replace
                        const existingSender = peerConnection.getSenders().find(s => s.track?.kind === 'video' || !s.track);
                        let needsRenegotiation = false;

                        if (existingSender && existingSender.track === null) {
                            await existingSender.replaceTrack(videoTrack);
                        } else if (!existingSender) {
                            peerConnection.addTrack(videoTrack, videoStream);
                            needsRenegotiation = true; // New track added, need to notify remote
                        } else {
                            await existingSender.replaceTrack(videoTrack);
                        }

                        cameraStream = videoStream;
                        isCameraOff = false;

                        // Update local video preview
                        const localVideo = document.getElementById('local-video');
                        if (localVideo) {
                            localVideo.srcObject = videoStream;
                        }

                        // Update localStream to include video
                        if (localStream) {
                            // Add video track to existing localStream
                            localStream.addTrack(videoTrack);
                        } else {
                            localStream = videoStream;
                        }

                        // Renegotiation if we added a new track
                        if (needsRenegotiation && callId && window.firebaseDB) {
                            try {
                                const offer = await peerConnection.createOffer();
                                await peerConnection.setLocalDescription(offer);

                                const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${callId}`);
                                await window.firebaseUpdateDoc(callDocRef, {
                                    offer: {
                                        type: offer.type,
                                        sdp: offer.sdp
                                    },
                                    renegotiation: true
                                });
                                console.log('Renegotiation offer sent for video mode switch');
                            } catch (renego_err) {
                                console.error('Renegotiation failed:', renego_err);
                            }
                        }

                        console.log('Video track added successfully');
                    } catch (e) {
                        console.error('Could not get video:', e);
                        alert('Could not access camera: ' + e.message);
                    }
                }
                currentCallMode = 'video';
                updateCameraUI();
            }
            else if (newMode === 'screen') {
                // Switch to screen share
                await toggleScreenShare();
                return; // toggleScreenShare handles the mode update
            }

            updateModeUI(currentCallMode);
        }

        // Open mode switcher popup
        function openModeSwitcher() {
            const popup = document.getElementById('mode-switcher-popup');
            if (popup) {
                popup.classList.toggle('hidden');
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }
            }
        }

        // Hide mode switcher popup
        function hideModeSwitcher() {
            const popup = document.getElementById('mode-switcher-popup');
            if (popup) popup.classList.add('hidden');
        }

        // Update mode indicator UI
        function updateModeUI(mode) {
            const modeBadge = document.getElementById('call-mode-badge');
            const miniModeBadge = document.getElementById('mini-call-mode');

            const modeLabels = {
                'audio': 'VOICE CALL',
                'video': 'VIDEO CALL',
                'screen': 'SCREEN SHARE'
            };

            const label = modeLabels[mode] || 'CALL';

            if (modeBadge) modeBadge.textContent = label;
            if (miniModeBadge) miniModeBadge.textContent = label;
        }

        // Minimize video call window to bar
        function minimizeCallWindow() {
            const videoWindow = document.getElementById('video-call-window');
            const miniBar = document.getElementById('active-call-interface');

            if (videoWindow) videoWindow.classList.add('hidden');
            if (miniBar) miniBar.classList.remove('hidden');
        }

        // Expand to full-screen video call window
        function expandCallWindow() {
            const videoWindow = document.getElementById('video-call-window');
            const miniBar = document.getElementById('active-call-interface');

            if (miniBar) miniBar.classList.add('hidden');
            if (videoWindow) {
                videoWindow.classList.remove('hidden');
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons();
                }
            }
        }

        // Start call timer
        function startCallTimer() {
            callStartTime = Date.now();
            if (callTimerInterval) clearInterval(callTimerInterval);

            callTimerInterval = setInterval(() => {
                if (!callActive) {
                    clearInterval(callTimerInterval);
                    return;
                }
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                const timerEl = document.getElementById('call-timer');
                if (timerEl) timerEl.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        // Stop call timer
        function stopCallTimer() {
            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
            }
            const timerEl = document.getElementById('call-timer');
            if (timerEl) timerEl.textContent = '00:00';
        }

        // Close popups when clicking outside
        document.addEventListener('click', (e) => {
            const callOptionsPopup = document.getElementById('call-options-popup');
            const callBtn = document.getElementById('ghost-call-btn');
            const modeSwitcherPopup = document.getElementById('mode-switcher-popup');
            const modeSwitchBtn = document.getElementById('vc-mode-btn');

            // Close call options if clicking outside
            if (callOptionsPopup && !callOptionsPopup.contains(e.target) && !callBtn?.contains(e.target)) {
                callOptionsPopup.classList.add('hidden');
            }

            // Close mode switcher if clicking outside
            if (modeSwitcherPopup && !modeSwitcherPopup.contains(e.target) && !modeSwitchBtn?.contains(e.target)) {
                modeSwitcherPopup.classList.add('hidden');
            }
        });

        // Cleanup call resources - SECURE HANGUP with recursive deletion
        async function cleanupCall() {
            try {
                // Stop any ring sound immediately
                stopRingSound();

                const wasActive = callActive;
                const currentCallId = callId; // Store callId before cleanup
                callActive = false;

                // HARDWARE RELEASE: Stop all tracks IMMEDIATELY to turn off microphone light
                if (localStream) {
                    try {
                        console.log('HANGUP: Stopping all local tracks (hardware release)');
                        localStream.getTracks().forEach(track => {
                            track.stop();
                            track.enabled = false;
                        });
                        console.log('HANGUP: All local tracks stopped - microphone should be off');
                    } catch (e) {
                        console.warn('Error stopping tracks:', e);
                    }
                    localStream = null;
                }

                // Remove current callId from processedCallIds to allow new calls
                if (currentCallId) {
                    processedCallIds.delete(currentCallId);
                    console.log('Removed callId from processedCallIds:', currentCallId);
                }

                // Clear mobile audio check interval
                if (mobileAudioCheckInterval) {
                    clearInterval(mobileAudioCheckInterval);
                    mobileAudioCheckInterval = null;
                }

                // Unsubscribe from all listeners
                if (callUnsubscribe) {
                    callUnsubscribe();
                    callUnsubscribe = null;
                }
                if (answerUnsubscribe) {
                    answerUnsubscribe();
                    answerUnsubscribe = null;
                }
                if (offerCandidatesUnsubscribe) {
                    offerCandidatesUnsubscribe();
                    offerCandidatesUnsubscribe = null;
                }
                if (answerCandidatesUnsubscribe) {
                    answerCandidatesUnsubscribe();
                    answerCandidatesUnsubscribe = null;
                }

                // Re-enable incoming call listener if call was active
                if (wasActive && ghostRoomId && window.firebaseDB) {
                    // Small delay to ensure cleanup is complete
                    setTimeout(() => {
                        if (!callActive) {
                            listenForIncomingCalls();
                        }
                    }, 1000);
                }

                // Disconnect Web Audio API nodes
                if (remoteAudioSource) {
                    try {
                        remoteAudioSource.disconnect();
                    } catch (e) {
                        console.warn('Error disconnecting remote audio source:', e);
                    }
                    remoteAudioSource = null;
                }

                if (localAudioSource) {
                    try {
                        localAudioSource.disconnect();
                    } catch (e) {
                        console.warn('Error disconnecting local audio source:', e);
                    }
                    localAudioSource = null;
                }

                // Reset gain node
                if (remoteGainNode) {
                    try {
                        remoteGainNode.disconnect();
                    } catch (e) {
                        console.warn('Error disconnecting gain node:', e);
                    }
                }

                // Stop remote audio element
                if (remoteAudioElement) {
                    try {
                        remoteAudioElement.pause();
                        remoteAudioElement.srcObject = null;
                        if (remoteAudioElement.src) {
                            remoteAudioElement.src = '';
                        }
                    } catch (e) {
                        console.warn('Error stopping remote audio:', e);
                    }
                    remoteAudioElement = null;
                }

                // Close peer connection
                if (peerConnection) {
                    try {
                        // Remove all tracks before closing
                        peerConnection.getSenders().forEach(sender => {
                            if (sender.track) {
                                sender.track.stop();
                            }
                        });
                        peerConnection.close();
                    } catch (e) {
                        console.warn('Error closing peer connection:', e);
                    }
                    peerConnection = null;
                }

                // Note: We don't close the audio context here to avoid reinitialization overhead
                // It will be reused for the next call

                // RECURSIVE DELETION: Delete call document and all subcollections (ZERO TRACE POLICY)
                if (currentCallId && window.firebaseDB) {
                    try {
                        console.log('HANGUP: Starting recursive deletion for callId:', currentCallId);

                        const callDocRef = window.firebaseDoc(window.firebaseDB, `calls/${currentCallId}`);

                        // CRITICAL FIX: Update call status to 'ended' FIRST so other user gets notification
                        // This ensures both sides know the call has ended before we delete the document
                        try {
                            await window.firebaseUpdateDoc(callDocRef, {
                                status: 'ended',
                                ended: true,
                                endedAt: window.firebaseServerTimestamp(),
                                endedBy: ghostHandle
                            });
                            console.log('HANGUP: Call status updated to ended - other user will be notified');

                            // Wait briefly for the other user to receive the status change
                            await new Promise(resolve => setTimeout(resolve, 500));
                        } catch (updateError) {
                            console.warn('HANGUP: Could not update call status (may already be deleted):', updateError);
                        }

                        // First, delete subcollections (offerCandidates and answerCandidates)
                        try {
                            // Delete offerCandidates subcollection
                            const offerCandidatesRef = window.firebaseCollection(window.firebaseDB, `calls/${currentCallId}/offerCandidates`);
                            const offerCandidatesSnapshot = await window.firebaseGetDocs(offerCandidatesRef);

                            const deletePromises = [];
                            offerCandidatesSnapshot.forEach((doc) => {
                                deletePromises.push(window.firebaseDeleteDoc(window.firebaseDoc(window.firebaseDB, `calls/${currentCallId}/offerCandidates/${doc.id}`)));
                            });

                            // Delete answerCandidates subcollection
                            const answerCandidatesRef = window.firebaseCollection(window.firebaseDB, `calls/${currentCallId}/answerCandidates`);
                            const answerCandidatesSnapshot = await window.firebaseGetDocs(answerCandidatesRef);

                            answerCandidatesSnapshot.forEach((doc) => {
                                deletePromises.push(window.firebaseDeleteDoc(window.firebaseDoc(window.firebaseDB, `calls/${currentCallId}/answerCandidates/${doc.id}`)));
                            });

                            // Wait for all subcollection deletions
                            if (deletePromises.length > 0) {
                                await Promise.all(deletePromises);
                                console.log(`HANGUP: Deleted ${deletePromises.length} candidate documents from subcollections`);
                            }
                        } catch (subCollectionError) {
                            console.warn('HANGUP: Error deleting subcollections (may not exist):', subCollectionError);
                        }

                        // Delete the main call document
                        await window.firebaseDeleteDoc(callDocRef);
                        console.log('HANGUP: Call document deleted from Firestore');
                        console.log('SECURE HANGUP: Call metadata wiped from server.');

                    } catch (e) {
                        console.warn('HANGUP: Could not delete call document (may already be deleted):', e);
                        // Still log the secure hangup message
                        console.log('SECURE HANGUP: Cleanup completed (document may have been already deleted).');
                    }
                } else {
                    console.log('SECURE HANGUP: No callId to delete (call may not have been established).');
                }

                // Release wake lock
                releaseWakeLock();

                // Stop call timer
                stopCallTimer();

                // Hide UI - both video window and mini bar
                const activeCallUI = document.getElementById('active-call-interface');
                if (activeCallUI) activeCallUI.classList.add('hidden');
                const videoCallWindow = document.getElementById('video-call-window');
                if (videoCallWindow) videoCallWindow.classList.add('hidden');
                const incomingModal = document.getElementById('incoming-call-modal');
                if (incomingModal) incomingModal.classList.add('hidden');
                const callBtn = document.getElementById('ghost-call-btn');
                if (callBtn) callBtn.classList.remove('hidden');

                // Clear video elements
                const localVideo = document.getElementById('local-video');
                if (localVideo) localVideo.srcObject = null;
                const remoteVideo = document.getElementById('remote-video');
                if (remoteVideo) remoteVideo.srcObject = null;

                // Show video placeholder
                const videoPlaceholder = document.getElementById('video-placeholder');
                if (videoPlaceholder) videoPlaceholder.classList.remove('hidden');

                // UI RESET: Reset all call-related variables to prevent memory leaks
                const endedCallId = currentCallId;
                callId = null;
                isCaller = false;

                // Reset video call state
                currentCallMode = 'audio';
                isCameraOff = false;
                isScreenSharing = false;
                cameraStream = null;

                // Reset all call-related variables
                remoteAudioSource = null;
                remoteGainNode = null;
                remoteAnalyser = null;
                localAnalyser = null;
                compressorNode = null;
                limiterNode = null;

                console.log('HANGUP: All call variables reset (UI reset complete)');

                // Ensure ended call is removed from processedCallIds
                if (endedCallId) {
                    processedCallIds.delete(endedCallId);
                    console.log('Removed ended callId from processedCallIds:', endedCallId);
                }

            } catch (error) {
                console.error('Error in cleanupCall:', error);
                // Force cleanup even if there's an error
                callActive = false;
                isMuted = false; // Reset mute state
                if (callId) {
                    processedCallIds.delete(callId);
                }
                callId = null;
                isCaller = false;
            }
        }

        // Cleanup on disconnect
        async function disconnectGhostWithCleanup() {
            await cleanupCall();
            if (callUnsubscribe) {
                callUnsubscribe();
                callUnsubscribe = null;
            }
            disconnectGhost();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', async () => {
            if (callActive) {
                await cleanupCall();
            }
        });

        // Cleanup on page visibility change (mobile tab switch)
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden && callActive) {
                // Page is hidden, but don't cleanup - just pause
                if (remoteAudioElement) {
                    remoteAudioElement.pause();
                }
                // Suspend audio context to save resources
                if (callAudioContext && callAudioContext.state !== 'closed') {
                    await callAudioContext.suspend();
                }
            } else if (!document.hidden && callActive) {
                // Page is visible again, resume audio
                try {
                    if (callAudioContext && callAudioContext.state === 'suspended') {
                        await callAudioContext.resume();
                    }
                    if (remoteAudioElement) {
                        await remoteAudioElement.play();
                    }
                } catch (e) {
                    console.warn('Could not resume audio:', e);
                }
            }
        });

        // Handle page focus/blur for better audio management
        window.addEventListener('blur', async () => {
            if (callActive && callAudioContext && callAudioContext.state !== 'closed') {
                // Reduce volume slightly when page loses focus
                if (remoteGainNode) {
                    remoteGainNode.gain.setTargetAtTime(
                        remoteGainNode.gain.value * 0.8,
                        callAudioContext.currentTime,
                        0.1
                    );
                }
            }
        });

        window.addEventListener('focus', async () => {
            if (callActive && callAudioContext) {
                if (callAudioContext.state === 'suspended') {
                    await callAudioContext.resume();
                }
                // Restore volume when page regains focus
                if (remoteGainNode) {
                    remoteGainNode.gain.setTargetAtTime(
                        Math.min(0.8, remoteGainNode.gain.value * 1.2),
                        callAudioContext.currentTime,
                        0.1
                    );
                }
            }
        });

        // Add volume control function for user adjustment
        function adjustCallVolume(volume) {
            if (remoteGainNode && callAudioContext) {
                const clampedVolume = Math.max(0.1, Math.min(1.0, volume));
                remoteGainNode.gain.setTargetAtTime(
                    clampedVolume,
                    callAudioContext.currentTime,
                    0.1
                );
                if (remoteAudioElement) {
                    remoteAudioElement.volume = clampedVolume;
                }
            }
        }

        // Get optimal audio device
        async function getOptimalAudioDevice() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');

                // Prefer devices with "headset" or "headphone" in the name (better echo cancellation)
                const headsetDevice = audioInputs.find(device =>
                    device.label.toLowerCase().includes('headset') ||
                    device.label.toLowerCase().includes('headphone')
                );

                if (headsetDevice) {
                    return { deviceId: { exact: headsetDevice.deviceId } };
                }

                // Fallback to default
                return true;
            } catch (error) {
                console.warn('Could not enumerate devices:', error);
                return true; // Use default
            }
        }

        // Enhanced media constraints with device selection
        const getEnhancedMediaConstraints = async () => {
            const baseConstraints = getMediaConstraints();
            const deviceId = await getOptimalAudioDevice();

            if (deviceId !== true) {
                baseConstraints.audio.deviceId = deviceId;
            }

            return baseConstraints;
        };

        // Check microphone permissions
        async function checkMicrophonePermission() {
            try {
                if (navigator.permissions && navigator.permissions.query) {
                    const result = await navigator.permissions.query({ name: 'microphone' });
                    return result.state; // 'granted', 'denied', or 'prompt'
                }
                // Fallback: try to get media to check permission
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());
                    return 'granted';
                } catch (e) {
                    if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                        return 'denied';
                    }
                    return 'prompt';
                }
            } catch (e) {
                console.warn('Could not check microphone permission:', e);
                return 'prompt'; // Assume we can prompt
            }
        }

        // Request microphone permission with better error handling
        async function requestMicrophoneAccess() {
            try {
                // First check current permission state
                const permissionState = await checkMicrophonePermission();

                if (permissionState === 'denied') {
                    throw new Error('Microphone permission was denied. Please enable it in your browser settings.');
                }

                // Try to get media with basic constraints first
                const basicConstraints = { audio: true };
                const stream = await navigator.mediaDevices.getUserMedia(basicConstraints);

                // Stop the test stream
                stream.getTracks().forEach(track => track.stop());

                return true;
            } catch (error) {
                console.error('Microphone access error:', error);
                throw error;
            }
        }


    </script>
</body>

</html>
